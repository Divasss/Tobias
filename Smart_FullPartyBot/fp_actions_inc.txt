unit fp_actions_inc;
interface

function Action_CheckForCombatInitiation: Boolean;
function Check_LowHpMode_Actions: Boolean;
function CheckRemove_BuffsByList: Boolean;

function Do_L2Idle_Rebuff(takeShadow: Boolean = false): Boolean;
function DoRebuff(takeShadow: Boolean = false): Boolean;
function DoRebuff_Pet: Boolean;
function ComTalk(Word: string): void;
function Action_GoClose(caller: string; randomRange: Integer): Boolean;
function Action_AssistPk(caller: string): boolean;
function Action_PullMobs: Boolean;
function PortRandomTown(): void;
function MoveZaken: Void;
function MoveFreya(): void;
function MoveTo_LoaForceFieldBridge: void;
function ExitInstance(): void;
function Action_UseSingleSkill_Force: Boolean;
function Action_UseNukeSkill: Boolean;

function CheckUse_Tank_Pvp_Buff: Boolean;
function CheckUse_Tank_Pve_Buff: Boolean;
function CheckUse_Tank_Overall_Buff: Boolean;
function CheckUse_InsaneCrusher: Boolean;
function CheckUse_ShadowSnare: Boolean;
function CheckUse_Tank_MiscPvp_Skills: Boolean;
function CheckUse_SigelAoeAgro: Boolean;
function CheckUse_CenterPull: Boolean;

function UseSkill_Tank_Agro_Pvp: Boolean;
function UseSkill_Tank_Attack_Pvp: Boolean;
function UseSkill_Tank_Agro_Pve: Boolean;
function UseSkill_Tank_Attack_Pve: Boolean;
function UseSkill_Aggression_Pve: Boolean;
function UseSkill_Aggression_Pvp: Boolean;

function UseSkill_Ol_AoeAttack_Pvp: Boolean;
function UseSkill_Slh_AoeAttack_Pvp: Boolean;
function UseSkill_Slh_AoeAttack_Pve: Boolean;
function UseSkill_Slh_SingleAttack_Pve: Boolean;
function CheckUse_Dagger_Pvp_Buff: Boolean;
function CheckUse_Doombringer_Pvp_Buff: Boolean;


function LeadDlg( TargetID: Integer; Ans1: Integer = 1; Ans2: Integer = -1; Ans3: Integer = -1; Ans4: Integer = -1; Ans5: Integer = -1; Ans6: Integer = -1): Boolean;
function OpenGK: Void;
function MoveTo_InsideFog: boolean;
function CheckBuff_Cov: void;
function Restock: Boolean;
function CheckPickupDrops: void;

function CheckSwsBd_Aoe: Boolean;
function PullMobs_CleanList(): void;

function BuyAndSendDyesToParty: void;
function SoaTunnelMove(StartRandomDelay: Integer): Void;
function SellAllItems: void;
function DepositAllItems_ToClanWh: void;
function WalkRandom(MinRange, MaxRange: Integer): Void;
function AutoFollow: Boolean;

function Action_CircleAgroMove(roundNum: Integer; mainAssist: Tl2Char): void;
function AutoFollow_Move(oLeader: Tl2Char; randomRange, distance: Integer; currentPosition: Boolean): Boolean;

function MoveTo_Timer(x, y, z: Integer; delay: Integer = -1): Boolean;

function TakePartyBuffs: Boolean;
function IsAnyoneMissingABuff(minTimeLeft: Integer; mageBuffs: Boolean = true; selfOnly: Boolean = false): Boolean;
function CheckBuffs_L2Idle: Boolean;

function Speak_ItemsCount_Party: void;


function CheckWalk_ToBack_AndStab(): Boolean;
function UseStabSkill(oTarget: Tl2Live): Boolean; overload;
function UseStabSkill(oTarget: Tl2Char): Boolean; overload;

function Check_AvoidBubbles: Boolean;

function CheckCreateParty: Boolean;

implementation
uses
SysUtils, Classes, global_vars, fp_target_inc, fp_inc, fp_char_info, fp_math_inc, fp_ap, aoe;


function LeadDlg( TargetID: Integer;
                  Ans1: Integer = 1;
                  Ans2: Integer = -1;
                  Ans3: Integer = -1;
                  Ans4: Integer = -1;
                  Ans5: Integer = -1;
                  Ans6: Integer = -1): Boolean;
//checked
var
obj : Tl2Spawn;
b1, b2, b3, b4, b5, b6: Boolean;
begin
	result := false;
	
	b1 := true;
	b2 := true;
	b3 := true;
	b4 := true;
	b5 := true;
	b6 := true;
	if not npclist.byid(TargetID, obj) then exit;
	if (User.Distto(obj) <= 900) then begin
		Engine.CancelTarget;
		Engine.SetTarget(TargetID);
		if (User.DistTo(obj) > 100) then
			Engine.MoveToTarget(-100);  
		Delay(500);
		Engine.DlgOpen;
		Delay(1000);
		if not(Ans1 = -1)then begin
			b1 := Engine.DlgSel(Ans1); 
			Delay(1000);
		end;
		if not(Ans2 = -1)then begin
			b2 := Engine.DlgSel(Ans2); 
			Delay(1000);
		end;
		if not(Ans3 = -1)then begin
			b3 := Engine.DlgSel(Ans3); 
			Delay(1000);
		end;
		if not(Ans4 = -1)then begin
			b4 := Engine.DlgSel(Ans4); 
			Delay(1000);
		end;
		if not(Ans5 = -1)then begin
			b5 := Engine.DlgSel(Ans5); 
			Delay(1000);
		end;
		if not(Ans6 = -1)then begin
			b6 := Engine.DlgSel(Ans6); 
			Delay(1000);
		end; 
	end else begin
	  Print('Conversation: Target npc not in range');
	end;
	result := b1 and b2 and b3 and b4 and b5 and b6;
end;

function AutoFollow: Boolean;
var
oTargetToFollow: Tl2Char;
begin
	result := false;
	Print('AutoFollow - Started');
	if not FollowEnabled then begin
		Print('AutoFollow ended, not enabled.');
		exit;
	end;
	oTargetToFollow := GetTarget_ToFollow;
	if not (oTargetToFollow = nil) and not (oTargetToFollow.Oid = user.Oid) then begin
		AutoFollow_Move(oTargetToFollow, FOLLOW_RANDOM_RANGE, FOLLOW_DIST, FOLLOW_CURRENT_POSITION);
	end else begin
		//print('Auto Follow: No target found...');
	end;
	
	Print('AutoFollow - Ended');
	//AutoFollow_Move(oLeader: Tl2Char; randomRange, distance: Integer; currentPosition: Boolean): Boolean;
end;

function CheckBuffs_L2Idle: Boolean;
var
minHp: Integer;
isMageParty: Boolean;
begin
	result := false;
	//L2 Idle party buff item
	if (HasItem_MinCount(Engine, 40001, 1)) then begin
	
		isMageParty := (GetPartyNum = 1) or (GetPartyNum = 2);
		if not User.InCombat
		and not User.Pvp
		and (IsAnyoneMissingABuff(3600000, isMageParty)) then begin 
			TakePartyBuffs;
		end else if (IsAnyoneMissingABuff(500000, isMageParty)) then begin
			if Engine.GetFaceState(0) then begin
				tempBuffBotPause := true;
				Engine.FaceControl(0, false);
			end;
				
			AutoFollow();	
			result := true;
		end else if (tempBuffBotPause) then begin
			tempBuffBotPause := false;
			Engine.FaceControl(0, true);
		end;
	end;
end;
function OpenGK: Void;
var
serverName: string;
counter: Integer;
Begin
	GetOutOfCombat;
	serverName := GetName_Server;
	counter := 0;
	if (serverName = 'Idle') then begin
		if (User.DistTo(147854, -55332, -2728) > 700) then begin
			if (User.DistTo(147715, -56486, -2776) > 400) then begin
				PortToGoddard;
				(*
				while User.InCombat do begin
					Delay(1000);
					counter := counter + 1;
					if (counter > 5) then break;
				end;
				Delay(500);
				cEnterText('.goddard');
				Delay(4000 + Random(1000));
				*)
			end;
			Engine.MoveTo(147819, -56526, -2776);
			Engine.MoveTo(147814, -56353, -2776);
			Engine.MoveTo(147850, -55849, -2752);
			Engine.MoveTo(147871, -55340, -2728);
			Delay(1000);
		end;
		Engine.MoveTo(147878, -55228, -2728);
		if (User.InRange(147901, -55252, -2728, 300)) then begin
			Engine.SetTarget(32792);
			Delay(500);
			Engine.DlgOpen();
			Delay(1000);
			exit;
		end else begin
			print('cant port, wrong location');
			exit;
		end;
	end;
	
	if (serverName = 'Tales') then begin
		ComTalk('_bbshome');
		ComTalk('services');
		ComTalk('00');

	end else if (serverName = 'GreenWorld') then begin
		ComTalk('_bbshome');
		ComTalk('_bbsgetfav');
		ComTalk('_bbsgatekeeper');

	end else if (serverName = 'InJustice') then begin
		ComTalk('_bbshome');
		ComTalk('_bbsgetfav');
		ComTalk('_bbsgatekeeper');


	end else if (serverName = 'Apocalyps') then begin
		ComTalk('_bbshome');
		ComTalk('01');
		ComTalk('09');


	end else if (serverName = 'World') then begin
		ComTalk('_bbshome');
		ComTalk('_bbsfile:bbs_npcs');
		ComTalk('_bbsgatekeeper');


	end else if (serverName = 'Lionna') then begin
		ComTalk('_bbshome');
		ComTalk('_bbsgetfav');
		ComTalk('00');


	end else if (serverName = 'Devil') then begin
		ComTalk('_bbshome');
		ComTalk('_bbsgetfav');

	end;
	Delay(Random(8000));
end;

function PortRandomTown(): void;
var
townCount, rand: Integer;
begin
	
	if (GetName_Server = 'Idle') or (GetName_Server = 'Devil') then begin
		PortToGoddard;
		exit;
	end;

	
	
	townCount := 17;
	rand := Random(townCount);
	
	PortToTown_ByNum(rand);
	exit;
	
	case rand of 
		0 : PortToGiran;
		1 : PortToDion;
		2 : PortToOren;
		3 : PortToGludio;
		4 : PortToGludin;
		5 : PortToAden;
		6 : PortToHeine;
		7 : PortToHunters;
		8 : PortToRune;
		9 : PortToGoddard;
		else PortToGiran;
	end;

end;

function Action_GoClose(caller: string; randomRange: Integer): Boolean;
var
oTarget: Tl2Char;
dist, x, y, z: Integer;
randomMovePoint: TPoint;
begin
	result := false;
	print('go close to ' + caller);
	if not(Charlist.ByName(caller, oTarget)) then exit;
	if (oTarget = nil)
	or (oTarget.Dead) 
	or (User.DistTo(oTarget) > 2500) then Exit;
	
	dist := User.DistTo(oTarget); 
	if (dist < 200) then exit;
	
	x := oTarget.x;
	y := oTarget.y;
	z := oTarget.z;
	//Function declaraction note
	//function GetRandomPointInCircle(radius, centerX, centerY: Integer): TPoint;
	randomMovePoint := GetRandomPointInCircle(randomRange, x, y);
	x := randomMovePoint.X;
	y := randomMovePoint.Y;
	MoveTo_Timer(x, y, z);
	Delay(300);
	result := true;
end;

function Action_AssistPk(caller: string): boolean;
var
oCaller: Tl2Char;
begin
	result := false;
	if not CharList.ByName(caller, oCaller) then Exit;
	if (oCaller = nil) then Exit;

	if (oCaller.Target = nil) then Exit;
	
	if not (User.Target = oCaller.Target) then begin
		Engine.SetTarget(oCaller.Target);
		delay(150);
	end;
	if not (User.Target = oCaller.Target) then Exit;
	
	Action_UseSingleSkill_Force;
	
	result := true;
end;

function Action_UseSingleSkill_Force: Boolean;
var
skillId, castRange: Integer;
oTarget: Tl2Live;
begin 
	result := false;
	castRange := 900;
	skillId := 0;

	if (HasSkill_Ready(11026)) then begin//Wind Destruction
		castRange := 1100;
		skillId := 11026;
	end else if HasSkill_Ready(11017) then begin//Elemental Crash
		castRange := 1100;
		skillId := 11027;
	end else if HasSkill_Ready(10762) then begin//Quick Shot
		castRange := 1100;
		skillId := 10762;
	end else if HasSkill_Ready(10760) then begin//Tornado Shot
		castRange := 1100;
		skillId := 10760;
		
		
	
	end else if HasSkill_Ready(1230) then 
		skillId := 1230
	else if HasSkill_Ready(1235) then 
		skillId := 1235
	else if HasSkill_Ready(1239) then 
		skillId := 1239
	else if HasSkill_Ready(1148) then 
		skillId := 1148
	else if HasSkill_Ready(1530) then 
		skillId := 1530
	else if HasSkill_Ready(1436) then 
		skillId := 1436
	else if HasSkill_Ready(1245) then 
		skillId := 1245
	else if HasSkill_Ready(1175) then 
		skillId := 1175
	else if HasSkill_Ready(1148) then 
		skillId := 1148
	else if HasSkill_Ready(1433) then //Abyssal Blaze - Judi
		skillId := 1433
	else
		skillId := 0;
		
	if (skillId = 0) then begin
		result := Engine.Attack(50, true);
		exit;
	end;
		
	if (skillId = 1175) then
		castRange := 750
	else if (skillId = 1436) or (skillId = 1433) then
		castRange := 700;	//Soul of Pain or Abyssal Blaze
		
	if (castRange > 200) then castRange := castRange - 100; 
		
	oTarget := User.Target;
	if (oTarget = nil) or ((oTarget.Name = '') and not allowEmptyStringMobNames) then exit;
	if (User.DistTo(oTarget) > castRange) then begin
		MoveToTarget_Timeout_Live(oTarget, castRange, 2000);
	end;
	if (User.DistTo(oTarget) > castRange + 100) then begin
		result := true;
		exit;
	end;
	if HasSkill_Ready(skillId) then
		result := Engine.DUseSkill(skillId, True, False);
end;


function Action_UseNukeSkill: Boolean;
var
skillId: Integer;
oTarget: Tl2Live;
begin 
	result := false;
	skillId := 0;

	if (HasSkill_Ready(11026)) then begin//Wind Destruction
		skillId := 11026;
	end else if HasSkill_Ready(11017) then begin//Elemental Crash
		skillId := 11027;
	end else if HasSkill_Ready(10762) then begin//Quick Shot
		skillId := 10762;
	end else if HasSkill_Ready(10760) then begin//Tornado Shot
		skillId := 10760;
		
		
	
	end else if HasSkill_Ready(1230) then 
		skillId := 1230
	else if HasSkill_Ready(1235) then 
		skillId := 1235
	else if HasSkill_Ready(1239) then 
		skillId := 1239
	else if HasSkill_Ready(1148) then 
		skillId := 1148
	else if HasSkill_Ready(1530) then 
		skillId := 1530
	else if HasSkill_Ready(1436) then 
		skillId := 1436
	else if HasSkill_Ready(1245) then 
		skillId := 1245
	else if HasSkill_Ready(1175) then 
		skillId := 1175
	else if HasSkill_Ready(1148) then 
		skillId := 1148
	else if HasSkill_Ready(1433) then //Abyssal Blaze - Judi
		skillId := 1433
	else
		skillId := 0;
		
	if (skillId = 0) then begin
		result := Engine.Attack(50);
		exit;
	end;
		
	if HasSkill_Ready(skillId) then
		result := Engine.DUseSkill(skillId, False, False);
end;

function PullMobs_CleanList(): void;
var
i: Integer;
oTarget: Tl2Live;
begin
	for i := 0 to pulledMobList.Count - 1 do begin
		oTarget := Tl2Live(pulledMobList.Items(i));
		if (oTarget = nil) or (not oTarget.Valid) or (oTarget.Dead) then begin 
			pulledMobList.Delete(i);
			Print('Deleted mob with oid = ' + IntToStr(oTarget.Oid));
			PullMobs_CleanList();
			exit;
		end else if IsMobGone(oTarget.Oid) then begin
			pulledMobList.Delete(i);
			Print('Deleted mob with oid = ' + IntToStr(oTarget.Oid));
			PullMobs_CleanList();
			exit;
		end;
	end;
	print('Mob Pulling List Count = ' + IntToStr(pulledMobList.Count));
end;

function IsMobGone(oMobOid: Integer): Boolean;
var
i: Integer;
oTarget: Tl2Live;
begin
	result := true;
	for i := 0 to NpcList.Count - 1 do begin
		oTarget := NpcList.Items(i);
		if (oTarget = nil) then continue;
		if (User.DistTo(oTarget) > MAX_RANGE_NPC_SEARCH) then break;
		if (oTarget.Oid = oMobOid) then begin
			result := false;
			exit;
		end;	
	end;
end;

function Action_PullMobs(): Boolean;
var
oTarget: Tl2Live;
x, y, z: Integer;
begin
	result := false;
	
	if not isJava then begin
		result := Action_PullMobs_NonJava;
		exit;
	end;
	
	if (pullMobs_Cooldown > 0) then begin
		pullMobs_Cooldown := pullMobs_Cooldown - 1;
		if (pullMobs_Cooldown = 0) then begin
			Print('Mobs Pulling: Time passed, start pulling again...');
		end;
		exit;
	end;
	if (User.Hp < 65) then begin
		pullMobs_Cooldown := 30;
		Print('Mobs Pulling: Low hp, take a break...');
	end;
	//if GetCount_EnemiesNearTarget_Pve_Char(User, 400)
	if (MONSTER_SOCIAL_RANGE > 0) then
		oTarget := GetTarget_MostClustered_WithinRange_NonAgroed_InZone(1500)
	else 
		oTarget := GetTarget_Nearest_WithinRange_NonAgroed_InZone(1500);
		
	if (oTarget = nil) or (oTarget = (user as tl2live)) then exit;
	
	if (oTarget.CurHp < oTarget.MaxHp) then begin
		if (pulledMobList.IndexOf(oTarget) < 0) then begin
			pulledMobList.Add(oTarget);
			Print('Added mob with oid = ' + IntToStr(oTarget.Oid));
		end;
		if (MONSTER_SOCIAL_RANGE > 0) then
			AddSourrondingMobsToPulledList_ByRange(oTarget, MONSTER_SOCIAL_RANGE);
		exit;
	end;

	//Bot off
	Engine.FaceControl(0, false);
	
	if not (User.Target = oTarget) then begin
		Engine.CancelTarget();
		Engine.SetTarget(oTarget);
	end;
	
	result := Action_UseSingleSkill_Force;
	Delay(200);
	if (User.Cast.EndTime = 0) then begin
		x := oTarget.X; 
		y := oTarget.Y; 
		z := oTarget.Z;
		MoveTo_Timer(x, y, z);
	//end else if (User.Cast.EndTime > 0) then begin
		//while (User.Cast.EndTime > 0) and (User.Cast.EndTime < 300000) do delay(500)) do Delay(300);
	end;
	//Bot on
	Engine.FaceControl(0, true);
end;



function AddSourrondingMobsToPulledList_ByRange(oCenterTarget: Tl2Live; range: Integer): void;
var
i: Integer;
oTarget: Tl2Live;
begin
	//print('Check sorrounding mobs within range of ' + inttostr(range));
	if (pulledMobList = nil) then exit;
	if (oCenterTarget = nil) or ((oCenterTarget.Name = '') and not allowEmptyStringMobNames) then exit;
	
	for i := 0 to NpcList.Count - 1 do begin
		oTarget := NpcList.Items(i);
		if (oTarget = nil) 
		or ((oTarget.Name = '') and not allowEmptyStringMobNames) 
		or (oTarget.Dead) 
		or (not oTarget.Attackable) then continue;
		//print('checking target: ' + oTarget.Name + ',   with dist to CenterTarget = ' + IntToStr(oTarget.DistTo(oCenterTarget)));
		
		if (User.DistTo(oTarget) > MAX_RANGE_NPC_SEARCH) then break;
		
		if (oTarget = oCenterTarget) then continue;
		if (oTarget.DistTo(oCenterTarget) > range) then continue;
			
			
		//At this time, all mobs should be within range of MONSTER_SOCIAL_RANGE
		if (pulledMobList.IndexOf(oTarget) < 0) then begin
			pulledMobList.Add(oTarget);
			Print('Added sorrounding mob with oid = ' + IntToStr(oTarget.Oid));
		end;
	end;
	//print('AddSourrondingMobsToPulledList_ByRange exited with i+1 = ' + IntToStr(i+1));
end;

function Action_PullMobs_NonJava(): Boolean;
var
oTarget: Tl2Live;
x, y, z: Integer;
begin
	result := false;
	
	if (GetCount_EnemiesAttackingUs_Pve(1500) > MAX_ATTACKING_MOBS_TO_PULL) then exit;
	
	if (pullMobs_Cooldown > 0) then begin
		pullMobs_Cooldown := pullMobs_Cooldown - 1;
		if (pullMobs_Cooldown = 0) then begin
			Print('Mobs Pulling: Time passed, start pulling again...');
		end;
		exit;
	end;
	if (User.Hp < 65) then begin
		pullMobs_Cooldown := 30;
		Print('Mobs Pulling: Low hp, take a break...');
	end;
	
	if (MONSTER_SOCIAL_RANGE > 0) then
		oTarget := GetTarget_MostClustered_WithinRange_NonAgroed_InZone(1500, true)
	else 
		oTarget := GetTarget_Nearest_WithinRange_NonAgroed_InZone(1500, true);
		
	if (oTarget = nil) or (oTarget = (user as tl2live)) then exit;

	//Bot off
	Engine.FaceControl(0, false);
	
	if not (User.Target = oTarget) then begin
		Engine.CancelTarget();
		Engine.SetTarget(oTarget);
	end;
	
	result := Action_UseSingleSkill_Force;
	Delay(200);
	if (User.Cast.EndTime = 0) then begin
		x := oTarget.X; 
		y := oTarget.Y; 
		z := oTarget.Z;
		MoveTo_Timer(x, y, z);
	end;
	//Bot on
	if not TotalPause then
		Engine.FaceControl(0, true);
end;

function Action_CircleAgroMove(roundNum: Integer; mainAssist: Tl2Char): void;
var
AoePoint: TPoint;
begin
	if not (MainAssist = nil) and (Charlist.ByName(mainAssist.Name, mainAssist)) then begin
		AoePoint := Point(mainAssist.x, mainAssist.y);
	end else begin
		AoePoint := Point(User.x, User.y);
		Print('MainAssist or is me CAN NOT BE FOUND, ERROR!!! ');
	end;
		
	aoe.CircleAgro_Iteration(AoePoint, roundNum, true, interlude);
end;


function MoveTo_InsideFog: boolean;
begin
	result := false;
	Engine.FaceControl(0, false);
	Delay(Random(15000));	
	PortFog;
	Delay(Random(5000));
	Engine.MoveTo(169320, -116280, -2360);
	Engine.MoveTo(169944, -116296, -2152);
	Engine.MoveTo(170280, -116264, -2016);
	Engine.MoveTo(170920, -116216, -2056);
	Engine.MoveTo(171392, -116293, -2086);
	Engine.MoveTo(171648, -116325, -2141);
	Engine.MoveTo(171928, -116376, -2675);
	Engine.MoveTo(172474, -116415, -3176);
	Engine.MoveTo(172902, -116338, -3362);
	Engine.MoveTo(173214, -116182, -3512);
	Engine.MoveTo(173384, -115944, -3648);
	Engine.MoveTo(173497, -115665, -3712);
	Engine.MoveTo(173765, -115499, -3748);
	Engine.MoveTo(174141, -115549, -3768);
	Engine.MoveTo(174570, -115635, -3758);
	Engine.MoveTo(174974, -115723, -3768);
	Engine.MoveTo(175299, -115858, -3764);
	Engine.MoveTo(175621, -116000, -3754);
	Engine.MoveTo(176047, -116128, -3768);
	Engine.MoveTo(GetRandomXInCircle(100, 176344), GetRandomYInCircle(100, -116232), -3768);
	result := user.InRange(176344, -116232, -3768, 500);
end;	


function Action_CheckForCombatInitiation: Boolean;
var
oEnemy: Tl2Char;
begin
	result := false;
    if PvpLoaded
    and not TempOff then begin	
		if not (User.Target = nil) then begin
			if (CharList.ByName(User.Target.Name, oEnemy))
			and not (oEnemy = nil)
			and (IsTarget_Valid_Char(oEnemy))
			and (User.DistTo(oEnemy) <= 900)
			and not (User.InCombat) then begin
				Print('Initiate PvP Combat!');
				if IsClass_FighterType(User.ClassId) then
					Engine.Attack(50, true)
				else
					Action_UseSingleSkill_Force;
					
				result := true;
			end;
		end;
	end;	
end;


function CheckBuff_Cov: void;
var
oBuff: Tl2Effect;
begin	
	if not (user.InCombat or User.PVP or User.PK)
	and not(User.Buffs.ById(1363, oBuff)) 
	and not user.dead then begin
		if (GetName_Server = 'PlayInera') then begin
			Print('CheckBuff_Cov not implemented for PlayInera!');
		end;
	end;
	
end;


function DoRebuff(takeShadow: Boolean = false): Boolean;
var
serverName: string;
begin
	result := false;
	if (interlude)  then begin
		Print('DoRebuff is not implemented for interlude');
		exit;
	end;
	serverName := GetName_Server;
	
	
	if (serverName = 'Idle') then begin
		Do_L2Idle_Rebuff(takeShadow);
	(*
		cEnterText('.goddard');
		Delay(15000);
		Engine.MoveTo(147754, -55376, -2728);
		Delay(1000);
		if (User.InRange(147754, -55376, -2728, 300)) then begin
			Engine.SetTarget(32793);
			Delay(500);
			Engine.DlgOpen();
			Delay(1500);
			Engine.DlgSel(11);
			Delay(1500);
			Engine.DlgSel(2);
			result := true;
		end else begin
			print('cant buff, wrong location');
			exit;
		end;
		
	*)
	end else if (serverName = 'Tales') then begin
		ComTalk('buffer');
		ComTalk(GetPersonalBuffMessage);
		result := true;
	end else if (serverName = 'PlayInera') then begin
		ComTalk('_bbshome');
		ComTalk('02');
		ComTalk(GetPersonalBuffMessage);
		result := true;
	end else if (serverName = 'Apocalyps') then begin
		ComTalk('_bbshome');
		ComTalk('01');
		ComTalk('0a');
		if (User.ClassId = 21) then ComTalk('0b')
		else ComTalk('01a');
	end else if (serverName = 'World') then begin
		ComTalk('_bbshome');
		ComTalk('_bbsfile:bbs_npcs');
		ComTalk('_bbsbuffer');
		if not (GetBuffMessage_World = '') then ComTalk(GetBuffMessage_World);
		result := true;
	end else if (serverName = 'Devil') then begin
		ComTalk('_bbshome');
		ComTalk('_bbsgetfav');
		ComTalk('_bbsservicesbuffer_0');
		ComTalk('_doschemebuff_1');
		
		result := true;
		
	end;
end;

function GetBuffMessage_World: string;
begin
	result := '';
	if (User.Level < 81) then begin
		if IsClass_FighterType(User.ClassId) then result := '_bbsbufferbypass_giveBuffSet figher 0 0'
		else result := '_bbsbufferbypass_giveBuffSet mage 0 0';
		exit;
	end;
	if (User.Name = 'Kaballius') then result := '_bbsbufferbypass_cast 84 x x'
	else if (User.Name = 'iPrancer') then result := '_bbsbufferbypass_cast 167 x x'
	else if (User.Name = 'iCure') then result := '_bbsbufferbypass_cast 168 x x'
	else if (User.Name = 'iComet') then result := '_bbsbufferbypass_cast 169 x x'
	else if (User.Name = 'Chaos') then result := '_bbsbufferbypass_cast 170 x x'
	else if (User.Name = 'NewEra') then result := '_bbsbufferbypass_cast 171 x x'
	else if (User.Name = 'Spiker') then result := '_bbsbufferbypass_cast 172 x x'
	else if (User.Name = 'Reinn') then result := '_bbsbufferbypass_cast 173 x x'
	else if (User.Name = 'Tranquility') then result := '_bbsbufferbypass_cast 174 x x'
	else if IsClass_FighterType(User.ClassId) then result := '_bbsbufferbypass_giveBuffSet figher 0 0'
	else result := '_bbsbufferbypass_giveBuffSet mage 0 0';
	
end;


function Do_L2Idle_Rebuff(takeShadow: Boolean = false): Boolean;
var
isFighter: boolean;
begin
	result := false;
	if (Party.Chars.Count >= 2) or (User.Name = GetName_SubPartyLeader(GetPartyNum)) then exit;
	

	GetOutOfCombat;
	if (User.DistTo(147715, -56486, -2776) > 500) then begin
		cEnterText('.goddard');
		Delay(7000);
	end;
	if (User.DistTo(147715, -56486, -2776) < 1500) then begin
		Engine.MoveTo(147793, -56533, -2776);
		Delay(1000);
		if OpenBuffer then begin
			
			//Take Standard Buffs
			Engine.DlgSel(11);
			Delay(1500);
			ComTalk('npc_268478260_autobuff');
			Delay(2000);
			isFighter := (IsClass_FighterType(User.ClassId)) or (IsClass_OrcMystic(User.ClassId)) or (IsClass_Slh(User.ClassId)) or IsClass_Judi(User.ClassId);
			//Take Specialized Buffs
			TakePpBuffs(isFighter, (not IsClass_FighterType(User.ClassId)));
			TakeElderBuffs;
			TakeWcBuffs;
			TakeOlBuffs;
			TakeMiscBuffs;
			if (isFighter) then begin
				TakeDances_Fighter(takeShadow);
				TakeSongs_Fighter;
			end else begin
				if (IsClass_Sph(User.ClassId) and (User.Level >= 84)) then takeShadow := true;
				TakeDances_Mage(takeShadow);
				TakeSongs_Mage;	
			end;
			Delay(1000);
			
			
			//Take healling
			OpenBuffer;
			Delay(2000);
			Engine.DlgSel(11);
			Delay(1500);
			ComTalk('npc_268478260_healme');
			Delay(2000);
			
			CheckTakeVit;
		end;
	end;
end;

function OpenBuffer: Boolean;
begin
	result := false;
	if (User.InRange(147793, -56533, -2776, 300)) then begin
		Engine.SetTarget(32793);
		Delay(500);
		result := Engine.DlgOpen();
		Delay(2500);
	end else begin
		print('cant buff, wrong location');
		exit;
	end;
end;

function CheckTakeVit: Boolean;
begin
	result := false;
	if (User.Level < 35) then exit;
	if (User.InRange(147736, -56468, -2776, 500)) then begin
		Engine.MoveTo(148058, -55484, -2728);
		Delay(1000);
		Engine.SetTarget(4306);
		Delay(500);
		result := Engine.DlgOpen();
		Delay(1500);
		Engine.DlgSel(1);
		Delay(1000);
		Engine.MoveTo(147718, -56485, -2776);
	end;
end;

function TakePpBuffs(greaterMight, acumen: Boolean): void;
begin
	OpenBuffer;	
	ComTalk('npc_268478260_Chat_buffer.htm');
	ComTalk('npc_268478260_Chat_prophet.htm');
	ComTalk('npc_268478260_buffprop_1501_1');
	ComTalk('npc_268478260_buffprop_1499_1');
	ComTalk('npc_268478260_buffprop_1062_2'); //Zerk
	
	if acumen then ComTalk('npc_268478260_buffprop_1085_3'); //Acumen
	
	if greaterMight then ComTalk('npc_268478260_buffprop_1388_3')
	else ComTalk('npc_268478260_buffprop_1389_3');
	Delay(1200);
end;
function TakeElderBuffs: void;
begin
	OpenBuffer;	
	ComTalk('npc_268478260_Chat_buffer.htm');
	ComTalk('npc_268478260_Chat_elder.htm');
	ComTalk('npc_268478260_buffelder_1397_3');
	ComTalk('npc_268478260_buffelder_1500_1');
	ComTalk('npc_268478260_buffelder_1502_1');
	ComTalk('npc_268478260_buffelder_1503_1');
	ComTalk('npc_268478260_buffelder_1504_1');
	ComTalk('npc_268478260_buffelder_1460_1');
	
	
	Delay(1200);
end;
function TakeWcBuffs: void;
begin
	OpenBuffer;	
	ComTalk('npc_268478260_Chat_buffer.htm');
	ComTalk('npc_268478260_Chat_warcryer.htm');
	ComTalk('npc_268478260_buffwar_1363_1');
	ComTalk('npc_268478260_buffwar_1519_1');
	
	Delay(1200);
end;
function TakeOlBuffs: void;
begin
	OpenBuffer;	
	ComTalk('npc_268478260_Chat_buffer.htm');
	ComTalk('npc_268478260_Chat_overlord.htm');
	ComTalk('npc_268478260_buffover_1364_1');
	ComTalk('npc_268478260_buffover_1415_1');
	
	Delay(1200);
end;

function TakeMiscBuffs: void;
begin
	OpenBuffer;	
	ComTalk('npc_268478260_Chat_buffer.htm');
	ComTalk('npc_268478260_Chat_misc.htm');
	ComTalk('npc_268478260_buffmisc_1323_1');
	ComTalk('npc_268478260_buffmisc_4699_13');
	ComTalk('npc_268478260_buffmisc_4703_13');
	Delay(1200);
end;
function TakeDances_Fighter(takeShadow: Boolean): void;
begin
	OpenBuffer;	
	ComTalk('npc_268478260_Chat_buffer.htm');
	ComTalk('npc_268478260_Chat_dances.htm');
	ComTalk('npc_268478260_buffdance_271_1');
	ComTalk('npc_268478260_buffdance_272_1');
	ComTalk('npc_268478260_buffdance_274_1');
	ComTalk('npc_268478260_buffdance_275_1');
	ComTalk('npc_268478260_buffdance_310_1');
	ComTalk('npc_268478260_buffdance_915_1');
	
	if takeShadow then ComTalk('npc_268478260_buffdance_366_1');
	Delay(1200);
end;
function TakeSongs_Fighter: void;
begin
	OpenBuffer;	
	ComTalk('npc_268478260_Chat_buffer.htm');
	ComTalk('npc_268478260_Chat_songs.htm');
	ComTalk('npc_268478260_buffsong_264_1');
	ComTalk('npc_268478260_buffsong_267_1');
	ComTalk('npc_268478260_buffsong_268_1');
	ComTalk('npc_268478260_buffsong_269_1');
	ComTalk('npc_268478260_buffsong_304_1');
	ComTalk('npc_268478260_buffsong_364_1');
	ComTalk('npc_268478260_buffsong_349_1');
	//ComTalk('npc_268478260_buffsong_363_1');
	Delay(1200);
end;
function TakeDances_Mage(takeShadow: Boolean): void;
begin
	OpenBuffer;	
	ComTalk('npc_268478260_Chat_buffer.htm');
	ComTalk('npc_268478260_Chat_dances.htm');
	ComTalk('npc_268478260_buffdance_273_1');
	ComTalk('npc_268478260_buffdance_276_1');
	ComTalk('npc_268478260_buffdance_365_1');
	ComTalk('npc_268478260_buffdance_915_1');
	if takeShadow then ComTalk('npc_268478260_buffdance_366_1');
	Delay(1200);
end;
function TakeSongs_Mage: void;
begin
	OpenBuffer;	
	ComTalk('npc_268478260_Chat_buffer.htm');
	ComTalk('npc_268478260_Chat_songs.htm');
	ComTalk('npc_268478260_buffsong_264_1');
	ComTalk('npc_268478260_buffsong_267_1');
	ComTalk('npc_268478260_buffsong_268_1');
	ComTalk('npc_268478260_buffsong_304_1');
	ComTalk('npc_268478260_buffsong_349_1');
	ComTalk('npc_268478260_buffsong_363_1');
	ComTalk('npc_268478260_buffsong_914_1');
	Delay(1200);
end;

function DoRebuff_Pet: Boolean;
var
serverName: string;
begin
	result := false;
	if (interlude) or (GetName_Server = 'Idle') then begin
		Print('DoRebuff is not implemented for interlude');
		exit;
	end;
	serverName := GetName_Server;
	if (serverName = 'PlayInera') then begin
		ComTalk('_bbshome');
		ComTalk('02');
		ComTalk('08');
		result := true;
	end;
end;

function GetPersonalBuffMessage: string;
var
i, nClassID: Integer;
begin
	nClassID := User.ClassID;
	
	if (GetName_Server = 'Tales') then begin
		if (IsClass_Tank(nClassID)) then result := '06';
		if (IsClass_Nuker(nClassID)) then result := '01';
		if (IsClass_Wl(nClassID)) then result := '06';
		if (GetClassValue_Healer(nClassID) > 0) then result := '05';
		if (IsClass_Ol(nClassID)) then result := '01';
		Exit;
	end else if (GetName_Server = 'PlayInera') then begin
		result := '01';
		Exit;
	end;
  
end;

function UseSkill_Aggression_Pve: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
begin
	result := false;
	if not IsTarget_ValidAndVisible_Live(User.Target) then Exit;
	
	
	if HasSkill_Ready(28) then begin
		Engine.UseSkill(28);
		print('Use Aggression!');
		result := true;
		Exit;
	end;
end;

function UseSkill_Aggression_Pvp: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
begin
	result := false;
	if not IsTarget_ValidAndVisible_CharAsLive(User.Target) then Exit;
	
	
	if HasSkill_Ready(28) then begin
		Engine.UseSkill(28);
		print('Use Aggression!');
		result := true;
		Exit;
	end;
end;

function UseSkill_Tank_Agro_Pvp: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
begin
	result := false;
	if not IsTarget_ValidAndVisible_CharAsLive(User.Target) then Exit;
	
	
	if HasSkill_Ready(28) then begin
		Engine.UseSkill(28);
		result := true;
		Exit;
	end;
	
	if (HasSkill_Ready(985)) then begin
		Engine.UseSkill(985);
		result := true;
		Exit;
	end;
	
	
	//	Aura of Hate
	if HasSkill_Ready(18) then begin
		CountNearMe := GetCount_EnemiesNearTarget_Pvp_Char(User);
		CountNearTarget := GetCount_EnemiesNearTarget_Pvp_CharAsLive(User.Target);
		if (CountNearMe > 2) or (CountNearTarget > 2) then begin
			if (CountNearMe >= CountNearTarget) then begin
				Engine.UseSkill(18);
				result := true;
				Exit;
			end else begin
				if (User.DistTo(User.Target) > 75) then begin
					LockCheck_MoveAndBot_Off;
					x := user.target.x;
					y := user.target.y;
					z := User.z;
					MoveTo_Timer(x, y, z);
					Delay(800);
					LockCheck_MoveAndBot_On;
					result := true;
					Exit;
				end else begin
					Engine.UseSkill(18);
					result := true;
					Exit;
				end;
				
			end;
		end;
	end;

end;



function CheckUse_InsaneCrusher: Boolean;
var
oBuff: Tl2Buff;
begin
	result := false;
	
	//Hell Knights Only
	if not IsClass_Hk(User.ClassID) then exit;
	
	if User.Buffs.ById(5561, oBuff) then begin
		if (oBuff.Level >= 3) then begin
			SetPoint_AoePosition;
			if (IsAoePoint_Valid) then begin
				SetDistance_AoePointDistance;
				
				if (PvpLoaded) then
					SetTarget_Nearest_Pvp
				else
					SetTarget_Nearest_Pve;
					
				//Use insane crusher no matter where we are,
				if HasSkill_Ready(762) then Engine.DUseSkill(762, false, false);
				
				//In case we are away from aoe point, move there
				if (AOE_PT_DIST > 50) then begin
					MoveTo_AoePoint_WaitForFinish(40); 
					result := true; 
				end;
					
				result := true;
			end else begin
				Print('Warning: HK cannot find AoePosition, just use InsaneCrusher now');
				if HasSkill_Ready(762) then result := Engine.DUseSkill(762, false, false);
			end;
		end;
	end;
	
	//	Seed Buff 	Id = 761
	//	Lv 1-3 buff id = 5561
	//	Mass Cancel Id = 762

end;


function CheckUse_SigelAoeAgro: Boolean;
var
massAgroId: Integer;
oBuff: Tl2Buff;
begin
	result := false;
	massAgroId := 10027;
	
	if not HasSkill_Ready(massAgroId) then exit;
	
		SetPoint_AoeAgroPosition;
		if (IsAoeAgroPoint_Valid) then begin
			SetDistance_AoeAgroPointDistance;
				
			//In case we are away from aoe point, move there
			if (AOEAGRO_PT_DIST > 50) then begin
				if MoveTo_AoeAgroPoint(40) then begin
					Engine.DUseSkill(massAgroId, false, false);
					Engine.DUseSkill(massAgroId, false, false);
				end;
				result := true; 
			end else begin
				Engine.DUseSkill(massAgroId, false, false);
				Engine.DUseSkill(massAgroId, false, false);
				result := true;
			end;
					
			result := true;
		end else begin
			Print('Warning: Sigel cannot find AoeAgroPosition, just use Mass Agro now');
			result := Engine.DUseSkill(massAgroId, false, false);
	end;
	
end;

function CheckUse_CenterPull: Boolean;
var
centerPullId: Integer;
oBuff: Tl2Buff;
begin
	result := false;
	centerPullId := 19555;
	
	if not HasSkill_Ready(centerPullId) then exit;
	
		SetPoint_AoePosition;
		if (IsAoePoint_Valid) then begin
			SetDistance_AoePointDistance;
				
			//In case we are away from aoe point, move there
			if (AOE_PT_DIST > 50) then begin
				if MoveTo_AoePoint(40, false) then begin
					Engine.DUseSkill(centerPullId, false, false);
					Engine.DUseSkill(centerPullId, false, false);
				end;
				result := true; 
			end else begin
				Engine.DUseSkill(centerPullId, false, false);
				Engine.DUseSkill(centerPullId, false, false);
				result := true;
			end;
					
			result := true;
		end else begin
			Print('Warning: Sigel cannot find AoeAgroPosition, just use Maelstrom now');
			result := Engine.DUseSkill(centerPullId, false, false);
	end;
	
end;

function CheckUse_ShadowSnare: Boolean;
var
oBuff: Tl2Buff;
z: Integer;
begin
	result := false;
	if not HasSkill_Ready(11058) then exit;
	
	SetPoint_AoePosition(true); 
	if (IsAoePoint_Valid) then begin
		z := User.Z;
		result := Engine.UseSkillGround(11058, AOE_PX, AOE_PY, z);
	end else begin
		Print('Warning: Feoh, Aoe point is not valid, we cannot use Shadow Snare');
	end;
	
end;


function UseSkill_Tank_Attack_Pvp: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
oTarget: Tl2Char;
begin
	result := false;
	if not IsTarget_ValidAndVisible_CharAsLive(User.Target) then Exit;
	CharList.ByName(User.Target.name, oTarget);
	if (oTarget = nil) then Exit;
	
	//	Touch of Death
	if HasSkill_Ready(342) then begin
		Engine.UseSkill(342);
		result := true;
		Exit;
	end;
	
	//	Shield Slam?
	if HasSkill_Ready(353) 
	and (IsClass_FighterType(oTarget.ClassID))
	and not (IsTarget_Silenced_Live(User.Target)) then begin
		Engine.UseSkill(353);
		result := true;
		Exit;
	end;
	
	//	Shield Bash?
	if HasSkill_Ready(352) 
	and not (IsTarget_Stunned(User.Target)) then begin
		Engine.UseSkill(352);
		result := true;
		Exit;
	end;
	
	//	Shield Stun?
	if HasSkill_Ready(92) 
	and not (IsTarget_Stunned(User.Target)) then begin
		Engine.UseSkill(92);
		result := true;
		Exit;
	end;
	
	//	Shackle?
	if HasSkill_Ready(403) 
	and not (IsTarget_Rooted_Live(User.Target)) then begin
		Engine.UseSkill(403);
		result := true;
		Exit;
	end;
	
	//	Judgement?
	if HasSkill_Ready(401)  then begin
		Engine.UseSkill(401);
		result := true;
		Exit;
	end;
	
	//	Shield Agro?
	if HasSkill_Ready(984) then begin
		Engine.UseSkill(984);
		result := true;
		Exit;
	end;
	
	Print('NO SKILL USED!');
end;

function Speak_ItemsCount_Party: void;
var
cSss, cBsss, cSpiritOre, cManaPots, cHolyWater: Integer;
oItem: Tl2Item;
sMessage: string;
begin
	if (Party.Chars.Count < 2) then exit;
	
	if IsClass_Nuker(User.ClassId) then 
		delay(3000)
	else
		Delay(5000);
	
	if (Inventory.User.ById(726, oItem)) then cManaPots := oItem.Count
	else cManaPots := 0;
	
	if (Inventory.User.ById(GetShotId, oItem)) then cSss := oItem.Count
	else cSss := 0;
	
	if (Inventory.User.ById(GetSpiritShotId, oItem)) then cBsss := oItem.Count
	else cBsss := 0;
	
	if (Inventory.User.ById(3031, oItem)) then cSpiritOre := oItem.Count
	else cSpiritOre := 0;
	
	if (Inventory.User.ById(8874, oItem)) then cHolyWater := oItem.Count
	else cHolyWater := 0;
	
	
	if IsClass_Bp(User.ClassId) then begin
		Delay(4000);
		sMessage := 'MP = ' + IntToStr(cManaPots) + ', SO = ' + IntToStr(cSpiritOre) + ', SSS = ' + IntToStr(cSss) + ', BSSS = ' + IntToStr(cBsss) + ', HW = ' + IntToStr(cHolyWater)
	end else
		sMessage := 'MP = ' + IntToStr(cManaPots) + ', SO = ' + IntToStr(cSpiritOre) + ', SSS = ' + IntToStr(cSss) + ', BSSS = ' + IntToStr(cBsss);
	
	
	Engine.Say(sMessage, 3, '');
	
end;

function UseSkill_Ol_AoeAttack_Pvp: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
oTarget: Tl2Char;
begin
	result := false;
	if not IsTarget_ValidAndVisible_CharAsLive(User.Target) then Exit;
	CharList.ByName(User.Target.name, oTarget);
	if (oTarget = nil) then Exit;
	
	//	Seal of Blockade
	if HasSkill_Ready(1462) then begin
		if (GetCount_EnemiesNearTarget_Pvp_Char_StandardAttackers(User, 200) > 1) then begin
			Engine.UseSkill(1462);
			result := true;
			Exit;
		end;
	end;
	
end;
function UseSkill_Slh_AoeAttack_Pvp: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
oTarget: Tl2Char;
begin
	result := false;
	if not IsTarget_ValidAndVisible_CharAsLive(User.Target) then Exit;
	if CharList.ByName(User.Target.name, oTarget) 
	and not (oTarget = nil) then begin
		
		//	Lightning Shock
		if HasSkill_Ready(791) then begin
			CUseSkill(791, true, false, Engine.GetFaceState(0));
			result := true;
			Exit;
		end;
	end;
end;

function UseSkill_Slh_AoeAttack_Pve: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
oTarget: Tl2Live;
begin
	result := false;
	oTarget := User.Target;
	if not IsTarget_ValidAndVisible_Live(oTarget) then Exit;
	if (oTarget = nil) then exit;
		
	//	Lightning Shock
	if HasSkill_Ready(791) then begin
		CUseSkill(791, false, false, Engine.GetFaceState(0));
		result := true;
		Exit;
	end;
end;

function UseSkill_Slh_SingleAttack_Pve: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
oTarget: Tl2Live;
begin
	result := false;
	oTarget := User.Target;
	if not IsTarget_ValidAndVisible_Live(oTarget) then Exit;
	if (oTarget = nil) then exit;
		
	
	
	//Check main assist's target for death mark
	if HasSkill_Ready_Interval(1435, 2500) then begin
		if not IsTarget_DeathMarked(oTarget) then begin
			UseSkill_SetInterval(1435, 2500);
			result := true;
			Exit;
		end;
	end;
	
	//	Close distance! Check Charge.
	if CheckUse_Charge(oTarget) then begin
		result := true;
		exit;
	end;
	
	//	Lightning Shock
	if HasSkill_Ready(791) then begin
		CUseSkill(791, false, false, Engine.GetFaceState(0), oTarget, 100);
		result := true;
		Exit;
	end;
	
end;
	
function CheckUse_Dagger_Pvp_Buff: Boolean;
begin
	result := false;
	
	//Check Counterattack
	if HasSkill_Ready(447) and not IHaveBuff(447) then begin 	
		if (GetCount_FighterDpsHasCharAsTarget_Pvp(User) > 1) then begin
			result := CUseSkill(447, false, false, Engine.GetFaceState(0));
			exit;
		end;
	end;
	
end;

function CheckUse_Doombringer_Pvp_Buff: Boolean;
begin
	result := false;
	
	//Check Eye for Eye
	if HasSkill_Ready(948) and not IHaveBuff(948) then begin 	
		if (GetCount_FighterDpsHasCharAsTarget_Pvp(User) > 1) then begin
			result := Engine.UseSkill(948);
			exit;
		end;
	end;
	
end;

function CheckUse_Tank_Pvp_Buff: Boolean;
begin
	result := false;
	
	//Check Shield of Faith
	if HasSkill_Ready(528)
	and (IsTime_ToPartyUd_Pvp) then begin
		result := CUseSkill(528, false, false, Engine.GetFaceState(0));
		exit;
	end;
	
	//Check Shield Deflect Magic
	if HasSkill_Ready(916) and not IHaveBuff(916) then begin 	
		if (GetCount_NukersHasCharAsTarget_Pvp(User) > 2) then begin
			result := CUseSkill(916, false, false, Engine.GetFaceState(0));
			exit;
		end;
	end;
	
end;


function CheckUse_Tank_Pve_Buff: Boolean;
begin
	result := false;
	
	//Check Shield of Faith
	if HasSkill_Ready(528)
	and (IsTime_ToPartyUd_Pve) then begin
		result := CUseSkill(528, false, false, Engine.GetFaceState(0));
		exit;
	end;
	
end;

function CheckUse_Tank_Overall_Buff: Boolean;
var
oBuff: Tl2Buff;
begin
	result := false;	
	if IsClass_Hk(User.ClassId) then begin
		if HasSkill_Ready(761)
		and not (User.Buffs.ById(761, oBuff))
		and not User.Buffs.ById(5561, oBuff) then begin
			result := CUseSkill(761, false, false, Engine.GetFaceState(0));
		end;
		//	Seed Buff 	Id = 761
		//	Lv 1-3 buff id = 5561
		//	Mass Cancel Id = 762
		
		
	end else if CheckUse_PainOfShilen_LeaderTypeOnly then begin
		result := true;
	
		(*
	end else if IsClass_Sk(User.ClassId) then begin
		if HasSkill_Ready(789)
		and HasSkill_Ready(788)
		and not (User.Buffs.ById(788, oBuff))
		and not User.Buffs.ById(5564, oBuff)
		and not User.Buffs.ById(789, oBuff) then begin
			result := Engine.UseSkill(788);
		end;
		
		if HasSkill_Ready(789)
		and User.Buffs.ById(5564, oBuff)
		and (oBuff.Level >= 3) then begin
			result := Engine.UseSkill(789);
		end;
		//	Seed Buff 	Id = 788
		//	Lv 1-3 buff id = 5564
		//	Mass Cancel Id = 789*)
	end;
end;



function CheckUse_Tank_MiscPvp_Skills: Boolean;
begin
	result := false;
	if (HasSkill_Ready_Interval(403, 7000)) then begin
		if SetTarget_BestToRoot_Pvp() then begin
			result := UseSkill_SetInterval(403, 7000);
		end;
	end else if (HasSkill_Ready_Interval(402, 7000)) then begin
		if SetTarget_BestToRoot_Pvp() then begin
			result := UseSkill_SetInterval(402, 7000);
		end;
	end;

end;

function UseSkill_Tank_Agro_Pve: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
Has985, Has18: Boolean;
begin
	print('Agro_PVE: Started');
	result := false;
	if not IsTarget_ValidAndVisible_Live(User.Target) then Exit;
	
	
	if HasSkill_Ready(28) then begin
		Engine.UseSkill(28);
		result := true;
		print('Agro_PVE: Use Standard Aggression');
		Exit;
	end;
	
	Has985 := HasSkill_Ready(985);
	Has18 := HasSkill_Ready(18);
	print(Has985);
	print(Has18);
	if (Has985 or Has18) then begin
		CountNearMe := GetCount_EnemiesNearTarget_Pve_Char(User);
		CountNearTarget := GetCount_EnemiesNearTarget_Pve_Live(User.Target);
		print('Agro_PVE: CountNearMe = ' + IntToStr(CountNearMe) + ', CountNearTarget = ' + IntToStr(CountNearTarget));
		
	end;
	
	if (Has985) and (CountNearTarget > 2) then begin
		Engine.UseSkill(985);
		result := true;
		Exit;
	end;
	
	
	//	Aura of Hate
	if Has18 then begin
		if (CountNearMe > 2) or (CountNearTarget > 2) then begin
			if (CountNearMe >= CountNearTarget) then begin
				Engine.UseSkill(18);
				result := true;
				Exit;
			end else begin
				if (User.DistTo(User.Target) > 75) then begin
					LockCheck_MoveAndBot_Off;
					x := user.target.x;
					y := user.target.y;
					z := User.z;
					MoveTo_Timer(x, y, z);
					Delay(800);
					LockCheck_MoveAndBot_On;
					result := true;
					Exit;
				end else begin
					Engine.UseSkill(18);
					result := true;
					Exit;
				end;
				
			end;
		end;
	end;

end;


(*
function DetermineMessage_DbPort(sCommand: string): boolean;
var
sCommandWords: array of string;
i: Integer;
begin
  result := false;
  sCommandWords := sCommand.Split(' ');
  
  
  if (Length(sCommandWords) = 4)
  and (sCommandWords[1] = 'db')
  and (sCommandWords[2] = 'search')then begin
    DatabasePort_Search(sCommandWords[3]);
	result := true;
	
  end else if (Length(sCommandWords) = 4)
  and (sCommandWords[1] = 'db')
  and (sCommandWords[2] = 'take')then begin
	if (sCommandWords[3] = '1st') 
	or (sCommandWords[3] = '2nd')
	or (sCommandWords[3] = '3rd')
	or (sCommandWords[3] = '4th')
	or (sCommandWords[3] = '5th')
	or (sCommandWords[3] = '6th') then begin
		result := true;
		DatabasePort_Pick(sCommandWords[3]);
	end;  
  end;
end;

function DatabasePort_Search(searchString: string): void;
begin
	ComTalk('_bbshome');
	ComTalk('_friendlist_0_');
	ComTalk('_dropMonstersByName_ ' + searchString);
end;
function DatabasePort_Pick(choice: string): void;
var
sPick: string;
begin

	if (choice = '1st') then sPick := '03'
	else if (choice = '2nd') then sPick := '04'
	else if (choice = '3rd') then sPick := '05'
	else if (choice = '4th') then sPick := '06'
	else if (choice = '5th') then sPick := '07'
	else if (choice = '6th') then sPick := '08';
	ComTalk(sPick);
	ComTalk('03');
end;

*)

function CheckSwsBd_Aoe: Boolean;
begin
	result := false;
	if not IsTime_ToAoe then exit;
	
	SetPoint_AoePosition;
	if not IsAoePoint_Valid then exit;
	
	SetDistance_AoePointDistance;
	if (AOE_PT_DIST > 100) then begin
		MoveTo_AoePoint_WaitForFinish; 
		result := true; 
		exit;
	end;
	
	if (PvpLoaded) then begin
		if HasSkills_Ready_Any(407, 408) and (User.Mp > 20) then begin
			if (SetTarget_Nearest_Pvp) then begin
				//Use Aoe Skill
				if HasSkill_Ready(407) then begin
					result := Engine.DUseSkill(407, True, False);
					exit;
				end else if HasSkill_Ready(408) then begin
					result := Engine.DUseSkill(408, True, False);
					exit;
				end;
				
			end;
		end;
	end else begin
		if (SetTarget_Nearest_Pve) then begin
			//Use Aoe Skill
			if HasSkills_Ready_Any(407, 408) and (User.Mp > 20) then begin
				
				if HasSkill_Ready(407) then begin
					result := Engine.DUseSkill(407, True, False);
					exit;
				end else if HasSkill_Ready(408) then begin
					result := Engine.DUseSkill(408, True, False);
					exit;
				end;
				
			end;
		end;
	end;
end;

function UseSkill_Tank_Attack_Pve: Boolean;
var
CountNearMe, CountNearTarget, x, y, z: Integer;
oTarget: Tl2Char;
begin
	result := false;
	if not IsTarget_ValidAndVisible_Live(User.Target) then Exit;
	
	print('AutoTank: Use Pve single skill!!');
	
	//	Shield Stun?
	if HasSkill_Ready(92) 
	and not (IsTarget_Stunned(User.Target)) then begin
		Engine.UseSkill(92);
		result := true;
		Exit;
	end;
	
	//	Shield Bash?
	if HasSkill_Ready(352) 
	and not (IsTarget_Stunned(User.Target)) then begin
		Engine.UseSkill(352);
		result := true;
		Exit;
	end;
	
	//	Judgement?
	if HasSkill_Ready(401)  then begin
		Engine.UseSkill(401);
		result := true;
		Exit;
	//	Tribunal?
	end else if HasSkill_Ready(400)  then begin
		Engine.UseSkill(400);
		result := true;
		Exit;
	end;
	
	//	Shield Agro?
	if HasSkill_Ready(984) then begin
		Engine.UseSkill(984);
		result := true;
		Exit;
	end;
	

end;

function ComTalk(Word: string): void;
begin
  Engine.BypassToServer(Word);
  //print('ComTalk: ' + Word);
  Delay(1200 + Random(200));
end;


function Restock: Boolean;
var
i, nItemCount, nShotID, nSpiritShotID, SSPrice, BSSPrice, AdenaCount,
SSToBuy, BSSToBuy,
ManaPotID, ManaPotPrice, ManaPotToBuy,
SOreID, SOrePrice, SOreToBuy,
SoeCastleID, SoeCastlePrice, SoeCastleToBuy, SoeCastleMax,
soulOreID, soulOrePrice, soulOreToBuy,
RScrollID, RScrollPrice, RScrollToBuy,
Max_ManaPot, Max_SOre, Max_soulOre, Max_RScroll, Max_SS, Max_BSS: Integer;
oItem: Tl2Item;
begin
	result := false;
	if (User.Dead) then exit;
	if (User.Level < 76) then begin
		Max_ManaPot := 1000;
		if not IsClass_FighterType(User.ClassId) then Max_ManaPot := 5000;
	end else
		Max_ManaPot := 100000;
		
	if IsClass_FighterType(User.ClassId) then
		Max_SOre := 0
	else if (User.Level < 76) then
		Max_SOre := 1000
	else 
		Max_SOre := 200000;
	
	Max_RScroll := 30;  
	
	if (User.Level < 81) then
		Max_SS := 50000
	else
		Max_SS := 40000;
		
	if (User.Level < 81) then
		Max_BSS := 50000
	else
		Max_BSS := 40000;

	if (User.Hero) then begin
		Max_soulOre := 50000;
		Max_SOre := 100000;
		
	end else
		Max_soulOre := 0;

	SoeCastleMax := 30;
  nShotID := GetShotId(); //SSS ID
  SSPrice := GetShotPrice; //SSS Price
  nSpiritShotID := GetSpiritShotId(); //BSSS ID
  BSSPrice := GetSpiritShotPrice;  //BSSS Price
  
  if (GetName_Server = 'Apocalyps') then ManaPotID := 728
  else ManaPotID := 726;
  ManaPotPrice := 500;
  SOreID := 3031;
  soulOreID := 1785;
  SoeCastleID := 1830;
  SoeCastlePrice := 600;
  SOrePrice := 500;
  soulOrePrice := 250;
  RScrollID := 8599;
  RScrollPrice := 96000; //96.000 for S Recovery Scroll
  if not Inventory.User.ByID(57, oItem) then exit;
  AdenaCount := oItem.Count;

  
  SSToBuy := 0;
  if (AdenaCount < 55000) then exit;
  AdenaCount := (AdenaCount - 50000) div 12;
  

	if not (nShotID = 0) then begin
		SSToBuy := (AdenaCount * 3) div SSPrice;
		Inventory.User.ByID(nShotID, oItem);
		nItemCount := oItem.Count;
		if ((SSToBuy + nItemCount) > Max_SS) then begin
			SSToBuy := (Max_SS - nItemCount);
		end; 
	end;

	if not (nSpiritShotID = 0) then begin	
		BSSToBuy := (AdenaCount * 3) div BSSPrice;
		if (Inventory.User.ByID(nSpiritShotID, oItem)) then begin
			nItemCount := oItem.Count;
			if ((BSSToBuy + nItemCount) > Max_BSS) then begin
				BSSToBuy := (Max_BSS - nItemCount);
			end; 
		end else if (BSSToBuy > Max_BSS) then BSSToBuy := Max_BSS;
	end;
	
	
	
	
  SoeCastleToBuy := AdenaCount div SoeCastlePrice;
  Inventory.User.ByID(SoeCastleID, oItem);
  nItemCount := oItem.Count;
  if ((SoeCastleToBuy + nItemCount) > SoeCastleMax) then begin
    SoeCastleToBuy := (SoeCastleMax - nItemCount);
	Print('We should buy ' + IntToStr(SoeCastleToBuy) + ' Soe To Castle');
  end; 
	
  ManaPotToBuy := AdenaCount div ManaPotPrice;
  Inventory.User.ByID(ManaPotID, oItem);
  nItemCount := oItem.Count;
  if ((ManaPotToBuy + nItemCount) > Max_ManaPot) then begin
    ManaPotToBuy := (Max_ManaPot - nItemCount);
  end; 

  if (SSToBuy <= 0) then
	SOreToBuy := (AdenaCount * 4) div SOrePrice
  else
	SOreToBuy := AdenaCount div SOrePrice;
	
  Inventory.User.ByID(SOreID, oItem);
  nItemCount := oItem.Count;
  if ((SOreToBuy + nItemCount) > Max_SOre) then begin
    SOreToBuy := (Max_SOre - nItemCount);
  end; 

  soulOreToBuy := AdenaCount div SOrePrice;
  Inventory.User.ByID(soulOreID, oItem);
  nItemCount := oItem.Count;
  if ((soulOreToBuy + nItemCount) > Max_soulOre) then begin
    soulOreToBuy := (Max_soulOre - nItemCount);
  end; 
  
  RScrollToBuy := AdenaCount div RScrollPrice;
  Inventory.User.ByID(RScrollID, oItem);
  nItemCount := oItem.Count;
  if ((RScrollToBuy + nItemCount) > Max_RScroll) then begin
    RScrollToBuy := (Max_RScroll - nItemCount);
  end;   

  
	if ((SSToBuy > 0)  or (BSSToBuy > 0)) then begin
		OpenShotShop;
		result := true;
	end;
  if (SSToBuy > 0) 
  and (IsClass_FighterType(User.ClassID) or IsClass_OrcMystic(User.ClassId) or IsClass_Slh(User.ClassId) or IsClass_Judi(User.ClassID)) 
  and not (nShotID = 0) then 
    BuyItemFromMultiTrade(nShotID, SSToBuy);
	
	Delay(1000);
	
  if (BSSToBuy > 0) and not (IsClass_FighterType(User.ClassID)) and not (nSpiritShotID = 0) then
    BuyItemFromMultiTrade(nSpiritShotID, BSSToBuy);
	
  delay(2000);
  
	if (ManaPotToBuy > 0) then begin
		OpenPotionShop;
		result := true;
	end;
	
  if (ManaPotToBuy > 0) then
    BuyItemFromMultiTrade(ManaPotID, ManaPotToBuy);
	
  
  
	if (SOreToBuy > 0) or (RScrollToBuy > 0) or (soulOreToBuy > 0) or (SoeCastleToBuy > 0) then begin
		OpenConsumeShop;	
		result := true;
	end;
  if (SOreToBuy > 0) then
    BuyItemFromMultiTrade(SOreID, SOreToBuy);
  if (soulOreToBuy > 0) then
    BuyItemFromMultiTrade(soulOreID, soulOreToBuy);
  if (RScrollToBuy > 0) then
    BuyItemFromMultiTrade(RScrollID, RScrollToBuy);
	
	if (SoeCastleToBuy > 0) then
		BuyItemFromMultiTrade(SoeCastleID, SoeCastleToBuy);
	
end;

function Restock_FromGrocery: Boolean;
var
availableAdena, curAdena: Int64;
oItem: Tl2Item;

begin
	result := false;
	exit;
	if not Inventory.User.ById(57, oItem) then exit;
	curAdena := oItem.Count;
	
	
	availableAdena := curAdena div 100000;
	if (availableAdena <= 0) then exit;
	
	availableAdena := CheckBuyItem(123, 30, 600, availableAdena);
	
	

end;

function CheckBuyItem(itemId, maxItemCount, itemPrice: Integer; availableAdena: Int64): Int64;
var
oItem: Tl2Item;
currentItemCount, itemCountToBuy: Integer;
begin
	result := -1;
	
	if (itemId <= 0)
	or (maxItemCount <= 0) 
	or (availableAdena <= 0)
	or (itemPrice <= 0) then begin
		Print('CheckBuyItem: Error.');
		exit;
	end;
	if Inventory.User.ById(itemId, oItem) then begin
		currentItemCount := oItem.Count;
	end else
		currentItemCount := 0;
		
	itemCountToBuy := maxItemCount - currentItemCount;
	
	if ((itemCountToBuy * itemPrice) > availableAdena) then begin
		itemCountToBuy := availableAdena div itemPrice; //Division by 0 is avoided above.
	end;
	
	if (itemCountToBuy <= 0) then exit;
	if BuyItemFromMultiTrade(itemId, itemCountToBuy) then begin
		result := availableAdena - (itemCountToBuy * itemPrice);
	end;
end;

function BuyItemFromMultiTrade(itemId, itemAmount: Integer): Boolean;
var
tempAmount: Integer;
begin
	result := true;
	tempAmount := itemAmount;
	while (tempAmount > 0) do begin
		if (tempAmount > 5000) then begin
			result := result and Engine.NpcExchange(itemId, 5000);
			tempAmount := tempAmount - 5000;
		end else begin
			result := result and Engine.NpcExchange(itemId, tempAmount);
			tempAmount := 0;
		end;
		Delay(2000);	
	end;
end;



Function OpenPotionShop: Boolean;
begin
  result := true;
  	if (GetName_Server = 'Idle') then begin
		if not User.InRange(147719, -56471, -2776, 500) then begin
			PortToGoddard;
			Delay(10000);
		end;
		Engine.MoveTo(147670, -56518, -2776);
		LeadDlg(32801, 4, 6);
  end else if (GetName_Server = 'Tales') then begin
    ComTalk('_bbshome');
    ComTalk('services');
    ComTalk('02');
	ComTalk('015');
		
  end else if (GetName_Server = 'World') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsfile:bbs_npcs');
    ComTalk('_bbsfile:smallNpcs/gmshop');
    ComTalk('111'); 
  end else if (GetName_Server = 'InJustice') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsgetfav');
    ComTalk('_bbsfile:smallNpcs/gmshop');
    ComTalk('116'); 
  end else if (GetName_Server = 'Apocalyps') then begin
    ComTalk('_bbshome');
    ComTalk('01');
    ComTalk('0c');
    ComTalk('01e'); 
  end else if (GetName_Server = 'Lionna') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsgetfav');
    ComTalk('01');
    ComTalk('015');  
  end;
end;
Function OpenConsumeShop: Boolean;
begin
  result := false;
  
	if (GetName_Server = 'Idle') then begin
		if not User.InRange(147719, -56471, -2776, 500) then begin
			PortToGoddard;
			Delay(10000);
		end;
		Engine.MoveTo(147670, -56518, -2776);
		LeadDlg(32801, 4, 5);
	end else if (GetName_Server = 'Tales') then begin
		ComTalk('_bbshome');
		ComTalk('services');
		ComTalk('02');
		ComTalk('015');
		
  end else if (GetName_Server = 'World') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsfile:bbs_npcs');
    ComTalk('_bbsfile:smallNpcs/gmshop');
    ComTalk('110'); 
  end else if (GetName_Server = 'InJustice') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsgetfav');
    ComTalk('_bbsfile:smallNpcs/gmshop');
    ComTalk('116'); 
  end else if (GetName_Server = 'Apocalyps') then begin
    ComTalk('_bbshome');
    ComTalk('01');
    ComTalk('0c');
    ComTalk('01e'); 
  end else if (GetName_Server = 'Lionna') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsgetfav');
    ComTalk('01');
    ComTalk('015');  
  end;
end;
Function OpenShotShop: Boolean;
begin
  result := true;
  	if (GetName_Server = 'Idle') then begin
		if not User.InRange(147719, -56471, -2776, 500) then begin
			PortToGoddard;
			Delay(10000);
		end;
		Engine.MoveTo(147670, -56518, -2776);
		LeadDlg(32801, 4, 7);
	end else if (GetName_Server = 'Tales') then begin
		ComTalk('_bbshome');
		ComTalk('services');
		ComTalk('02');
		ComTalk('016');
  end else if (GetName_Server = 'World') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsfile:bbs_npcs');
    ComTalk('_bbsfile:smallNpcs/gmshop');
    ComTalk('1f'); 
  end else if (GetName_Server = 'InJustice') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsgetfav');
    ComTalk('_bbsfile:smallNpcs/gmshop');
    ComTalk('117');  
  end else if (GetName_Server = 'Apocalyps') then begin
    ComTalk('_bbshome');
    ComTalk('01');
    ComTalk('0c');
    ComTalk('020');   
  end else if (GetName_Server = 'Lionna') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsgetfav');
    ComTalk('01');
    ComTalk('016');  
  end;
end;




function GoToDyeShopNpc(): void;
begin
	PortToGiran;
	Delay(10000);
	MoveFromGiranSpawnToDyeShop;
end;

function BuyAndSendDyesToParty: void;
var
i, PartySize: Integer;
DyeList, MailList: array of Cardinal;
oTarget: Tl2Char;
begin
  Engine.FaceControl(0, False);
  GoToDyeShopNpc;
  Delay(500);
  PartySize := Party.Chars.Count;
  for i := 0 to PartySize do begin  //not (PartySize - 1) because we use last iteraion to check ourself
    if (PartySize = i) then oTarget := User
	else oTarget := Party.Chars.Items(i);
	if (oTarget = nil) then continue;
	DyeList := GetDyeIdList(oTarget);
	Engine.CancelTarget();
	LeadDlg(30093, 1);
	Delay(1500);
	BuyAndMailDyeToPlayer(DyeList, oTarget.Name);
  end;  
end;

function BuyAndMailDyeToPlayer(DyeIdList: array of Cardinal; PlayerName: string): void;
var
i, Lngth: Integer;
ShopList: array of Cardinal;
begin
  Lngth := Length(DyeIdList);
  if (Lngth < 1) then Exit;
  
  SetLength(ShopList, Lngth * 2);
  
  for i := 0 to Lngth - 1 do begin
    ShopList[i*2] := DyeIdList[i];
	ShopList[(i*2) + 1] := 10;
  end;
  Print('Buy Dyes...');
  Engine.NpcTrade(False, ShopList);
  Delay(1000);
  if not (PlayerName = User.Name) then begin
    Engine.SendMail(PlayerName, 'dyes', '', ShopList);
	Delay(10000);
  end;
end;

function GetDyeIdList(oTarget: Tl2Char): array of Cardinal;
begin
  result := [0]; 
  print('Getting Dye List for: ' + oTarget.Name);
  if (IsClass_Nuker(oTarget.ClassID)) then result := [4588, 4583, 4579];
  if (IsClass_Bp(oTarget.ClassID)) or (IsClass_Ol(oTarget.ClassID)) then result := [4588, 4579, 4504];
  if (IsClass_Tank(oTarget.ClassID) or (IsClass_Wl(oTarget.ClassID))) then result := [4579, 4581, 4495];
end;

function Check_LowHpMode_Actions: Boolean;
var
oTargetToLower: Tl2Char;
begin
	result := false;
	if not LowHpMode then exit;
	
	if HasIntervalPassed_BySkillId(99999, 120000) then begin //99999 is arbitrary unique id for this cooldown
		//If 60 seconds has passed since activation, something must be wrong. Exit LowHpMode
		Print('We have been in LowHpMode for too long, emergency exit!');
		LowHpMode := false;
	end;
	
	//Dont continue until we are flagged
	if IsClass_ZealotType(User.ClassId)then begin
		if not Check_FlagPvp_OnNearestPartyMember then begin
			result := true;
			exit;
		end;
		
		
		oTargetToLower := GetTarget_ToLower;
		if not (oTargetToLower.Oid = user.Oid) and not (oTargetToLower = nil) then begin
			Engine.SetTarget(oTargetToLower);
			Engine.Attack(50, true);
			LowHp_TargetFound := true;
			result := true;
			exit;
		end;
			
		if LowHp_TargetFound then begin
			WalkRandom(5, 10);
			LowHp_TargetFound := false;
		end;
	end;
	
	
	if IsReadyToZealot then begin
		//Delay healers
		if (GetClassValue_Healer(User.ClassId) > 0) or (IsClass_Ol(User.ClassId)) then delay(2000);
		
		if IsClass_ZealotType(User.ClassID) then begin
			UseZealot;
		end;
		LowHpMode := false;
	end;
	
	
	AutoFollow;
	result := true;
end;


function UseZealot: Boolean;
begin
	result := false;
	print('Use Zealot skills!');
	if IsClass_Destro(User.ClassId) then begin
		Print('Class Destro: Use Zealot skills!');
		if HasSkill_Ready(420) then begin
			print('Use Zealot!');
			CUseSkill(420, false, false, Engine.GetFaceState(0));
		end;
		
		
		if HasSkill_Ready(176) then begin
			Print('Use Frenzy');
			CUseSkill(176, false, false, Engine.GetFaceState(0));
		end else if HasSkill_Ready(139) then begin
			Print('Frenzy was not ready, use Guts!');
			CUseSkill(139, false, false, Engine.GetFaceState(0));
		end;
			
	end else if IsClass_Tyrant(User.ClassId) then begin
		Print('Class Tyrant: Use Zealot skills!');
		if HasSkill_Ready(420) then begin
			Print('Use Zealot!');
			CUseSkill(420, false, false, Engine.GetFaceState(0));
		end;
			
	end;
	
	
	result := true;
end;

function IsReadyToZealot: Boolean;
var
i: Integer;
oTarget: Tl2Char;
begin
	result := true;
	
	if DoesAnyOne_HaveZealotActive then exit;
	
	for i := 0 to CharList.Count do begin
		if (i = CharList.Count) then 
			oTarget := User
		else
			oTarget := CharList.Items(i);
			
		if (oTarget = nil) then continue;
		if (User.DistTo(oTarget) > 1000) then break;
		
		if (oTarget.IsMember or (oTarget.Oid = User.Oid)) 
		and IsClass_ZealotType(oTarget.ClassId)
		and not HasAnyZealotBuff(oTarget) 
		and ((oTarget.Hp > 27) or (oTarget.Dead) or (oTarget.Hp <= 0)) then begin
			result := false;
			exit;
		end;		
	end;

end;

function DoesAnyOne_HaveZealotActive: Boolean;
var
i: Integer;
oTarget: Tl2Char;
begin
	result := false;
	
	for i := 0 to CharList.Count do begin
		if (i = CharList.Count) then 
			oTarget := User
		else
			oTarget := CharList.Items(i);
			
		if (oTarget = nil) then continue;
		if (User.DistTo(oTarget) > 1000) then break;
		
		if (oTarget.IsMember or (oTarget.Oid = User.Oid)) 
		and IsClass_ZealotType(oTarget.ClassId)
		and HasAnyZealotBuff(oTarget) then begin
			result := true;
			exit;
		end;		
	end;
end;

function HasAnyZealotBuff(oTarget: Tl2Char): Boolean;
var
oBuff: Tl2Buff;
begin
	result := false;
	if (oTarget = nil) then exit;
	if not oTarget.IsMember and not (oTarget.Oid = User.Oid) then Exit;
	
	if IsTarget_ValidAndVisible_Char(oTarget) then begin
		if oTarget.Buffs.ById(420, oBuff)
		or oTarget.Buffs.ById(176, oBuff)
		or oTarget.Buffs.ById(139, oBuff) then result := true;	
	end;	
end;

function CheckStopAttack: Boolean;
begin
	CurrentAttackTime := User.AtkTime;
	if not (CurrentAttackTime = LastAttackTime) then begin
		Engine.CancelTarget();
		WalkRandom(20, 40);
		LastAttackTime := CurrentAttackTime;
	end;
end;

function GetTarget_ToLower: Tl2Char;
var
i: Integer;
oTarget: Tl2Char;
begin
	result := user;
	
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) then continue;
		if (User.DistTo(oTarget) > 1000) then break;
		
		if oTarget.IsMember
		and IsClass_ZealotType(oTarget.ClassId)
		and oTarget.Pvp
		and (oTarget.Hp > 27) then begin
			result := oTarget;
			exit;
		end;		
	end;
	
end;

function Check_FlagPvp_OnNearestPartyMember: Boolean;
var
i: Integer;
oTarget: Tl2Char;
begin
	result := false;
	
	if (User.Pvp) then begin
		result := true;
		exit;
	end;
	
	if Party.Chars.Count < 1 then exit;
	
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or not (oTarget.IsMember) then continue;
		if (User.DistTo(oTarget) > 800) then break;
		
		if (oTarget.Hp > 70) then begin
			Engine.SetTarget(oTarget);
			Engine.Attack(1000, true);
			WalkRandom(10, 40);
			exit;
		end;
	
	end;

end;

function MoveFromGiranSpawnToDyeShop: void;
begin
  if (User.InRange(83368, 148600, -3392, 3500)) then begin
	Engine.MoveTo(82920, 148744, -3456);
	Engine.MoveTo(81736, 149560, -3456);
	Engine.MoveTo(81544, 149800, -3448);
	Engine.MoveTo(81624, 150248, -3520);
	Engine.MoveTo(81784, 150648, -3512);
	Engine.MoveTo(82792, 150872, -3520);
	Engine.MoveTo(83016, 150872, -3496);
	Engine.MoveTo(83272, 150760, -3496);
	Engine.MoveTo(83320, 150696, -3496);
	Engine.MoveTo(83320, 150552, -3496);
    print('Arrived at "Giran - Dye Shop"');    
  end;
end;

function SoaTunnelMove(StartRandomDelay: Integer): Void;
begin
	Engine.FaceControl(0, false);
	Delay(Random(StartRandomDelay));
    Engine.MoveTo(GetRandomXInCircle(300, -180168), GetRandomYInCircle(300, 185944), -10552);
    Engine.MoveTo(GetRandomXInCircle(80, -179688), GetRandomYInCircle(80, 186456), -10640);
    Engine.MoveTo(GetRandomXInCircle(50, -179512), GetRandomYInCircle(50, 186664), -10688);
    Engine.MoveTo(GetRandomXInCircle(30, -178904), GetRandomYInCircle(30, 186984), -10704);
    Engine.MoveTo(GetRandomXInCircle(30, -178904), GetRandomYInCircle(30, 187256), -10704);
    Engine.MoveTo(GetRandomXInCircle(20, -179032), GetRandomYInCircle(20, 187688), -10720);
    Engine.MoveTo(GetRandomXInCircle(20, -178968), GetRandomYInCircle(20, 187880), -10712);
    MoveTo_Timer((-178968 + 381), (187880 + 189) , -10712);
	Delay(2000 + Random(2000));
end;

function SellAllItems: void;
var
StoreIDList : TStringList;
i, j, nRank : Integer;
oItem, oItem2: Tl2Item;
HasItem: Boolean;
TempSellList, FinalSellList: array of Cardinal;
begin
	print('Selling Items...');
	PortToGludin;
	Delay(10000);
	WalkToNpcGludin;
	Delay(5000);
	SetLength(TempSellList, Inventory.User.Count * 2);
  
	StoreIDList := TStringList.Create;
	StoreIDList.LoadFromFile('Pvp_Sell_Ids.txt');
	j := 0;
	for i := 0 to Inventory.User.Count - 1 do begin
		oItem := Inventory.User.Items(i);
		if (StoreIDList.IndexOf(IntToStr(oItem.ID)) > -1) then begin
			TempSellList[j*2] := oItem.ID;
			TempSellList[(j*2) + 1] := oItem.Count;
			print('Item Nr. ' + IntToStr(j) + ': ' + oItem.Name + ', Added.');
			Inc(j);
		end;
	end;
	print('Total Sell Item Count = ' + IntToStr(j));
  
	if (j < 1) then begin
		print('No items to sell');
		Exit;
	end;
  
	SetLength(FinalSellList, j*2);
  
	for i := 0 to j - 1 do begin
		FinalSellList[i*2] := TempSellList[i*2];
		FinalSellList[(i*2)+1] := TempSellList[(i*2) + 1];
	end;
	print('Length of final list = ' + IntToStr(Length(FinalSellList)));
	Engine.CancelTarget;
	Engine.SetTarget(31076);
	OpenSellShop;
	engine.npctrade(true, FinalSellList);       
	Delay(1000);
	StoreIDList.Free;
	Print('Done, selling items.');
end;

function DepositAllItems_ToClanWh: void;
var
StoreIDList : TStringList;
i, j, nRank, amount : Integer;
oItem, oItem2: Tl2Item;
HasItem: Boolean;
TempSellList, FinalSellList: array of Cardinal;
begin
	print('Storing Items to clan wh...');
	Delay(300 + Random(5000));
	SetLength(TempSellList, Inventory.User.Count * 2);
  
	StoreIDList := TStringList.Create;
	StoreIDList.LoadFromFile(GetPath_FileSettings + 'Pvp_MailItems_IdList.txt');
	
	j := 0;
	for i := 0 to Inventory.User.Count - 1 do begin
		oItem := Inventory.User.Items(i);
		if (oItem.ItemType = 0)
		or (oItem.ItemType = 1)
		or (oItem.ItemType = 2) then continue;
		if (StoreIDList.IndexOf(IntToStr(oItem.ID)) > -1) then begin
		
			if (oItem.Id = 57) then amount := oItem.Count - 500000
			else amount := oItem.Count;
			
			if (amount <= 0) then continue;
			TempSellList[j*2] := oItem.ID;
			TempSellList[(j*2) + 1] := amount;
			print('Item Nr. ' + IntToStr(j) + ': ' + oItem.Name + ', Added.');
			Inc(j);
		end;
	end;
	print('Total Store Item Count = ' + IntToStr(j));
  
	if (j < 1) then begin
		print('No items to store');
		Exit;
	end;
  
	SetLength(FinalSellList, j*2);
  
	for i := 0 to j - 1 do begin
		FinalSellList[i*2] := TempSellList[i*2];
		FinalSellList[(i*2)+1] := TempSellList[(i*2) + 1];
	end;
	print('Length of final list = ' + IntToStr(Length(FinalSellList)));
	OpenClanWarehouse(true);
	Delay(1000);
	Engine.LoadItems(true, FinalSellList);     	
	Delay(1000);
	
	StoreIDList.Free;
	Print('Done, storing items.');
end;
function OpenClanWarehouse(deposit: Boolean): Void;
begin
	if (GetName_Server = 'Apocalyps') then begin
		ComTalk('_bbshome');
		ComTalk('01');
		ComTalk('0f');
		if deposit then
			ComTalk('012')
		else
			ComTalk('013');
	end else if (GetName_Server = 'World') then begin
		ComTalk('_bbshome');
		ComTalk('_bbsfile:bbs_npcs');
		ComTalk('_bbsfile:smallNpcs/warehouse');
		if deposit then
			ComTalk('_bbsscripts:Util:CommunityClanWarehouseDeposit;_bbsfile:smallNpcs/warehouse')
		else
			ComTalk('_bbsscripts:Util:CommunityClanWarehouseWithdraw;_bbsfile:smallNpcs/warehouse');
	end;
end;

function OpenSellShop: Void;
begin
  if (GetName_Server = 'Tales') then begin
    ComTalk('_bbshome');
    ComTalk('services');
    ComTalk('02');
    ComTalk('019');
  end else if (GetName_Server = 'GreenWorld') then begin
    ComTalk('_bbshome');
    ComTalk('_bbsgetfav');
    ComTalk('_bbsfile:smallNpcs/gmshop');
    ComTalk('118');
  end;
end;

function WalkToNpcGludin: Void;
begin
  Engine.MoveTo((-83096 + RandomizeNumber(50, 20)), (150872+ RandomizeNumber(50, 20)), -3104);
  Engine.CancelTarget;
  Engine.SetTarget(31076);
  Delay(1000);
end;


function MoveZaken: Void;
begin
  Engine.FaceControl(0, false);
  if not (GetName_Server = 'Idle') then Delay(Random(40 * 1000));
  OpenGK;
  PortToZaken;
  MoveFromGiranHarborToZaken;
end;

function MoveFromGiranHarborToZaken: Void;
begin
  if (User.InRange(47992, 186728, -3464, 2000)) then begin
    Engine.FaceControl(0, False);
    Engine.MoveTo(47992 + RandomizeNumber(100, 0), 186728 + RandomizeNumber(100, 0), -3464);
	Engine.MoveTo(48152 + RandomizeNumber(40, 0), 186808 + RandomizeNumber(40, 0), -3464);
    LeadDlg(32712, 1);
	Delay(3000 + Random(3000));
	Engine.MoveTo(GetRandomXInCircle(150, 52168), GetRandomYInCircle(150, 219096), -3208); 
  end;
end;


function ExitInstance(): void;
begin
  Delay(Random(5000));
  Engine.LeaveParty;
  Delay(3000 + Random(5000));
  PortRandomTown;
end;



function MoveFreya(): void;
begin
	Print('Go freya');
	Engine.FaceControl(0, False);
	Delay(Random(10000));
	OpenGK;
	PortFreyaRoad;
	WalkFreyaRoad;
	LeadDlg(32029, 1);
	Delay(1000 + Random(2000));
	MoveNearFreyaNpc;
end;



function WalkRandom(MinRange, MaxRange: Integer): Void;
//checked
var
z, x, y: Integer;
begin
  z := User.z;
  x := User.X;
  y := User.Y;
  MoveTo_Timer(RandomizeNumber(x, MaxRange), RandomizeNumber(y, MaxRange), z);
end;


function WalkFreyaRoad: void;
begin
	Engine.MoveTo(113768, -109992, -848);
	Engine.MoveTo(114344, -110376, -856);
	Engine.MoveTo(114648, -110632, -864);
	Engine.MoveTo(115471, -111660, -996);
	Engine.MoveTo(116146, -112935, -1166);
	Engine.MoveTo(116216, -113624, -1264);
	Engine.MoveTo(116350, -114732, -1571);
	Engine.MoveTo(116916, -115880, -1848);
	Engine.MoveTo(117579, -116461, -2040);
	Engine.MoveTo(117938, -116675, -2153);
	Engine.MoveTo(118284, -116749, -2275);
	Engine.MoveTo(119503, -117105, -2445);
	Engine.MoveTo(120973, -118190, -2502);
	Engine.MoveTo(121880, -119032, -2568);
	Engine.MoveTo(122211, -120544, -2794);
	Engine.MoveTo(122075, -121224, -2805);
	Engine.MoveTo(121893, -121568, -2759);
	Engine.MoveTo(121311, -122428, -2760);
	Engine.MoveTo(120550, -123926, -2766);
	Engine.MoveTo(119989, -124472, -2752);
	Engine.MoveTo(118904, -124888, -2800);
	Engine.MoveTo(118200, -124888, -2928);
	Engine.MoveTo(117560, -124472, -2960);
	Engine.MoveTo(117240, -124552, -2960);
	Engine.MoveTo(116872, -124904, -2976);
	Engine.MoveTo(116504, -125480, -3152);
	Engine.MoveTo(116232, -125672, -3216);
	Engine.MoveTo(115688, -125736, -3408);
	Engine.MoveTo(115528, -125720, -3416);
end;

function MoveNearFreyaNpc: Void;
begin
  if (User.InRange(102744, -124360, -2768, 2000)) then begin
    Engine.FaceControl(0, False);
    Engine.MoveTo(102744 + RandomizeNumber(150, 0), -124360 + RandomizeNumber(150, 0), -2768);
		
	Engine.MoveTo(102536 + RandomizeNumber(100, 0), -124392 + RandomizeNumber(100, 0), -2768);
  end;
end;

function TakePartyBuffs: Boolean;
var
oItem: Tl2Item;
begin
	result := false;
	if (User.InCombat) or (User.Pvp) then exit;
	if (Inventory.User.ById(40001, oItem)) then begin
		print('Take Buffs');
		
		Engine.UseItem(40001);
		AutoFollow();
		Delay(600);
		AutoFollow();
		ComTalk('Aiobuff_showProfiles_buffforparty');
		AutoFollow();
		if (User.Name = 'Ezekiel') or (User.name = 'Igneous') or (User.Name = 'iCharger') then
			ComTalk('Aiobuff_buffforparty_ PartyMage')
		else if (User.Name = 'Eviscerator') then
			ComTalk('Aiobuff_buffforparty_ PartyFighter');
		AutoFollow();
		result := true;
	end;
end;

function IsAnyoneMissingABuff(minTimeLeft: Integer; mageBuffs: Boolean = true; selfOnly: Boolean = false): Boolean;
var
i, j, buffId, buffCount: Integer;
oTarget: Tl2Char;
oBuff: Tl2Buff;
begin
	result := false;
	for i := 0 to Party.Chars.Count do begin
		
		if (i = Party.Chars.Count) or (selfOnly) then
			oTarget := User
		else begin
			if (i >= Party.Chars.Count) then break;
			oTarget := Party.Chars.Items(i);
		end;
		
		if (oTarget = nil) or (oTarget.Name = '') or (oTarget.Dead) or (User.DistTo(oTarget) > 900) then continue;
		
		if (mageBuffs) then buffCount := BuffList_Mage.Count
		else buffCount := BuffList_Fighter.Count;
		
		for j := 0 to buffCount - 1 do begin
			
			
			if (mageBuffs) then buffId := StrToInt(BuffList_Mage[j])
			else buffId := StrToInt(BuffList_Fighter[j]);
			
			if IsBuffException_OnTarget(buffId, oTarget) then continue;
			
			//if (i = 0) then print('BuffList[' + IntToStr(j) + '] = ' + IntToStr(buffId));
			
			if not (oTarget.Buffs.ById(buffId, oBuff)) then begin
				result := true;
				print('Buff Missing: ' + oTarget.Name + ' misses buff with id = ' + IntToStr(buffId));
				exit;
			end else begin
				if (oBuff.EndTime < minTimeLeft) then begin
					print('Buff Missing: ' + oTarget.Name + ' buff with id = ' + IntToStr(buffId) + ' has low time left: ' + IntToStr(oBuff.EndTime) + ' < ' + IntToStr(minTimeLeft));
					result := true;
					exit;
				end;
			end;
		end;
		if selfOnly then break;
	end;
end;


function IsBuffException_OnTarget(buffId: Integer; oTarget: Tl2Char): Boolean;
begin
	result := false;
	if (oTarget = nil) then exit;
	if not (oTarget.IsMember) and not (oTarget.Oid = User.Oid) then exit;
	
	if IsClass_FighterType(oTarget.ClassId) then begin
		
		if IsClass_Sk(oTarget.ClassId) then begin
		
			if (fighterCasterBuffExList.IndexOf(IntToStr(buffId)) >= 0) 
			or (defensiveBuffExceptionList.IndexOf(IntToStr(buffId)) >= 0) then result := true;
			
		end else if IsClass_Gh(oTarget.ClassId) or IsClass_Db(oTarget.ClassId) then begin
			// Fighter Caster (cuz casting speed based debuffs)
			
			if (fighterCasterBuffExList.IndexOf(IntToStr(buffId)) >= 0) then result := true;
		end else begin
			
			//Regular Fighter, that doesnt need cst spd
			if (fighterBuffExceptionList.IndexOf(IntToStr(buffId)) >= 0) then result := true;
			if (IsClass_Tank(oTarget.ClassId)) or (IsClass_Wl(oTarget.ClassId)) then begin
				if (defensiveBuffExceptionList.IndexOf(IntToStr(buffId)) >= 0) then result := true;
				
			end;
		end;
	
	end else begin
		
		//Regular Mystic
			if (mageBuffExceptionList.IndexOf(IntToStr(buffId)) >= 0) then result := true;
			if (GetClassValue_Healer(oTarget.ClassId) > 0) then begin
				if (defensiveBuffExceptionList.IndexOf(IntToStr(buffId)) >= 0) then result := true;
				
			end;
	end;
	
end;

function CheckRemove_BuffsByList: Boolean;
begin
	result := false;
	print('Check remove buffs started');
	if IsClass_FighterType(User.ClassId) then begin
		
		if IsClass_SK(User.ClassId) then begin
		
			CheckDispellBuffs_ByList(defensiveBuffExceptionList); 
			CheckDispellBuffs_ByList(fighterCasterBuffExList);
		end else if IsClass_Gh(User.ClassId) or IsClass_Db(User.ClassId) then begin
		
			// Fighter Caster (cuz casting speed based debuffs)
			CheckDispellBuffs_ByList(fighterCasterBuffExList);
		end else begin
			
			//Regular Fighter, that doesnt need cst spd
			CheckDispellBuffs_ByList(fighterBuffExceptionList);
			if (IsClass_Tank(User.ClassId)) or (IsClass_Wl(User.ClassId)) then begin
				CheckDispellBuffs_ByList(defensiveBuffExceptionList); 
			end;
		end;
	
	end else begin
		
		//Regular Mystic
		CheckDispellBuffs_ByList(mageBuffExceptionList);
		if (GetClassValue_Healer(User.ClassId) > 0) then CheckDispellBuffs_ByList(defensiveBuffExceptionList); 
	end;
	print('Check remove buffs ended');
end;



function CheckDispellBuffs_ByList(idStringList: TStringList): Boolean;
var
i, buffId: Integer;
oBuff: Tl2Buff;
begin
	result := false;
	
	for i := 0 to idStringList.Count - 1 do begin
		buffId := StrToInt(idStringList[i]);
		if (User.Buffs.ById(buffId, oBuff)) then begin
			Engine.Dispel(oBuff.Name);
			result := true;
			exit;
		end;
	end;
end;


function MoveTo_LoaForceFieldBridge: void;
begin
	OpenGK;
	Engine.DlgSel('Giran Area');
	Delay(1500);
	Engine.DlgSel(6);
	Delay(10000);
	LeadDlg(32869, 7);


end;





function AutoFollow_Move(oLeader: Tl2Char; randomRange, distance: Integer; currentPosition: Boolean): Boolean;
var
centerX, centerY, x, y, z, x2, y2: Integer;
movePoint, tempPoint, randomPoint: TPoint;
begin
	result := false;
	(*)
	if (FOLLOW_DELAY > 0) then begin
		print('Delay Detected..');
		if HasIntervalPassed_BySkillId(80001, FOLLOW_DELAY) then begin
			SetInterval_OnSkillId(80001, FOLLOW_DELAY);
			Print('Proceed');
		end else begin
			Print('Block Movement');
			exit; //If time has not passed, exit.
		end;
	end;*)
	
	if (oLeader = nil) or (oLeader.Name = '') or (not oLeader.Valid) then exit;
	if not IsTarget_ValidAndVisible_Char(oLeader) then exit;
	
	//if we are far away, move to leaders exact location, in order to get ingame pathfinding to avoid obstacles
	if (User.DistTo(oLeader) > ((distance + randomRange) * 1.5)) then begin
		x := oLeader.X;
		y := oLeader.Y;
		z := oLeader.Z;
		
		result := MoveTo_Timer(x, y, z);
		
		if not (User.Target = oLeader) then begin
			Engine.CancelTarget();
			Engine.SetTarget(oLeader);
			if (oLeader.Pvp) then
				WalkRandom(10, 20);
		end;
		exit;
	end;
	
	
	z := user.Z;
	
	if currentPosition then begin
		if (User.DistTo(oLeader) <= (distance + randomRange)) then exit;
		x := User.X;		y := User.Y;
		x2 := oLeader.X;	y2 := oLeader.Y;
		tempPoint := GetPointBehindTargetFromTarget(x2, y2, x, y, -distance);
		x := tempPoint.X; y := tempPoint.Y;
		if (x = 0) and (y = 0) then exit;
	end else begin
		//End position then...
		x := User.X;		y := User.Y;
		x2 := oLeader.ToX;	y2 := oLeader.ToY;
		
		if (User.DistTo(x2, y2, z) <= (distance + randomRange)) then exit;
		
		tempPoint := GetPointBehindTargetFromTarget(x2, y2, x, y, -distance);
		x := tempPoint.X; y := tempPoint.Y;
		if (x = 0) and (y = 0) then exit;	
	end;
	
	
	//Allow assignment of new random point, not more often than 3-8 sec (specified in initializeVariables.
	if HasIntervalPassed_BySkillId(80000, FOLLOW_RANDOM_TIME_CHANGE) then begin
		randomPoint := GetRandomPointInCircle(randomRange, 0, 0);
		FOLLOW_Random_X := randomPoint.X;
		FOLLOW_Random_Y := randomPoint.Y;
		
		if (FOLLOW_RANDOM_TIME_CHANGE_MAX > FOLLOW_RANDOM_TIME_CHANGE_MIN) then begin
			FOLLOW_RANDOM_TIME_CHANGE := FOLLOW_RANDOM_TIME_CHANGE_MIN + Random(FOLLOW_RANDOM_TIME_CHANGE_MAX - FOLLOW_RANDOM_TIME_CHANGE_MIN);
		end;
		SetInterval_OnSkillId(80000, FOLLOW_RANDOM_TIME_CHANGE);
	end;
	
	movePoint := Point(0, 0);
	movePoint.X := x + FOLLOW_Random_X;
	movePoint.Y := y + FOLLOW_Random_Y;
	
	if (movePoint.X = 0) and (movePoint.Y = 0) then exit;
	
	if not currentPosition then begin
	
		//If we are following the end point of leader - Allow assignment of a new move point, every 1-2 sec  (specified in initializeVariables.
		if (HasIntervalPassed_BySkillId(80001, FOLLOW_MOVE_TIME_CHANGE)) or ((FOLLOW_MOVE_X = 0) and (FOLLOW_MOVE_Y = 0))then begin
			FOLLOW_MOVE_X := movePoint.X;
			FOLLOW_MOVE_Y := movePoint.Y;
			if (FOLLOW_MOVE_TIME_CHANGE_MAX > FOLLOW_MOVE_TIME_CHANGE_MIN) then begin
				FOLLOW_MOVE_TIME_CHANGE := FOLLOW_MOVE_TIME_CHANGE_MIN + Random(FOLLOW_MOVE_TIME_CHANGE_MAX - FOLLOW_MOVE_TIME_CHANGE_MIN);
			end;
			SetInterval_OnSkillId(80001, FOLLOW_MOVE_TIME_CHANGE);
		end;
		
	end else begin
		
		//If we are following the current point of leader - Assign new move point instantly
		FOLLOW_MOVE_X := movePoint.X;
		FOLLOW_MOVE_Y := movePoint.Y;
	end;
	result := MoveTo_Timer(FOLLOW_MOVE_X, FOLLOW_MOVE_Y, z);
	if not CombatEnabled and (GetClassValue_Healer(User.ClassId) <= 0) then begin
		if not (User.Target = oLeader) then begin
			Engine.CancelTarget();
			Engine.SetTarget(oLeader);
			if (oLeader.Pvp) then
				WalkRandom(10, 20);
		end;
	end;

	//GetRandomPointInCircle(radius, centerX, centerY: Integer)
	//GetPointBehindTargetFromTarget(x1, y1, x2, y2: Integer; distance: Extended)   -distance so we get infront of target instead of behind
end;

function MoveTo_Timer(x, y, z: Integer; delay: Integer = -1): Boolean;
begin
	result := false;
	if (delay = -1) then delay := Movement_Delay;
	
	if (delay > 0) then begin
		if not TimerEx(Timer_MoveTo, delay) then exit;
	end;
	
	result := Engine.DMoveTo(x, y, z);
end;

function CheckPickupDrops: void;
var
i: Integer;
oDrop: Tl2Drop;
oBuff: Tl2Buff;
begin
	for i := 0 to DropList.Count - 1 do begin
		oDrop := DropList.Items(i);
		if (oDrop = nil) or not (oDrop.valid) then continue;
		if (User.DistTo(oDrop) > 900) then continue;
		if not (oDrop.IsMy) then continue;
		
		if (oDrop.Id = 13028) and not User.Buffs.ById(2580, oBuff) and not IsClass_Summoner(User.ClassID) then begin
			//Engine.
			Engine.Pickup(oDrop);
			exit;
		end;
	
	end;

end;



function CheckWalk_ToBack_AndStab(): Boolean;
var
oAttacker: Tl2Live;
oFriend: Tl2Char;
stabPoint: TPoint;
x1,x2,y1,y2, userZ, targetZ, i, lastX, lastY, 
lastZ, moveCount, breakCounter: Integer;
distance: Extended;
botWasOn: Boolean;
begin
	result := false;
    breakCounter := 0; moveCount := 0; lastX := 0; lastY := 0; lastZ := 0;
	if (User.Mp < 20) then Exit;
	oAttacker := nil;//GetTarget_AttackingParty_Special();
	if (oAttacker = nil) or not oAttacker.Valid then Exit;
	if (oAttacker.Target = nil) or not (oAttacker.Target.Valid) then exit
	else if (Party.Chars.ByName(oAttacker.Target.Name, oFriend)) then begin
	
		x1 := oAttacker.X;	y1 := oAttacker.Y;
		x2 := oFriend.X;	y2 := oFriend.Y;
		distance := 75;	//Distance behind the attacker.
	
		stabPoint := GetPointBehindTargetFromTarget(x1, y1, x2, y2, distance);
		
		if (stabPoint.X = 0) and (stabPoint.Y = 0) then exit;
		
		//The point is found, the enemy is found, 
		//	proceed, by moving to point, and stabbing enemy.	//Note: this method assumes 
					
		userZ := User.Z;
		if (User.InRange(stabPoint.X, stabPoint.Y, userZ, 40)) then begin
			if not (User.Target = oAttacker) then begin
				Engine.SetTarget(oAttacker);
			end;
			result := UseStabSkill(oAttacker);
		end else begin
			//Target ourself, in order to break the attack from adrenalin interface
			if not (User.Target.Oid = User.Oid) then begin
				Engine.CancelTarget();
				Engine.SetTarget(User);
			end;
			targetZ := oAttacker.Z;
			MoveTo_Timer(stabPoint.X, stabPoint.Y, targetZ);
		end;
		
	end;	
end;

function UseStabSkill(oTarget: Tl2Live): Boolean; overload;
begin
	result := false;
	if (oTarget = nil) or (not oTarget.Valid) or (oTarget.Target.Oid = User.Oid) or not IsTarget_Valid_Live(oTarget) then Exit;
	if (HasSkill_Ready(30)) then begin//Backstab
		if not(User.Target = oTarget) then begin
			Engine.SetTarget(oTarget);
		end;
		result := Engine.UseSkill(30);
	end else if (HasSkill_Ready(263)) then begin//Deadly blow
		if not(User.Target = oTarget) then begin
			Engine.SetTarget(oTarget);
		end;
		result := Engine.UseSkill(263);
	end;
end;
function UseStabSkill(oTarget: Tl2Char): Boolean; overload;
begin
	result := false;
	if (oTarget = nil) or (not oTarget.Valid) or (oTarget.Target.Oid = User.Oid) or not IsTarget_Valid_Char(oTarget) then Exit;
	if (HasSkill_Ready(30)) then begin//Backstab
		if not(User.Target = oTarget) then begin
			Engine.SetTarget(oTarget);
		end;
		result := Engine.UseSkill(30);
	end else if (HasSkill_Ready(263)) then begin//Deadly blow
		if not(User.Target = oTarget) then begin
			Engine.SetTarget(oTarget);
		end;
		result := Engine.UseSkill(263);
	end;
end;

function Check_AvoidBubbles: Boolean;
begin
	if (IsAnyBubbleClose()) then begin
		result := AutoFollow;
	end;
end;

function IsAnyBubbleClose: Boolean;
var
i: Integer;
oTarget: Tl2Live;
begin
	result := false;
	for i := 0 to NpcList.Count - 1 do begin
		oTarget := NpcList.Items(i);
		if (oTarget = nil) then continue;
		
		if (User.DistTo(oTarget) > BUBBLE_AOE_RANGE) then break;
		
		if IsTarget_BubbleObject(oTarget) then begin
			result := true;
			exit;
		end;
	end;
end;

function IsTarget_BubbleObject(oTarget: Tl2Live): Boolean;
var
nTargetId: Integer;
begin
	result := false;
	if (oTarget = nil) then exit;
	
	nTargetId := oTarget.Id;
	
	if (nTargetId <= 0) then exit;
	
	case nTargetId of
		
		123: result := true;
		
	end;
end;




function CheckCreateParty: Boolean;
var
myName: String;
begin
	try
		result := false;
		
		if not (HasIntervalPassed_BySkillId(80010, 2000)) then begin
			exit;
		end;
		
		myName := User.Name;
		
		//Members... (Leader if leader)
		if not (myName = GetName_Leader)
		and not (myName = GetName_SecondLeader)
		and not (myName = GetName_ThirdLeader)
		and not (myName = GetName_FirstSubPartyLeader()) 
		and not (myName = GetName_SecondSubPartyLeader()) 
		and not (myName = GetName_ThirdSubPartyLeader()) then begin
			
			
			if (Party.Chars.Count > 0) then begin
				if (User.Oid = Party.Leader.Oid) then begin
					Engine.LeaveParty();
					Print('Party - I am leader, leave party.');
					result := true;
				end;
			end;
		
		
		//Leaders... (Invite Members)
		end else begin
		
			if (myName = GetName_Leader) then begin
				if Check_InviteMember('Nastmine')
				or Check_InviteMember('FireSky')
				or Check_InviteMember('Ragnator')
				or Check_InviteMember('Kaballius')
				or Check_InviteMember('Ezekiel')
				or Check_InviteMember('iSky')
				or Check_InviteMember('Chaos')
				or Check_InviteMember('Trin1ty') then begin
					result := true;
				end;
			end else if (myName = GetName_SecondLeader) then begin
				if Check_InviteMember('iPrancer')
				or Check_InviteMember('iCure')
				or Check_InviteMember('Tranquility')
				or Check_InviteMember('iSpike')
				or Check_InviteMember('iStorm')
				or Check_InviteMember('NewEra')
				or Check_InviteMember('iReinn')
				or Check_InviteMember('Igneous') then begin
					result := true;
				end;
			end else if (myName = GetName_ThirdLeader) then begin
				if Check_InviteMember('EyeCandy')
				or Check_InviteMember('iSerenity')
				or Check_InviteMember('iSanity')
				or Check_InviteMember('iPain')
				or Check_InviteMember('Eviscerator')
				or Check_InviteMember('Undisputed')
				or Check_InviteMember('Insanity')
				or Check_InviteMember('iFury') then begin
					result := true;
				end;
			end else if (myName = GetName_FirstSubPartyLeader()) then begin
				if Check_InviteMember('iCharger')
				or Check_InviteMember('Cherry')
				or Check_InviteMember('iLast')
				or Check_InviteMember('PowerSpoil') then begin
					result := true;
				end;
			end else if (myName = GetName_SecondSubPartyLeader()) then begin
				if Check_InviteMember('Tipsy')
				or Check_InviteMember('Gipsy') then begin
				//or Check_InviteMember('iRecovery') then begin
					result := true;
				end;
			end else if (myName = GetName_ThirdSubPartyLeader()) then begin
				if Check_InviteMember('Candy') then begin
					result := true;
				end;
			end else begin
				Print('CheckCreateParty: Warning - Leader name is not recognized!');
				result := false;
				exit;
			end;
		
		end;
			
			
		if result then begin
			SetInterval_OnSkillId(80010, 2000);
		end;
	except
		on E : EInvalidPointer do begin
			Print('Pointer Exception Caught;');
			Print('Message: ' + E.Message);
			Print('StackTrace: ' + E.StackTrace);
		end;
		
		on E : Exception do begin
			Print('Exception Caught;');
			Print('Message: ' + E.Message);
			Print('StackTrace: ' + E.StackTrace);
		end;
	end;
end;

function Check_InviteMember(sName: string): Boolean;
var
oTarget, oTemp: Tl2Char;
begin
	result := false;
	if (sName = '') then exit;
	if Party.Chars.ByName(sName, oTemp) then exit;
	if (CharList.ByName(sName, oTarget)) then begin
		if (User.DistTo(oTarget) < 8000) then begin
			result := Engine.InviteParty(sName);
			Print('Party - Invite member: ' + sName);
		end;	
	end;
end;




end.



