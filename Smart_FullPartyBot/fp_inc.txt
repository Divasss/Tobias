unit fp_inc;
interface

function InitializeVariables: void;
function ResetVariables: void;

//function SetAttackTime: Boolean;

function wrap_Do_L2Idle_Rebuff: Boolean;
function wrap_DoRebuff: Boolean;

function IsTime_ToRebuff(): Boolean;
function CheckParty_DoCancelSleep: boolean;
function MapMove(X, Y: Integer): boolean;
function MoveTo_BackToZone: Boolean;
function MoveTo_AoePoint(rangeToPoint: Integer = 100; disableBot: Boolean = true): Boolean;
function MoveTo_AoePoint_WaitForFinish(rangeToPoint: Integer = 100): Boolean;
function MoveTo_AoePoint_RestoreSettings: void;
function IsSkillReady_OtherBotChar(skillId: Integer; sCharName: string; hpCost: Integer = 0; mpCost: Integer = 0): Boolean;

function CheckDo_DeadActions_Healer1: Boolean;
function CheckUse_MassBlockWindWalk: Boolean;
function CheckUse_AuraFlash: Boolean;
function CheckUse_Fear_Pvp(maxRange: Integer = 5000): Boolean;
function CheckUse_AoeSkill_Nuker: Boolean;
function CheckUse_AoeSkill_Nuker_Pvp: Boolean;
function Check_ClusterCharge: Boolean;
function Check_ClusterCharge_Pvp(): Boolean;
function Check_ClusterCharge_Pve(): Boolean;
function CheckUse_Charge(oTarget: Tl2Live): Boolean; Overload;
function CheckUse_Charge(oTarget: Tl2Char): Boolean; Overload;
function CheckUse_FinalSecret(): Boolean;
function CheckUse_HeroicValor_LeaderOnly: Boolean;
function CheckUse_HeroSelfBuffs: Boolean;
function Check_Trigger_Sos: Boolean;

function UseSkill_Safe(SkillId: Integer; oTarget: Tl2Live = nil; IsAttackSkill: Boolean = true; UseForUser: Boolean = false): Boolean; Overload;
function UseSkill_Safe(SkillId: Integer; oTarget: Tl2Char = nil; IsAttackSkill: Boolean = true; UseForUser: Boolean = false): Boolean; Overload;

function CheckMove_DeadParty_LeaderOnly: Boolean;
function VoiceCommand_Listen: Boolean;
function DoActions: Boolean;
function IsInPvp: Boolean;
function SetPvpStance: Boolean;
function GetName_Ee: string;
function SetPoint_PartyCenter: void;
function SetDistance_AoePointDistance: void;
function SetPoint_AoePosition(): TPoint;
function IsAoePoint_Valid: Boolean;
function IsOnlyTanksLeft: Boolean;
function IsOtherPlayersNearby(minRange: Integer): Boolean;
function ShouldIAgro: Boolean;

function IsTarget_Casting_Damaging_GroundSkill(oTarget: Tl2Char): Boolean;
function IsTarget_Casting_DayOfDoom(oTarget: Tl2Char): Boolean;

function GetOutOfCombat: void;
function IsUnderAttack: Boolean;
function IsTime_ToAoe: Boolean;
function IsTime_ToAoe_Pvp: Boolean;
function IsTime_ToAoe_Pve: Boolean;
function IsTime_ToBalanceLife: Boolean;
function IsTime_ToMajorGroupHeal: Boolean;
function IsTime_ToMassRez: Boolean;
function IsTime_ToSublime: Boolean;
function CheckUse_Sublime_Healer1Only(): Boolean;
function CheckUse_MassCleanse_Healer1Only(): Boolean;
function CheckUse_Miracle_Healer1Only(): Boolean;
function IsTime_ToHeal: Boolean;
function IsTime_ToHeal_Ee: Boolean;
function IsTime_ToPartyUd_Pve: Boolean;
function IsTime_ToPartyUd_Pvp: Boolean;
function LockCheck_MoveAndBot_Off: Boolean;
function LockCheck_MoveAndBot_On: Boolean;
function MoveToTarget_Timeout_Live(oTarget: Tl2Live; rangeToTarget, nTimeOut: Integer): Boolean;
function MoveTo_TimeOut(x, y, z, nMaxTime: Integer): Boolean;

function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean): Boolean; Overload;
function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean; oTarget: Tl2Live; range: Integer = 900): Boolean; Overload;
function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean; oTarget: Tl2Char; range: Integer = 900): Boolean; Overload;

function GetPartyNum: Integer;

function GetTarget_ToFollow(): Tl2Char;
function GetName_OtherHealer: string;
function GetName_Healer1: string;
function GetName_Healer2: string;
function GetName_Healer3: string;
function GetName_Server: string;
function GetPath_CharSettings: string;
function GetPath_FileSettings: string;
function GetPath_ZoneFolder: string;
function cLoadZone(zoneName: string): Boolean;
function cLoadConfig(configName: string): Boolean;
function GetName_Leader: string;
function GetName_CoLeader: string;
function GetName_SecondLeader: string;
function GetName_LocalLeader: string;
function GetTarget_MainAssist: Tl2Char;
function SetTarget_MainAssist: Boolean;

function GetParty_AverageHp_AliveOnly: Integer;
function GetParty_AverageHp_DeadIncluded: Integer;
function GetMinPartyHp: Integer;
function GetMinPartyMp: Integer;
function GetCount_DeadPartyWithinRange(nMaxRange: Integer): Integer;
function GetCount_MagesClustered_NearChar_Pvp(oCenterTarget: Tl2Char; range: Integer): Integer;
function GetCount_DamageDealers_NearChar_Pvp(oCenterTarget: Tl2Char; range: Integer): Integer;
function WriteError(ErrorMessage : string): void;

function ObjectDistTo_PartyCenter(obj: Tl2Spawn): Cardinal;

function IsSkillReady(skillID: Integer): Boolean; Overload;
function IsSkillReady(skillID: Integer; control: Tl2Control): Boolean; Overload;
function HasSkill_Ready_Interval(nSkillId, interval_ms: Integer): Boolean;
function UseSkill_SetInterval(nSkillId, intervalToSet: Integer; force: Boolean = false): Boolean;

function SetInterval_OnSkillId(nSkillId, intervalToSet: Integer; force: Boolean = false): Boolean;
function HasIntervalPassed_BySkillId(nSkillId, interval_ms: Integer): Boolean;

function IsAnyPartyBishopLowMp_NotMyself(maxMp : Integer): Boolean; overload;
function IsAnyPartyBishopLowMp_NotMyself(myControl: Tl2Control; maxMp : Integer): Boolean; overload;

function CheckSweep: boolean;

procedure Anti_EventPopup;

function SHIFT : boolean;
function CTRL : boolean;
function ALT : boolean;
function bHALF : boolean;

function BoolToStr(statement: Boolean): string;

function cEnterText(msg: string): Boolean;

function GetZone: Integer;
function GetClosestNpcOfId(NpcId: Integer): Tl2Live;

function IsAbnormalActive(searchId, abnormalId: Cardinal): Boolean;

function SetWeaponEquipped: Boolean;
function CheckDisarm(): Boolean;

function CompleteAutoFarm: void;

function KillAttackers: void;
function CMoveTo(x, y, z: Integer): boolean;

function CheckDispellBuffs(idList: array of integer): Boolean;
function CheckFindNewMob: Boolean;
function WaitForCasting: void;


implementation
uses
SysUtils, Classes, global_vars, fp_target_inc, fp_char_info, fp_actions_inc, fp_ap, fp_math_inc, class_unit, fp_AutoRelog;


function VoiceCommand_Listen: Boolean;
var
sCommand, prefix: string;
words: array of string;
oSender: Tl2Char;
oSkill: Tl2Skill;
oItem: Tl2Item;
x, y, z, adenaCount: Integer;
begin
	result := false;
	prefix := 'c';
	oSender := nil;
	if (ChatMessage.Unread)
	and (ChatMessage.Time < 10000)
	and (Party.Chars.ByName(ChatMessage.Sender, oSender) or (ChatMessage.Sender = GetName_Leader) or (ChatMessage.Sender = GetName_SecondLeader) or (ChatMessage.Sender = GetName_CoLeader))
	and not (ChatMessage.Sender = User.Name) then begin
		sCommand := ChatMessage.Text;
		words := sCommand.Split(' ');
		if not (words[0] = prefix) then Exit;
		sCommand := ChatMessage.Text;
		
		if (oSender = nil) then begin
			CharList.ByName(ChatMessage.Sender, oSender);
		end;
		
		if DuoPartyMode then begin
			if (User.Name = GetName_CoLeader) then begin
				//Co-Leader should pass commands along to Second-Leader
				PassCommandAlongTo_SecondLeader(sCommand);
			end else if (User.Name = GetName_SecondLeader) then begin
				//Second-Leader should pass commands along to his party
				if (Party.Chars.Count > 1) then
					Engine.Say(sCommand, 3, '');
			end;
		end;
		
		result := true;
		
		if (sCommand = prefix + ' start all') then begin
			Engine.FaceControl(0, true);
			TotalPause := false;
		
		end else if (sCommand = prefix + ' pause all') then begin
			Engine.FaceControl(0, false);
			TotalPause := true;
		
		end else if (sCommand = prefix + ' start heal') and (GetClassValue_Healer(User.ClassId) > 0) then begin
			Engine.FaceControl(0, true);
			TotalPause := false;
		
		end else if (sCommand = prefix + ' pause heal') and (GetClassValue_Healer(User.ClassId) > 0) then begin
			Engine.FaceControl(0, false);
			TotalPause := true;
		
		end else if (sCommand = prefix + ' pvp on') then begin
			PvpEnabled := true;
		
		end else if (sCommand = prefix + ' pvp off') then begin
			PvpEnabled := false;
		
		end else if (sCommand = prefix + ' pk on') then begin
			TotalPause := true;
			AA_AssistPk := true;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			CommandSenderList.Add(oSender.Name);
		
		end else if (sCommand = prefix + ' pk off') then begin
			TotalPause := false;
			AA_AssistPk := false;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
				
		end else if (sCommand = prefix + ' rbf') then begin
			DoRebuff;
			DoRebuff_Pet;
		
		end else if (sCommand = prefix + ' rbf slow') then begin
			Delay(Random(10000));
			DoRebuff;
			DoRebuff_Pet;
			
		end else if (IsClass_Summoner(User.ClassId) or IsClass_Judi(User.ClassId)) 
		and (sCommand = prefix + ' pull mobs') 
		and not AA_BringMobsMode then begin
			print('start pulling...');
			AA_BringMobsMode := true;
			if (MAX_PARTY_PT_DIST < 1200) then 
				temp_Max_Party_Pt_Dist := MAX_PARTY_PT_DIST;
			MAX_PARTY_PT_DIST := 1200;
			pulledMobList := TList.Create();
			
		end else if (IsClass_Summoner(User.ClassId)) 
		and (sCommand = prefix + ' stop pull mobs') 
		and AA_BringMobsMode then begin
			print('stop pulling...');
			AA_BringMobsMode := false;
			MAX_PARTY_PT_DIST := temp_Max_Party_Pt_Dist;
			if not (pulledMobList = nil) and (pulledMobList.Count > 0) then pulledMobList.Free();
		
		end else if (sCommand = prefix + ' go close') then begin
			Engine.FaceControl(0, false);
			TotalPause := true;
			IsMoving := true;
			AA_GoClose := true;
			AA_GoVeryClose := false;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			CommandSenderList.Add(oSender.Name);
		
		end else if (sCommand = prefix + ' go very close') then begin
			Engine.FaceControl(0, false);
			TotalPause := true;
			IsMoving := true;
			AA_GoClose := false;
			AA_GoVeryClose := true;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			CommandSenderList.Add(oSender.Name);
		
		end else if (sCommand = prefix + ' disable combat') then begin
			CombatEnabled := false;
		
		end else if (sCommand = prefix + ' enable combat') then begin
			CombatEnabled := true;
		
		end else if (sCommand = prefix + ' disable follow') then begin
			FollowEnabled := false;
		
		end else if (sCommand = prefix + ' enable follow') then begin
			FollowEnabled := true;
		
		
		end else if (sCommand = prefix + ' disable aoe') then begin
			AOE_ENABLED := false;
		
		end else if (sCommand = prefix + ' enable aoe') then begin
			AOE_ENABLED := true;
			
		end else if (sCommand = prefix + ' spread') then begin
			Engine.FaceControl(0, true);
			TotalPause := false;
			IsMoving := false;
			AA_GoClose := false;
			AA_GoVeryClose := false;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			
		end else if (sCommand = prefix + ' heal spread') and (GetClassValue_Healer(User.ClassID) > 0) then begin
			Engine.FaceControl(0, true);
			TotalPause := false;
			IsMoving := false;
			AA_GoClose := false;
			AA_GoVeryClose := false;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
		
		end else if (IsClass_Tank(User.ClassID)) and (sCommand = prefix + ' circle agro on') then begin
			CircleAgroMode := true;
			Engine.FaceControl(0, false);
			
		end else if (IsClass_Tank(User.ClassID)) and (sCommand = prefix + ' circle agro off') then begin
			CircleAgroMode := false;
		
		end else if (sCommand = prefix + ' discrete mode on') then begin
			DiscreteMode := true;
			
		end else if (sCommand = prefix + ' discrete mode off') then begin
			DiscreteMode := false;
			
		end else if (sCommand = prefix + ' use soe') then begin
			if (Inventory.user.ById(736, oItem)) then begin
				Engine.FaceControl(0, false);
				Engine.UseItem(736);
			end; 
			
		end else if (IsClass_Summoner(User.ClassId)) 
		and (sCommand = prefix + ' summon me') then begin
			if (SkillList.ById(1403, oSkill)) then begin
				if (oSkill.EndTime <= 0) or (oSkill.Endtime > 500000) then begin
					Engine.FaceControl(0, false);
					Delay(500);
					Engine.CancelTarget;
					Engine.SetTarget(ChatMessage.Sender);
					Engine.UseSkill(1403);
					Engine.FaceControl(0, true);
				end;
				
			end;
					
					
					
		end else if (interlude) then begin 
			//  If interlude mode is enabled, block the following commands.
			result := false;
			exit;
				
		end else if (Length(words) >= 2) and (words[1] = 'port') then begin
			HandleCommand_Port(sCommand);
				
		end else if (Length(words) >= 3) and (words[1] = 'talk') then begin
			HandleCommand_TalkToNpc(sCommand, oSender);
		
		end else if (sCommand = prefix + ' enter fog') then begin
			MoveTo_InsideFog;
		
		end else if (sCommand = prefix + ' enter lower fog') then begin
			LeadDlg(32645, 1);
		
		end else if (sCommand = prefix + ' take 7rb quest') then begin
			LeadDlg(30754, 2, 1, 1, 1, 1, 1);
			
		end else if (sCommand = prefix + ' enter baium') then begin
			LeadDlg(31862, 1, 1);
		
		end else if (sCommand = prefix + ' enter dv north') then begin
			LeadDlg(32865, 3);
		
		end else if (sCommand = prefix + ' mail me adena') then begin
			DoMails([57, 9547, 6393, 959, 9627, 9554, 10639]);
		
		end else if (sCommand = prefix + ' mail me everything') then begin
			DoAllMails();
			
		end else if (sCommand = prefix + ' restock') then begin
			Restock;
		
		end else if (sCommand = prefix + ' sell items') then begin
			SellAllItems;
		
		end else if (sCommand = prefix + ' store items') then begin
			DepositAllItems_ToClanWh;
		
		end else if (sCommand = prefix + ' ' + User.Name + ' buy dyes for everyone') then begin
			BuyAndSendDyesToParty;
		
		end else if (sCommand = prefix + ' enter soa') then begin
			LeadDlg(32734, 1);
		
		end else if (sCommand = prefix + ' walk soa tunnel') then begin
			SoaTunnelMove(3000);
		
		end else if (sCommand = prefix + ' move zaken') then begin
			MoveZaken();
		
		end else if (sCommand = prefix + ' exit instance') then begin
			ExitInstance();
		
		end else if (sCommand = prefix + ' move freya') then begin
			if (GetName_Server = 'Idle') then
				PortToIceMerchantCabin
			else
				MoveFreya();
		
		end else if (sCommand = prefix + ' move loa bridge') then begin
			MoveTo_LoaForceFieldBridge();
			
			
		
		end else if (sCommand = prefix + ' take core') then begin
			if (User.Inrange(102504, -124440, -2760, 1000)) and not (Inventory.user.ById(15469, oItem)) then begin
				Delay(Random(15000));
				Engine.FaceControl(0, False);
				Engine.MoveTo(102504 + RandomizeNumber(50, 25), -124440 + RandomizeNumber(50, 25), -2760);
				Engine.CancelTarget;
				LeadDlg(32761, 1);
			end;
		
		end else if (sCommand = prefix + ' use core') then begin
			Engine.FaceControl(0, False);
			Delay(500);
			Engine.StopCasting();
			WalkRandom(10, 20);
			Delay(500);
			Engine.UseItem(15469);
			Engine.UseItem(15469);
			Engine.UseItem(15469);
			print('Use Core!!!');
			While (User.Cast.EndTime > 0 ) do delay(500);
			Engine.FaceControl(0, True);
			
			
			
		
		end else if (sCommand = prefix + ' max dps') then begin
			if (SkillList.ById(1532, oSkill)) then begin
				Engine.FaceControl(0, False);
				Delay(500);
				if (User.Cast.EndTime > 0) then
					Engine.StopCasting;
				Delay(1000);
				Engine.UseSkill(1532);
				Engine.FaceControl(0, True);
			end;
		
		end else if (sCommand = prefix + ' shut everything down!') then begin
			Engine.GameClose;
			
		
		end else if (sCommand = prefix + ' to village') then begin
			Engine.GoHome;
			
		end else if (sCommand = prefix + ' drop adena') then begin
			if (Inventory.user.ById(57, oItem)) then begin
				x := User.X; y := User.Y; z := User.Z;
				adenaCount := oItem.Count;
				if (adenaCount > 100000) then begin
					Engine.dropitem(57, adenaCount - 90000, x, y, z);
					delay(3000);
				end;
			end; 
			if (Inventory.user.ById(6361, oItem)) then begin
				x := User.X; y := User.Y; z := User.Z;
				adenaCount := oItem.Count;
				if (adenaCount > 0) then begin
					Engine.dropitem(6361, adenaCount, x, y, z);
					delay(3000);
				end;
			end; 
					
		end else if (sCommand = prefix + ' item count') then begin
			Speak_ItemsCount_Party;
					
		end else if (sCommand = prefix + ' take vit') then begin
			if (Engine.SetTarget(4306)) then 
				LeadDlg(4306, 1);
					
		end else if (sCommand = prefix + ' reset vars') then begin
			ResetVariables;
					
		end else if (sCommand = prefix + ' inc follow rand') then begin
			FOLLOW_RANDOM_RANGE := FOLLOW_RANDOM_RANGE + 50;
			
		end else if (sCommand = prefix + ' inc follow dist') then begin
			FOLLOW_DIST := FOLLOW_DIST + 25;
					
		end else if (sCommand = prefix + ' dec follow rand') then begin
			if (FOLLOW_RANDOM_RANGE > 50) then
				FOLLOW_RANDOM_RANGE := FOLLOW_RANDOM_RANGE - 50
			else
				FOLLOW_RANDOM_RANGE := 0;
			
		end else if (sCommand = prefix + ' dec follow dist') then begin
			if (FOLLOW_DIST > 25) then
				FOLLOW_DIST := FOLLOW_DIST - 25
			else
				FOLLOW_DIST := 0;
			
		end else if (sCommand = prefix + ' follow setting') then begin			
			if (User.Name = GetName_CoLeader) then begin
				Delay(1000);
				Engine.Say('Follow distance = ' + IntToStr(FOLLOW_DIST), 3, '');
				Engine.Say('Follow random range = ' + IntToStr(FOLLOW_RANDOM_RANGE), 3, '');
			end;
			
		end else if (sCommand = prefix + ' lower') then begin
			LowHpMode := true;
			SetInterval_OnSkillId(99999, 120000);
			
		end else if (sCommand = prefix + ' stop lower') then begin
			LowHpMode := false;
			
		end else if (sCommand = prefix + ' duo mode on') then begin
			DuoPartyMode := true;
			print('Switched to duo party mode');
			
		end else if (sCommand = prefix + ' duo mode off') then begin
			DuoPartyMode := false;
			print('Switched to single party mode');
			
		end else if (sCommand = prefix + ' sos mode on') then begin
			SOS_POP_MODE := true;
			print('Switched to Spirit of Shilen triggering mode');
			
		end else if (sCommand = prefix + ' sos mode off') then begin
			SOS_POP_MODE := false;
			print('Switched off from Spirit of Shilen triggering mode');
			
		end else if (sCommand = prefix + ' lowest first on') then begin
			TargetSearch_LowestFirst := true;
			print('Switched to ''Lowest First'' target search mode');
			
		end else if (sCommand = prefix + ' lowest first off') then begin
			TargetSearch_LowestFirst := false;
			print('Switched off from ''Lowest First'' target search mode');
			
		end else if (sCommand = prefix + ' strongest first on') then begin
			TargetSearch_StrongestFirst := true;
			print('Switched to ''Strongest First'' target search mode');
			
		end else if (sCommand = prefix + ' strongest first off') then begin
			TargetSearch_StrongestFirst := false;
			print('Switched off from ''Strongest First'' target search mode');
			
		
		
		end else
			result := false;
		
		
		
	end;
end;

function PassCommandAlongTo_SecondLeader(sCommand: string): Boolean;
begin
	//Send commands two times, incase of miss-read
	Engine.Say(sCommand, 2, GetName_SecondLeader());
	Engine.Say(sCommand, 2, GetName_SecondLeader());
end;

function HandleCommand_Port(sMessage: string): Boolean;
var
sCommand: string;
words: array of string;
i: Integer;
begin
	result := false;
	
	words := sMessage.Split(' ');	
	
	sCommand := '';
	for i := 1 to Length(words) - 1 do begin
		if not(i = 1) then sCommand := sCommand + ' ';
		sCommand := sCommand + words[i];
	end;	
	
	result := true;
	
	if (sCommand = 'port toi1') then begin
		PortToi1;
	end else if (sCommand = 'port toi2') then begin
		PortToi2;
	end else if (sCommand = 'port toi3') then begin
		PortToi3;
	end else if (sCommand = 'port toi4') then begin
		PortToi4;
	end else if (sCommand = 'port toi5') then begin
		PortToi5;
	end else if (sCommand = 'port toi6') then begin
		PortToi6;
	end else if (sCommand = 'port toi7') then begin
		PortToi7;
	end else if (sCommand = 'port toi8') then begin
		PortToi8;
	end else if (sCommand = 'port toi9') then begin
		PortToi9;
	end else if (sCommand = 'port toi10') then begin
		PortToi10;
	end else if (sCommand = 'port toi11') then begin
		PortToi11;
	end else if (sCommand = 'port toi12') then begin
		PortToi12;
	end else if (sCommand = 'port toi13') then begin
		PortToi13;
	end else if (sCommand = 'port pavel') then begin
		PortPavel;
	end else if (sCommand = 'port fog') then begin
		PortFog;
	end else if (sCommand = 'port ev') then begin
		PortToEnchantedValley;
	end else if (sCommand = 'port breka') then begin
		PortToBreka;
	end else if (sCommand = 'port vos') then begin
		PortToValleyOfSaints;
	end else if (sCommand = 'port ivory') then begin
		PortToIvoryTower;
	end else if (sCommand = 'port abg') then begin
		PortToABG;
	end else if (sCommand = 'port cemetary') then begin
		PortToCemetary;
	end else if (sCommand = 'port beehive') then begin
		PortToBeehive;
	end else if (sCommand = 'port sos') then begin
		PortToSwampOfScreams;
	end else if (sCommand = 'port dv') then begin
		PortToDragonValley;
	end else if (sCommand = 'port dv mid') then begin
		PortToDragonValleyMid;
	end else if (sCommand = 'port loa') then begin
		PortToAntharasLair;
	end else if (sCommand = 'port orc barracks') then begin
		PortToOrcBarracks;
	end else if (sCommand = 'port windy hill') then begin
		PortWindyHill;
	end else if (sCommand = 'port town') then begin
		PortRandomTown;
	end else if (sCommand = 'port giran') then begin
		PortToGiran;
	end else if (sCommand = 'port heine') then begin
		PortToHeine;
	end else if (sCommand = 'port rune') then begin
		PortToRune;
	end else if (sCommand = 'port dion') then begin
		PortToDion;
	end else if (sCommand = 'port aden') then begin
		PortToAden;
	end else if (sCommand = 'port soa') then begin
		PortSoa;
	end else if (sCommand = 'port soi') then begin
		PortSoI;
	end else if (sCommand = 'port sod') then begin
		PortSoD;
	end else if (sCommand = 'port silent valley') then begin
		PortSilentValley;
	end else if (sCommand = 'port it') then begin
		PortImperialTomb;
	end else if (sCommand = 'port mos') then begin
		PortMonastery;
	end else if (sCommand = 'port mos upper') then begin
		PortMonasteryUpper;
	end else if (sCommand = 'port varka') then begin
		PortToVarka;
	end else if (sCommand = 'port gc') then begin
		PortGiantsCave;
	end else if (sCommand = 'port hb entrance') then begin
		PortToHellboundEntrance;
	end else if (sCommand = 'port hb quary') then begin
		PortToHellboundQuary;
	end else if (sCommand = 'port hb oasis') then begin
		PortToHellboundOasis;
	end else if (sCommand = 'port hb temple') then begin
		PortToHellboundAncientTemple;
	end else if (sCommand = 'port hb battered') then begin
		PortToHellboundBatteredLands;
	end else if (sCommand = 'port hb foundry') then begin
		PortToHellboundAtmoicFoundry;

	end else if (sCommand = 'port pagan') then begin
		PortPagan;
		Engine.MoveTo(34916, -49756, -760);
		Engine.SetTarget(32039);
		Delay(500);
		Engine.DlgOpen();
		Delay(3000);
		Engine.MoveTo(-13102, -35817, -10848);
		Engine.MoveTo(-15262, -35831, -10736);
		Engine.MoveTo(-16379, -36518, -10720);
		Engine.MoveTo(-16245, -36709, -10720);
		
		
		
	end else if (sCommand = 'port dark omens') then begin
		PortCataDarkOmens;
	end else if (sCommand = 'port forbidden path') then begin
		PortCataForbiddenPath;
	end else if (sCommand = 'port witch') then begin
		PortCataWitch;
	end else if (sCommand = 'port apostate') then begin
		PortCataApostate;
	end else if (sCommand = 'port branded') then begin
		PortCataBranded;
	end else if (sCommand = 'port heretics') then begin
		PortCataHeretics;
	end else if (sCommand = 'port saints') then begin
		PortNecroSaints;
	end else if (sCommand = 'port disciples') then begin
		PortNecroDisciple;
	end else if (sCommand = 'port martyrdom') then begin
		PortNecroMartyrdom;
	end else if (sCommand = 'port devotion') then begin
		PortNecroDevotion;
	end else if (sCommand = 'port patriots') then begin
		PortNecroPatriots;
	end else if (sCommand = 'port worshippers') then begin
		PortNecroWorshippers;
	end else if (sCommand = 'port pilgrims') then begin
		PortNecroPilgrims;
	end else if (sCommand = 'port sacrifice') then begin
		PortNecroSacrifice;
	
	
	
	
	
	
	
	
	
	end else 
		result := false;
	

end;

function HandleCommand_TalkToNpc(sMessage: string; oCommander: Tl2Char): Boolean;
var
sCommand: string;
words: array of string;
talkIndices: array of Integer;
npcId, commandLength: Integer;
i: Integer;
oNpc: Tl2Live;
begin
	result := false;
	
	words := sMessage.Split(' ');	
	commandLength := Length(words);
	if (commandLength < 3) then exit;
	if (oCommander = nil) or (oCommander.Target = nil) then exit;
	
	if (words[0] = 'c')
	and (words[1] = 'talk') then begin
		
		SetLength(talkIndices, commandLength - 2);
		for i := 0 to Length(talkIndices) - 1 do begin
			//Skip the first 2 words. ('c', 'talk')
			talkIndices[i] := StrToIntDef(words[i + 2], 0);
			if (talkIndices[i] = 0) then begin
				print(words[i + 2] + ' is not recognized as a number.');
				exit;
			end;
		end;
	
		oNpc := oCommander.target;
		
		//Check if the desired npc is present
		if not (oNpc = nil) then begin
			
			//Fail safe
			if (not oNpc.Valid)
			or (User.DistTo(oNpc) > 1000)
			or (oNpc.Attackable) then begin
				Print('Npc: ' + oNpc.Name + ' is not available.');
				exit;
			end;
			
			//Speak to npc
			Engine.CancelTarget();
			Engine.SetTarget(oNpc);
			Delay(200);
			if (User.DistTo(oNpc) > 75) then Engine.MoveToTarget(-75);
			Delay(500);
			Engine.DlgOpen();
			Delay(1000);
			for i := 0 to Length(talkIndices) - 1 do begin
				if not Engine.DlgSel(talkIndices[i]) then exit;
				Delay(1000);
			end;
			
			result := true;
		end;
	end;
end;


function IsTime_ToTrigger_Sos_OnTarget(oTarget: Tl2Char): Boolean;
var
oBuff: Tl2Buff;
begin
	result := false;
	if (oTarget = nil) or not oTarget.IsMember then exit;
	if not IsClass_Sk(oTarget.ClassId) then exit;
	if User.DistTo(oTarget) > 700 then exit;
	
	//If we already have Spirit of shilen, then false.
	If User.Buffs.ById(789, oBuff) or oTarget.Buffs.ById(789, oBuff) then exit;
	
	if oTarget.Buffs.ById(788, oBuff)
	or ((oTarget.Buffs.ById(5564, oBuff)) and (oBuff.Level < 3)) then result := true
end;

function Check_Trigger_Sos: Boolean;
var
i: Integer;
oTarget, oResult: Tl2Char;
found: Boolean;
begin
	result := false;
	if not SOS_POP_MODE then exit;
	
	found := false;
	oResult := nil;
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) then continue;
		if not oTarget.Dead 
		and (oTarget.Hp > 60) 
		and IsTime_ToTrigger_Sos_OnTarget(oTarget) then begin
			found := true;
			oResult := oTarget;
		end;
	end;
	
	if found and not (oResult = nil) then begin
		if not (User.Target = oResult) then begin
			Engine.CancelTarget;
			Engine.SetTarget(oResult);
		end;
		Engine.Attack(50, true);
		SOS_TargetFound := true;
		result := true;
	end else if SOS_TargetFound then begin
		WalkRandom(5, 10);
		SOS_TargetFound := false;
	end;
	
end;

function CheckDo_DeadActions_Healer1: Boolean;
begin
	result := false;
	
	if (User.Dead) and (User.Name = GetName_Healer1) then begin
		if CheckUse_Sublime_Healer1Only
		or (PvpLoaded and CheckUse_Miracle_Healer1Only)
		or (PvpLoaded and CheckUse_MassCleanse_Healer1Only) then begin
			result := true;
			exit;
		end;
	end;	
end;

function CheckParty_DoCancelSleep: boolean;
var
i: Integer;
oTarget, temp: Tl2Char;
begin
	result := false;
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or not (CharList.ByName(oTarget.Name, temp)) then continue;
		
		if not(oTarget.Dead)
		and IsAbnormalActive(128, oTarget.AbnormalId) then begin
			result := true;
			engine.SetTarget(oTarget);
			Engine.Attack(500, true);
			exit;
		end;
	end;
end;

function DoMails(IdList: array of Cardinal): Boolean;
var
i, j, IDLength: Integer;
TempMailList, MailList: array of Cardinal;
ItemCount: Cardinal;
oItem: Tl2Item;
HasItem: Boolean;
recipentName: string;
begin
	//print('Mail adena initiated.');
  j := 0;
  IdLength := Length(IdList);
  SetLength(TempMailList, (2 * (IdLength)));
  for i := 0 to IdLength - 1 do begin
  HasItem := Inventory.User.ByID(IdList[i], oItem);
    if (HasItem) then begin
	  if (oItem.ID = 57) then begin
        ItemCount := oItem.count - 10000000;
        if (ItemCount < 30000) then continue;
      end else begin
        ItemCount := oItem.Count;
      end;	  
	  if (ItemCount > 0) then begin
	    TempMailList[j*2] := IdList[i];
		TempMailList[(j*2)+1] := ItemCount;
		Inc(j);
	  end;
	end;
  end;  
	
	//print('Found ' + IntToStr(j) + ' items to mail.');
  if (j > 0) then begin
    SetLength(MailList, (j*2));
    for i := 0 to j - 1 do begin
	  MailList[i*2] := TempMailList[i*2];
	  MailList[(i*2)+1] := TempMailList[(i*2) + 1];
	  print('Added item with id = ' + IntToStr(MailList[i*2]) + ' with count = ' + IntToStr(MailList[(i*2)+1]));
	end;
	recipentName := GetName_LocalLeader;
	//print('Send mail to ' + recipentName);
    Engine.SendMail(recipentName, 'Thanks for the help', 'I suck big time :D', MailList);
  end;
end;

function DoAllMails(): Boolean;
var
i, j, mailIndex, IDLength: Integer;
TempMailList, MailList: array of Cardinal;
ItemCount: Cardinal;
oItem: Tl2Item;
leaderName: string;
exceptionList: TStringList;
begin
	print('Start Mailing');
	result := false;
	j := 0;
	
	exceptionList := TStringList.Create();
	
	IdLength := Mail_List.Count;
	if (IdLength <= 0) then begin
		print('mail list not found');
		exit;
	end;
	
	leaderName := GetName_LocalLeader;
	if (leaderName = '') then begin
		Print('no mail leader found');
		exit;
	end;
	
	SetLength(TempMailList, (2 * (IdLength)));
	for i := 0 to IdLength - 1 do begin
		if (Inventory.User.ByID(StrToInt(Mail_List[i]), oItem)) then begin
			if (oItem.ID = 57) then begin
				ItemCount := oItem.count - 10000000;
				if (ItemCount < 30000) then continue;
			end else begin
				ItemCount := oItem.Count;
			end;	  
			if (ItemCount > 0) 
			and not (oItem.Equipped) 
			and (exceptionList.IndexOf(Mail_List[i]) = -1) 
			and ((oItem.ItemType = 5) or (oItem.ItemType = 4)) then begin
				print('Found Item to mail: ' + oItem.Name + ' with count = ' + IntToStr(ItemCount));
				TempMailList[j*2] := StrToInt(Mail_List[i]);
				TempMailList[(j*2)+1] := ItemCount;
				exceptionList.Add(Mail_List[i]);
				Inc(j);
			end;
		end;
	end;  
	print('We found ' + IntToStr(j) + ' items to mail');
	while (j > 0) do begin
	
		if (j <= 8) then begin
			SetLength(MailList, (j*2));
			for i := 0 to j - 1 do begin
				MailList[i*2] := TempMailList[i*2];
				MailList[(i*2)+1] := TempMailList[(i*2) + 1];
			end;
			j := j - 8;
			Engine.SendMail(leaderName, 'Last mail', 'items...', MailList);
			print('Send last Mail with ' + IntToStr(Length(MailList) div 2) + ' items.' );
		end else if (j > 8) then begin
			SetLength(MailList, 16);
			mailIndex := 0;
			for i := j - 8 to j - 1 do begin
				MailList[mailIndex * 2] := TempMailList[i*2];
				MailList[(mailIndex * 2)+1] := TempMailList[(i*2) + 1];
				Inc(mailIndex);
			end;
			j := j - 8;
			Engine.SendMail(leaderName, 'More mails comming...', 'items...', MailList);
			print('Send Mail with ' + IntToStr(Length(MailList) div 2) + ' items.' );
			
		end;
		Delay(20000);
	end;
	
	print('Ended Mailing');
end;

function DoActions: Boolean;
var
caller: Tl2Char;
callerFound: Boolean;
oBuff: Tl2Buff;
callerName: string;
begin
	result := true;
	
	if (Check_AutoRelog) then begin
		Delay(5000);
		exit;
	end;
	
	CheckDisarm();
	CheckPickupDrops;
	if IsMissingBuffs then begin
	
		if CombatEnabled and not PauseForBuffs then begin
			PauseForBuffs := true;
			CombatEnabled := false;
		end;
	
		if IsTime_ToRebuff then begin
			print('Time to rebuff ourself');
			DoRebuff;
			
			if PauseForBuffs then begin
				PauseForBuffs := false;
				CombatEnabled := true;
			end;
			
		end;
		
		//Allow healers to continue
		if not (GetClassValue_Healer(User.ClassId) > 0) then begin
			if not TotalPause then AutoFollow();
			exit;
		end;
	end;
	if IsTime_ToRebuff_Pet then begin
		print('Time to rebuff pet');
		DoRebuff_Pet;
	end;	
	
	if DuoPartyMode then begin
		callerName := GetName_LocalLeader;
		callerFound := Party.Chars.ByName(callerName, caller) or CharList.ByName(callerName, caller);
	end else begin
	
		if (CommandSenderList.Count > 0) then
			callerFound := CharList.ByName(CommandSenderList[0], caller)
		else
			callerFound := false;
		
		callerName := caller.Name;
	end;
	
	if (AA_GoClose) and callerFound then begin
		Action_GoClose(callerName, 70);
	
	end else if (AA_GoVeryClose) and callerFound then begin
		Action_GoClose(callerName, 20);
	
	end else if (AA_AssistPk) and callerFound then begin
		Action_AssistPk(callerName);
	
	end else
		result := false;
end;

function IsTime_ToRebuff(): Boolean;
var
oBuff: Tl2Effect;
begin
	result := false;
	if (interlude) or (GetName_Server = 'Idle') then exit;
	
	if (user.InCombat or User.PVP or User.PK) or User.Dead then exit;
	
	if (User.Buffs.Count < 18) then begin
		result := true;
		exit;
	end;
	//If no noblesse or Salvation
	if not canBuffNoblesse then begin
		if not User.Buffs.ByID(1323, oBuff) and not User.Buffs.ByID(1410, oBuff) then begin
			result := true;
			exit;
		end;
	end;
end;

function IsMissingBuffs(): Boolean;
var
oBuff: Tl2Effect;
begin
	result := false;
	if (interlude) or (GetName_Server = 'Idle') then exit;
	
	if (User.Buffs.Count < 18) then begin
		result := true;
		exit;
	end;
	//If no noblesse or Salvation
	if not canBuffNoblesse then begin
		if not User.Buffs.ByID(1323, oBuff) and not User.Buffs.ByID(1410, oBuff) then begin
			result := true;
			exit;
		end;
	end;
end;

function IsAnyoneMissingBuffs_Apocalyps: Boolean;
var
i: Integer;
oTarget: Tl2Char;
oBuff: Tl2Buff;
begin
	result := false;
	for i := 0 to Party.Chars.Count do begin
		if (i = Party.Chars.Count) then oTarget := User
		else oTarget := Party.Chars.Items(i);
		
		if (oTarget = nil) then continue;
		if (not oTarget.Buffs.ById(1323, oBuff) and not oTarget.Buffs.ByID(1410, oBuff)) 
		or (oTarget.Buffs.Count < 15) then begin
			result := true;
			exit;
		end;
	
	end;
end;

function IsTime_ToRebuff_Pet(): Boolean;
var
oBuff: Tl2Effect;
oPet: Tl2Pet;
begin
	result := false;
	if (interlude) or (GetName_Server = 'Idle') then exit;
	
	if (user.InCombat or User.PVP or User.PK) or User.Dead then exit;
	
	if (PetList.Count < 1) then exit;
	oPet := PetList.Items(0);
	if (oPet = nil) or (oPet.Dead) or (not oPet.Valid) then exit;
	
	if (oPet.Buffs.Count < 18) then begin
		result := true;
		exit;
	end;
	//If no noblesse or Salvation
	if canBuffNoblesse then begin
		if not oPet.Buffs.ByID(1323, oBuff) and not oPet.Buffs.ByID(1410, oBuff) then begin
			result := true;
			exit;
		end;
	end;
end;
(*
function SetAttackTime: Boolean;
var
currentAttackTime: Cardinal;
currentTime: TDateTime;
begin
	result := false;
	
	print('LastAttackTime = ' + IntToStr(LastAttackTime));
	
	currentAttackTime := user.AtkTime;
	print('currentAttackTime = ' + IntToStr(currentAttackTime));
	
	currentTime := now;
	TotalTimePassed := GetMillisecondsInBetween(StartTime, currentTime);
	AttackStartTime := AttackStartTime + (currentTime - StartTime);
	StartTime := currentTime;
	
	print('AttackStartTime = ' + TimeToStr(AttackStartTime));
	print('AttackStartTime in ms= ' + IntToStr(TimeToMs(AttackStartTime)));
	
	//We have made a new attack
	if (currentAttackTime > LastAttackTime) then begin
		if (AttackStartTime >= MsToTime(currentAttackTime)) then
			TimeSinceLastAttack := TimeToMs(AttackStartTime) - currentAttackTime
		else 
			TimeSinceLastAttack := 0;
			
		LastAttackTime := currentAttackTime;
		print('LastAttackTime = ' + IntToStr(LastAttackTime));
		
		
	//We have not attacked since last time, update time since last attack
	end else if (currentAttackTime = LastAttackTime) then begin
		TimeSinceLastAttack := TimeToMs(AttackStartTime) - LastAttackTime;
		print('Time since last attack is ' + IntToStr(TimeSinceLastAttack div 1000));
	end else begin
		print('WARNING ERROR!!! SetAttackTime: Variable Overflow!');
		print('currentAttackTime = ' + IntToStr(currentAttackTime));
		print('TotalTimePassed = ' + IntToStr(TotalTimePassed));
		print('LastAttackTime = ' + IntToStr(LastAttackTime));
		print('TimeSinceLastAttack = ' + IntToStr(TimeSinceLastAttack));
		
	end;
	
	result := true;
end;
*)
function SetPvpStance: Boolean;
var
inPvp: Boolean;
begin
	result := false;
	
	if DiscreteMode and (PlayersNearby) then begin
		PvpLoaded := false;
		PveLoaded := false;
		if not DiscreteLoaded then begin
			DiscreteLoaded := true;
			cLoadConfig(User.Name +'_Off.xml');
			Print('Loaded Discrete Settings');
		end;
		//Print('Switched to Discrete/Off Mode');
		Exit;
	end;
	
	if LowHpMode then begin
		PvpLoaded := false;
		PveLoaded := false;
		DiscreteLoaded := false;
		if not LowHpSettingLoaded then begin
			if IsClass_ZealotType(User.ClassId) then begin
				Engine.FaceControl(0, false);
			end;
			cLoadConfig(User.Name +'_LowHp.xml');
			LowHpSettingLoaded := true;
			Engine.AutoSoulShot('Soulshot (S-Grade)', false);
			Print('Loaded Low Hp Settings');
		end;
		Exit;
	end;
	
	if LowHpSettingLoaded then begin
		Print('Left LowHpMode, reload soulshots, and possibly interface control');
		Engine.AutoSoulShot('Soulshot (S-Grade)', true);
		if not TempOff and not TotalPause then
			Engine.FaceControl(0, true);
	end;
	
	
	
	
	
	inPvp := IsInPvp;
	if (inPvp) and not PvpLoaded then begin
		PvpLoaded := true;
		PveLoaded := false;
		cLoadConfig(User.Name +'_PvP.xml');
		Print('Switched to Pvp Mode');
		DiscreteLoaded := false;
		LowHpSettingLoaded := false;
	end else if (not inPvp) and not PveLoaded then begin
		PvpLoaded := false;
		PveLoaded := true;
		cLoadConfig(User.Name +'_Pve.xml');
		Print('Switched to Pve Mode');
		DiscreteLoaded := false;
		LowHpSettingLoaded := false;
	end;
	
	result := true;
end;

function IsInPvp: Boolean;
//checked
var
i, x, y, TempX, TempY: Integer;
oTarget: Tl2Char;
begin
	//print('IsInPvp: Started');
	result := false;
	if not(PvpEnabled) then Exit;
	
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) then begin
			Continue;
		end;
		
		//print('IsInPvp: Checking: ' + oTarget.Name);
	
		x := oTarget.x;
		y := oTarget.Y;
		TempX := PT_PX;
		TempY := PT_PY;
		if (GetDistanceBetweenPoints(TempX, TempY, x, y) > MAX_RANGE_PVP_SEARCH) then continue;
		//print('IsInPvp: not too far away');
		if (IsTarget_Pvp(oTarget)) then begin
			result := true;
			Exit;
		end;
		//print('IsInPvp: ' + oTarget.Name + ' was not a pvp target');
	end;
end;


function LockCheck_MoveAndBot_Off: Boolean;
begin
	result := false;
	if (TempOff) or IsMoving or MoveLock then Exit;
	
	if (Engine.GetFaceState(0)) then begin
		Engine.FaceControl(0, false);
		TempOff := true;
	end;
	IsMoving := true;
	MoveLock := true;
	
	
	result := true;
end;
function LockCheck_MoveAndBot_On: Boolean;
begin
	result := false;
	
	if (MoveLock) then begin
		if (TempOff) then begin
			Engine.FaceControl(0, true);
			TempOff := false;
		end;
		IsMoving := false;
		MoveLock := false;
		
		result := true;
	end;
end;

function WaitForCasting: void;
var
castTime: Cardinal;
begin
	while (User.Cast.EndTime > 0) do begin
		castTime := User.Cast.EndTime;
		if (castTime > 60000) then begin
			Print('Abnormal casting time detected, escape!');
			exit;
		end else if (castTime > 1000) and (castTime <= 60000) then begin
			Delay(950);
		end else if (castTime > 100) and (castTime <= 1000) then begin
			Delay(95);
		end else if (castTime > 0) and (castTime <= 100) then begin
			Delay(20);
		end;
	end;
end;

function MoveTo_AoePoint(rangeToPoint: Integer = 100; disableBot: Boolean = true): Boolean;
var
BotWasOn: Boolean;
z, counter : Integer;
begin
	result := false;
	if not (IsAoePoint_Valid) then exit;
	
	BotWasOn := Engine.GetFaceState(0);
	if disableBot and (BotWasOn) and not MovingTo_AoePoint then begin
		MovingTo_AoePoint := true;
		Engine.FaceControl(0, false);
	end;
	z := User.Z;
	if not (User.Target = user) then
		Engine.SetTarget(User);
	if (FOLLOW_DELAY <=	0) then begin
		counter := 0;
		while (User.DistTo(AOE_PX, AOE_PY, z) > rangeToPoint) do begin
			MoveTo_Timer(AOE_PX, AOE_PY, z);
			Delay(200);
			counter := counter + 1;
			if (counter >= 3) then break;
		end;
	end else begin
		MoveTo_Timer(AOE_PX, AOE_PY, z);
	end;
	z := User.Z;
	result := User.InRange(AOE_PX, AOE_PY, z, rangeToPoint);
end;
function MoveTo_AoePoint_RestoreSettings: void;
begin
	if MovingTo_AoePoint then begin
		MovingTo_AoePoint := false;
		Engine.FaceControl(0, true);
	end;
end;
(* before changes
function MoveTo_AoePoint(rangeToPoint: Integer = 100): Boolean;
var
BotWasOn: Boolean;
z, counter : Integer;
begin
	result := false;
	if not (IsAoePoint_Valid) or IsMoving or TempOff then exit;
	BotWasOn := Engine.GetFaceState(0);
	if (BotWasOn) and not (TempOff) and not IsMoving then begin
		TempOff := true;
		IsMoving := true;
		Engine.FaceControl(0, false);
	end;
	z := User.Z;
	if not (User.Target = user) then
		Engine.SetTarget(User);
	if (FOLLOW_DELAY <=	0) then begin
		counter := 0;
		while (User.DistTo(AOE_PX, AOE_PY, z) > rangeToPoint) do begin
			MoveTo_Timer(AOE_PX, AOE_PY, z);
			Delay(200);
			counter := counter + 1;
			if (counter >= 3) then break;
		end;
	end else begin
		MoveTo_Timer(AOE_PX, AOE_PY, z);
	end;
	if (BotWasOn) and TempOff and IsMoving then begin
		TempOff := false;
		IsMoving := false;
		Engine.FaceControl(0, true);
	end;
	z := User.Z;
	result := User.InRange(AOE_PX, AOE_PY, z, rangeToPoint);
end;*)


function MoveTo_AoePoint_WaitForFinish(rangeToPoint: Integer = 100): Boolean;
var
BotWasOn: Boolean;
z, counter : Integer;
begin
	result := false;
	if not (IsAoePoint_Valid) then exit;
	
	BotWasOn := Engine.GetFaceState(0);
	if (BotWasOn) and not MovingTo_AoePoint then begin
		MovingTo_AoePoint := true;
		Engine.FaceControl(0, false);
	end;
	
	if not (User.Target = user) then
		Engine.SetTarget(User);
		
	counter := 0;
	while (User.DistTo(AOE_PX, AOE_PY, z) > rangeToPoint)
	and (not User.Dead) do begin
		z := User.Z;
		MoveTo_Timer(AOE_PX, AOE_PY, z);
		Delay(100);
			
		//Escape if it is no longer time to Aoe
		if IsTime_ToAoe then SetPoint_AoePosition
		else break;
		
			
		counter := counter + 1;
		if (counter >= 25) then break; //Break after 25*100 ms = 2500 ms = 2,5 seconds
	end;

	if MovingTo_AoePoint then begin
		MovingTo_AoePoint := false;
		Engine.FaceControl(0, true);
	end;
	
	z := User.Z;
	result := User.InRange(AOE_PX, AOE_PY, z, rangeToPoint);
end;


function SetDistance_AoePointDistance: void;
var
z : Integer;
begin
	if not IsAoePoint_Valid then AOE_PT_DIST := 0
	
	else begin
		z := User.z;
		AOE_PT_DIST := User.DistTo(AOE_PX, AOE_PY, z);
	end;
end;

function IsAoePoint_Valid: Boolean;
begin
	if (AOE_PX = 0) and (AOE_PY = 0) then result := false
	else result := true;
end;


function IsSkillReady_OtherBotChar(skillId: Integer; sCharName: string; hpCost: Integer = 0; mpCost: Integer = 0): Boolean;
//checked
var
nEndTime: Integer;
oSkill: Tl2Skill;
oOtherChar: Tl2Char;
control: Tl2Control;
begin
	//print('IsSkillReady_OtherBotChar: Started, checking ' + sCharName + ', for skill = ' + IntToStr(skillID));
	result := false;
	control := getControl(sCharName);
	  
	if CharList.ByName(sCharName, oOtherChar)
	and (assigned(control)) then begin
	//print('IsSkillReady_OtherBotChar: Assigned: ' + oOtherChar.Name);
	
		if (hpCost > 0) then begin
			if (control.GetUser.CurHp < hpCost) then exit;
		end;
		if (mpCost > 0) then begin
			if (control.GetUser.CurMp < mpCost) then exit;
		end;
	
		if (skillID = 1409) then begin //Check cleanse item...
			if not HasItem_MinCount(control, 8874, 1) then exit;
		end;
	
		oSkill := nil;
		control.GetSkillList.ByID(skillId, oSkill);
		
		if (oSkill = nil) or (oSkill.Disabled) then begin 
			WriteError('IsOtherBotChar_SkillReady: oSkill = nil 1.');
			Exit;
		end;
		nEndTime := oSkill.EndTime;
		if ((nEndTime = 0) or (nEndTime >= 760000))
		or (oOtherChar.cast.Id = skillId) and (oOtherChar.Cast.EndTime > 0) then begin
		  result := True;
		  //print('IsOtherBotChar_SkillReady: result is true, ' + sCharName + ' has skill ready!');
		end;
	end;
end;


function GetSkill_OnOtherBotChar(skillId: Integer; sCharName: string): Tl2Skill;
//checked
var
nEndTime: Integer;
oSkill: Tl2Skill;
oOtherChar: Tl2Char;
control: Tl2Control;
begin
	//print('IsSkillReady_OtherBotChar: Started, checking ' + sCharName + ', for skill = ' + IntToStr(skillID));
	result := nil;
	control := getControl(sCharName);
	  
	if CharList.ByName(sCharName, oOtherChar)
	and (assigned(control)) then begin
	//print('IsSkillReady_OtherBotChar: Assigned: ' + oOtherChar.Name);
	
		oSkill := nil;
		if control.GetSkillList.ByID(skillId, oSkill) then begin
		
			if (oSkill = nil) or (oSkill.Disabled) then begin 
				WriteError('GetSkill_OnOtherBotChar: oSkill = nil 1.');
				Exit;
			end;
			result := oSkill;
		end;
	end;
end;

function IsSkillReady(skillID: Integer): Boolean; Overload;
var
skill: Tl2Skill;
begin
	result := false;
	if not (SkillList.ByID(skillID, skill)) then exit;
	
	if (skill.EndTime <= 0) or (skill.EndTime > 7600000) then result := true;
end;
function IsSkillReady(skillID: Integer; control: Tl2Control): Boolean; Overload;
var
skill: Tl2Skill;
begin
	result := false;
	if Assigned(control) then begin
		if not (control.GetSkillList.ByID(skillID, skill)) then exit;
		
		if (skill.EndTime <= 0) or (skill.EndTime > 7600000) then result := true;
	end;
end;

function SetPoint_AoePosition(): TPoint;
var
pt: TPoint;
begin
	pt := Point(0, 0);
	if (PvpLoaded = null) then WriteError('CalculateBestAoePosition: PvpLoaded = nil');
	if (PvpLoaded) then 
		pt := GetPoint_AoePosition_Pvp
	else 
		pt := GetPoint_AoePosition_Pve;  

	AOE_PX := pt.X;
	AOE_PY := pt.Y;
	result := pt;
end;

function GetPoint_AoePosition_Pvp: TPoint;
var
oTarget, oCenterTarget, cchar: Tl2Char;
i, EndX, EndY, nDivider: Integer;
begin
	result := Point(0, 0);
	EndX := 0;
	EndY := 0;
	nDivider := 0;
  
	oCenterTarget := GetTarget_MostClustered_Char;
	if not IsTarget_ValidAndVisible_Char(oCenterTarget) then begin
		Exit;
	end;
	
	//Investigate all enemies within range of 1k
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) then begin
			WriteError('CalculateBestAoePosition_Pvp: oTarget = nil');
			Continue;
		end;
		if (User.DistTo(oTarget) > MAX_RANGE_PVP_SEARCH + MAX_RANGE_AOE) then break;
		if (oCenterTarget.DistTo(oTarget) > (MAX_RANGE_AOE + 100))
		or not (IsTarget_Valid_Char(oTarget)) then Continue;
	
		EndX := EndX + oTarget.X;
		EndY := EndY + oTarget.Y;
		nDivider := nDivider + 1;
	end;

	if (nDivider > 1) then begin
		EndX := EndX div nDivider;
		EndY := EndY div nDivider;
	end;
  
	if (EndX = 0) and (EndY = 0) then begin
		result := Point(0, 0);
	end else begin
		result := Point(EndX, EndY);
	end;
end;

function GetPoint_AoePosition_Pve: TPoint;
var
oTarget, oCenterTarget, temp: Tl2Live;
i, EndX, EndY, nDivider, x, y: Integer;
begin
  result := Point(0, 0);
  EndX := 0;
  EndY := 0;
  nDivider := 0;
  oCenterTarget := GetTarget_MostClustered_Live;
  if not IsTarget_ValidAndVisible_Live(oCenterTarget) then begin
    Exit;
  end;

  //Investigate all enemies within range of 1k
  for i := 0 to NpcList.Count - 1 do begin
    oTarget := NpcList.Items(i);
	if (oTarget = nil) then begin
	  WriteError('CalculateBestAoePosition_Pve: oTarget = nil');
	  Continue;
	end;
	if (User.DistTo(oTarget) > MAX_RANGE_NPC_SEARCH) then break;
	if (oCenterTarget.DistTo(oTarget) > (MAX_RANGE_AOE+100))
	or not (IsTarget_Valid_Live(oTarget)) then Continue;
	
	EndX := EndX + oTarget.X;
	EndY := EndY + oTarget.Y;
	nDivider := nDivider + 1;
  end;

  if (nDivider > 1) then begin
    EndX := EndX div nDivider;
	EndY := EndY div nDivider;
  end;
  if (EndX = 0) and (EndY = 0) then begin
    WriteError('CalculateBestAoePosition_Pve: Point = (0, 0)');
    result := Point(0, 0);
  end else begin
    result := Point(EndX, EndY);
  end;
end;





function IsTime_ToAoe: Boolean;
begin
	result := false;
	if not AOE_ENABLED then exit;
	if (PvpLoaded = null) then WriteError('IsTime_ToAoe: PvpLoaded = null');
	if (PvpLoaded) then 
		result := IsTime_ToAoe_Pvp
	else 
		result := IsTime_ToAoe_Pve;
end;

function IsTime_ToAoe_Pvp: Boolean;
var
oTarget, oTarget2: Tl2Char;
i, j, searchRange, dist1, count, minClusterCount: Integer;
begin
  result := false;
  searchRange := 650;
  count := 0;
  minClusterCount := 4;
  for i := 0 to CharList.Count-2 do begin
    oTarget := CharList.Items(i);
	
	if (oTarget = nil) then begin
	  WriteError('IsTime_ToAoe_Pvp: oTarget = nil');
	  Continue;
	end;
	dist1 := User.DistTo(oTarget);
	if (dist1 > searchRange) then break;
	if not (IsTarget_Valid_Char(oTarget)) then continue;
	
	for j := (i + 1) to CharList.Count-1 do begin
		if (j = i) then Continue;
		oTarget2 := CharList.Items(j);
		if (oTarget2 = nil) then begin
			WriteError('IsTime_ToAoe_Pvp: oTarget2 = nil');
			Continue;
		end;
		
		if (User.DistTo(oTarget2) > searchRange + MAX_RANGE_AOE) then break;
		
		if (oTarget.DistTo(oTarget2) <= MAX_RANGE_AOE) 
		and (IsTarget_Valid_Char(oTarget2)) then begin
			count := count + 1;
			if (count >= minClusterCount) then begin
				result := true;
				print('Time to aoe true - Target count = ' + IntToStr(count));
				exit;
			end;
		end;
	end; 
  end;
	if (count >= minClusterCount) then begin
		result := true;
		print('Time to aoe true - Target count = ' + IntToStr(count));
		exit;
	end;
end;

function IsTime_ToAoe_Pve: Boolean;
var
oTarget, oTarget2: Tl2Live;
i, j, counter: Integer;
begin
  result := false;
  counter := 0;
  
  for i := 0 to NpcList.Count-1 do begin
    oTarget := NpcList.Items(i);
	
	if (oTarget = nil) then begin
	  WriteError('IsTime_ToAoe_Pve: oTarget = nil, solved?');
	  Continue;
	end;
	if (User.DistTo(oTarget) > 650) then break;
	if not (IsTarget_Valid_Live(oTarget))
	or not IsTarget_OnUs_Live(oTarget) then continue;
	
	if (GetCount_EnemiesNearTarget_Pve_Live(oTarget) > 2) then begin
		result := true;
		Exit;
	end;
	(*
	for j := 0 to NpcList.Count-1 do begin
	  if (j = i) then Continue;
	  oTarget2 := NpcList.Items(j);
	  if (oTarget2 = nil) then begin
	    WriteError('IsTime_ToAoe_Pve: oTarget2 = nil');
	    Continue;
	  end;
	  if (oTarget = nil) then begin
	    WriteError('IsTime_ToAoe_Pve: oTarget = nil');
	    Continue;
	  end;
	  if (oTarget.DistTo(oTarget2) <= MAX_RANGE_AOE) 
	  and (IsTarget_Valid_Live(oTarget2)) then begin
	    Inc(counter);
	  end;
	end;*) 
  end;
end;

function CheckUse_AoeSkill_Nuker: Boolean;
var
botWasOn: Boolean;
begin
	//botWasOn := Engine.GetFaceState(0);
	//if botWasOn then Engine.FaceControl(0, false);
	result := CheckUse_AoeSkill_Nuker_Pvp;
	//if botWasOn then Engine.FaceControl(0, true);
end;

function CheckUse_AoeSkill_Nuker_Pvp: Boolean;
var
myClass, dist: Integer;
castLongRange, classSorcerer, classSpellsinger: Boolean;
begin
	result := false;
	myClass := User.ClassId;
	castLongRange := false;
	classSorcerer := false;
	classSpellsinger := false;
	dist := 0;
	
	if IsClass_Sorc(myClass) then classSorcerer := true
	else if IsClass_Sps(myClass) then classSpellsinger := true
	else begin
		Print('CheckUse_AoeSkill_Nuker: Error - class not recognized!');
		exit;
	end;
	//Has any long range aoe-attacks ready?
	if (IsClass_Sorc(myClass)) then begin
		if HasSkill_Ready(1467) //Meteor has 600 range
		or HasSkill_Ready(1554) //Aura Blast has 900 range
		or HasSkill_Ready(1296) then //Rain of Fire has 500 range
			castLongRange := true;
	end else if IsClass_Sps(myClass) then begin
		if HasSkill_Ready(1468) //Star Fall has 600 range
		or HasSkill_Ready(1554) //Aura Blast has 900 range
		or HasSkill_Ready(1295) then //Aqua Splash has 500 range
			castLongRange := true;
	end;
	//Close range aoe attacks
	SetPoint_AoePosition;
	if not IsAoePoint_Valid then begin
		Print('CheckUse_AoeSkill_Nuker: Error - Failed to set aoe point');
		exit;
	end;
	SetDistance_AoePointDistance;
	
	if castLongRange 
	and (AOE_PT_DIST > 150) 
	and SetTarget_MostClustered_Pvp then begin
	
		//Long range aoe attacks
		dist := User.DistTo(User.Target);
		if (dist <= 0) then begin
			Print('CheckUse_AoeSkill_Nuker: Error - distance was 0');
			exit;
		end;
		
		if classSorcerer then begin
			//Sorcerer Long range aoe attack
			if (dist > 650) and HasSkill_Ready(1554) then begin //Aura Blast, from far distance
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if HasSkill_Ready(1467) then begin // Meteor
				result := Engine.DUseSkill(1467, true, false);
				exit;
			end else if (HasSkill_Ready(1554)) then begin //Aura Blast, regardless of range
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if (dist > 300) and (HasSkill_Ready(1296)) then begin //Rain of fire
				result := Engine.DUseSkill(1296, true, false);
				exit;
			end;
			
		end else if classSpellsinger then begin
			//Spellsinger Long range aoe attack
			if (dist > 650) and HasSkill_Ready(1554) then begin //Aura Blast, from far distance
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if HasSkill_Ready(1468) then begin // Star Fall
				result := Engine.DUseSkill(1468, true, false);
				exit;
			end else if (HasSkill_Ready(1554)) then begin //Aura Blast, regardless of range
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if (dist > 300) and (HasSkill_Ready(1295)) then begin //Aqua Splash
				result := Engine.DUseSkill(1295, true, false);
				exit;
			end;
			
		end;
	
	end;
		
	if (AOE_PT_DIST > 80) then begin
		MoveTo_AoePoint(70, false); //Dont disable bot from here, since we are already attack paused. 
		result := true;
		exit; 
	end;
		
	if SetTarget_Nearest_Pvp then begin
		if classSorcerer then begin
			//Sorcerer close range aoe attack
			if HasSkill_Ready(1467) then begin // Meteor
				result := Engine.DUseSkill(1467, true, false);
				exit;
			end else if (HasSkill_Ready(1554)) then begin //Aura Blast
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if HasSkill_Ready(1417) then begin //Aura Flash
				result := Engine.DUseSkill(1417, true, false);
				exit;
			end else if HasSkill_Ready(1171) then begin // Blazing Circle
				result := Engine.DUseSkill(1171, true, false);
				exit;
			end else if (HasSkill_Ready(1296)) then begin //Rain of fire
				result := Engine.DUseSkill(1296, true, false);
				exit;
			end;
			
		end else if classSpellsinger then begin
			//Spellsinger close range aoe attack
			if HasSkill_Ready(1468) then begin // Star Fall
				result := Engine.DUseSkill(1468, true, false);
				exit;
			end else if (HasSkill_Ready(1554)) then begin //Aura Blast
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if HasSkill_Ready(1417) then begin //Aura Flash
				result := Engine.DUseSkill(1417, true, false);
				exit;
			end else if HasSkill_Ready(1454) then begin // Diamond Dust
				result := Engine.DUseSkill(1454, true, false);
				exit;
			end else if (HasSkill_Ready(1174)) then begin //Frost Wall
				result := Engine.DUseSkill(1174, true, false);
				exit;
			end else if (HasSkill_Ready(1295)) then begin //Aqua Splash
				result := Engine.DUseSkill(1295, true, false);
				exit;
			end;
				
		end;
	end;
	
end;

function CheckUse_Fear_Pvp(maxRange: Integer = 5000): Boolean;
//checked
var
oTarget: Tl2Char;
attackWasOn: Boolean;
begin
	result := false;
	if not HasSkill_Ready(1169) then exit;
	oTarget := GetTarget_ToFear_Pvp(maxRange);
	if (oTarget = user) or (oTarget = nil) or not IsTarget_ValidAndVisible_Char(oTarget) then Exit;
	
	attackWasOn := Engine.GetFaceState(1); //Attacks enabled?
	if attackWasOn then begin
		Engine.FaceControl(1, false);
	end;
	//Wait for casting to finish
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 3000) do Delay(175);
	while (User.Cast.EndTime > 0) and (User.Cast.EndTime < 210) do Delay(20);
	
	if not (User.Target = oTarget) then begin
		Engine.SetTarget(oTarget);
	end;
	result := Engine.DUseSkill(1169, true, false); //Curse Fear 
	
	if attackWasOn then begin
		Engine.FaceControl(1, true);
	end;
	
end;

function UseSkill_Safe(SkillId: Integer; oTarget: Tl2Live = nil; IsAttackSkill: Boolean = true; UseForUser: Boolean = false): Boolean; Overload;
var
interfaceWasOn: Boolean;
begin
	result := false;
	
	if not HasSkill_Ready(SkillId) then exit;
	
	if IsAttackSkill then begin
		interfaceWasOn := Engine.GetFaceState(1); //Attacks enabled?
	end else begin
		interfaceWasOn := Engine.GetFaceState(2) or Engine.GetFaceState(3); //Heal/Buff enabled?
	end;
	if interfaceWasOn then begin
		if (IsAttackSkill) then begin
			Engine.FaceControl(1, false);
		end else begin
			Engine.FaceControl(2, false);
			Engine.FaceControl(3, false);
		end;
	end;
	
	//Wait for any casting to finish
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 3000) do Delay(175);
	while (User.Cast.EndTime > 0) and (User.Cast.EndTime < 210) do Delay(20);
	
	if UseForUser then begin
		if (oTarget = User) 
		and not (User.Target = User) then Engine.SetTarget(User);
		
	end else if not (oTarget = nil) 
	and not (oTarget = User)
	and not (User.Target = oTarget) then begin
		Engine.SetTarget(oTarget);
	end;
	
	result := Engine.DUseSkill(SkillId, true, false);
	
	if interfaceWasOn then begin
		if (IsAttackSkill) then begin
			Engine.FaceControl(1, true);
		end else begin
			Engine.FaceControl(2, true);
			Engine.FaceControl(3, true);
		end;
	end;
	
end;

function UseSkill_Safe(SkillId: Integer; oTarget: Tl2Char = nil; IsAttackSkill: Boolean = true; UseForUser: Boolean = false): Boolean; Overload;
begin
	result := UseSkill_Safe(SkillId, (oTarget as Tl2Live), IsAttackSkill, UseForUser)
end;

function CheckUse_MassBlockWindWalk: Boolean;
var
maxRange: Integer;
begin
	//GetTarget_Char(EvalFunc: TEvaluateCharFunction; maxRange: Integer): Tl2Char; Overload;
	result := false;
	maxRange := 200;
	if TimerEx(Timer_BlockWw, SKILL_CD_MASS_BLOCK_WW) and not (GetTarget_Char(EvaluateChar_Valid, maxRange) = nil) then begin
		result := Engine.DUseSkill(1361, true, false);
	end;
end;
function CheckUse_AuraFlash: Boolean;
var
maxRange: Integer;
begin
	//GetTarget_Char(EvalFunc: TEvaluateCharFunction; maxRange: Integer): Tl2Char; Overload;
	result := false;
	maxRange := 200;
	if not (GetTarget_Char(EvaluateChar_ValidNotDisabled, maxRange) = nil) then begin
		result := Engine.DUseSkill(1417, true, false);
	end;
end;

(*
function CheckUse_SlhSilence_Pvp(maxRange: Integer = 5000; TimeInterval: Cardinal = 5000): Boolean;
var
oTarget: Tl2Char;
attackWasOn: Boolean;
begin
	result := false;
	//if not TimerEx(Timer_SlhSilence, TimeInterval) then 
	
	if not HasSkill_Ready(1169) then exit;
	oTarget := GetTarget_ToFear_Pvp(maxRange);
	if (oTarget = user) or (oTarget = nil) or not IsTarget_ValidAndVisible_Char(oTarget) then Exit;
	
	attackWasOn := Engine.GetFaceState(1); //Attacks enabled?
	if attackWasOn then begin
		Engine.FaceControl(1, false);
	end;
	//Wait for casting to finish
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 3000) do Delay(175);
	while (User.Cast.EndTime > 0) and (User.Cast.EndTime < 210) do Delay(20);
	
	if not (User.Target = oTarget) then begin
		Engine.SetTarget(oTarget);
	end;
	result := Engine.DUseSkill(1169, true, false); //Curse Fear 
	
	if attackWasOn then begin
		Engine.FaceControl(1, true);
	end;
end;
	*)

function IsTarget_Casting_Damaging_GroundSkill(oTarget: Tl2Char): Boolean;
begin
	result := false;
	if (oTarget = nil) or (oTarget.Name = '') then exit;
	if (oTarget.Cast.EndTime > 0) then begin
		result := IsSpell_Damaging_GroundSkill(oTarget.Cast.Id);
	end;
end;
function IsTarget_Casting_DayOfDoom(oTarget: Tl2Char): Boolean;
begin
	result := false;
	if (oTarget = nil) or (oTarget.Name = '') then exit;
	if (oTarget.Cast.EndTime > 0) then begin
		result := oTarget.Cast.Id = DAY_OF_DOOM_ID;
	end;
end;
function IsSpell_Damaging_GroundSkill(nSpellId: Integer): Boolean;
begin
	result := false;
	case nSpellId of 
		1419: result := true; //Volcano (Sorc 80)
		1423: result := true; //Gahenna (Necro 80)
		1421: result := true; //Raging Waves (Spellsinger 80)
		1420: result := true; //Cyclone (Spellhowler 80)
	end;

end;

function GetCount_ClusteredMages_Pvp: Integer;
var
oTarget, oTarget2: Tl2Char;
i, j, count: Integer;
begin
	result := 0;
	count := 0;
	for i := 0 to CharList.Count-1 do begin
		oTarget := CharList.Items(i);
	
		if (oTarget = nil) then begin
			WriteError('IsTime_ToAoe_Pvp: oTarget = nil');
			Continue;
		end;
	
		if (User.DistTo(oTarget) > MAX_PARTY_PT_DIST) 
		or not (IsTarget_Valid_Char(oTarget))
		or IsClass_FighterType(oTarget.ClassId) then continue;
	
		for j := 0 to CharList.Count-1 do begin
			if (j = i) then Continue;
			oTarget2 := CharList.Items(j);
			if (oTarget2 = nil) then begin
				WriteError('IsTime_ToAoe_Pvp: oTarget2 = nil');
				Continue;
			end;
			if (oTarget.DistTo(oTarget2) <= MAX_RANGE_AOE) 
			and (IsTarget_Valid_Char(oTarget2)) 
			and not IsClass_FighterType(oTarget2.ClassId) then begin
				Inc(count);
			end;
		end; 
	end;
	result := count;
end;

function GetCount_MagesClustered_NearChar_Pvp(oCenterTarget: Tl2Char; range: Integer): Integer;
var
oTarget, oTarget2: Tl2Char;
i, j, count: Integer;
begin
	result := 0;
	if (oCenterTarget = nil) or (not oCenterTarget.Valid) or (oCenterTarget.Name = '') then exit;
	count := 0;
	for i := 0 to CharList.Count-1 do begin
		oTarget := CharList.Items(i);
	
		if (oTarget = nil) then begin
			WriteError('IsTime_ToAoe_Pvp: oTarget = nil');
			Continue;
		end;
	
		if (oCenterTarget.DistTo(oTarget) > range) then continue;
		if (User.DistTo(oTarget) > MAX_RANGE_PVP_SEARCH) then break;
		
		if not (IsTarget_Valid_Char(oTarget))
		or IsClass_FighterType(oTarget.ClassId) then continue;
	
		Inc(count);
	end;
	result := count;
end;

function GetCount_DamageDealers_NearChar_Pvp(oCenterTarget: Tl2Char; range: Integer): Integer;
var
oTarget, oTarget2: Tl2Char;
i, j, count: Integer;
begin
	result := 0;
	if (oCenterTarget = nil) or (not oCenterTarget.Valid) or (oCenterTarget.Name = '') then exit;
	count := 0;
	for i := 0 to CharList.Count-1 do begin
		oTarget := CharList.Items(i);
	
		if (oTarget = nil) then begin
			WriteError('IsTime_ToAoe_Pvp: oTarget = nil');
			Continue;
		end;
	
		if (oCenterTarget.DistTo(oTarget) > range) then continue;
		if (User.DistTo(oTarget) > MAX_RANGE_PVP_SEARCH) then break;
		
		if not (IsTarget_Valid_Char(oTarget))
		or not IsClass_DD(oTarget.ClassId) then continue;
	
		Inc(count);
	end;
	result := count;
end;

function GetPoint_AoePosition_Pvp_ClusteredMages: TPoint;
var
oTarget, oCenterTarget, cchar: Tl2Char;
i, EndX, EndY, nDivider: Integer;
begin
	result := Point(0, 0);
	EndX := 0;
	EndY := 0;
	nDivider := 0;
  
	oCenterTarget := GetTarget_MostClustered_Char_MagesOnly;
	if not IsTarget_ValidAndVisible_Char(oCenterTarget) then begin
		Exit;
	end;
	
	//Investigate all enemies within range of 1k
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) then begin
			WriteError('CalculateBestAoePosition_Pvp: oTarget = nil');
			Continue;
		end;
		if (oCenterTarget.DistTo(oTarget) > (MAX_RANGE_AOE + 100))
		or not (IsTarget_Valid_Char(oTarget))
		or (IsClass_FighterType(oTarget.ClassId)) then Continue;
	
		EndX := EndX + oTarget.X;
		EndY := EndY + oTarget.Y;
		nDivider := nDivider + 1;
	end;

	if (nDivider > 1) then begin
		EndX := EndX div nDivider;
		EndY := EndY div nDivider;
	end;
  
	if (EndX = 0) and (EndY = 0) then begin
		result := Point(0, 0);
	end else begin
		result := Point(EndX, EndY);
	end;
end;

function GetCount_FriendlyBishopsDeadNear_NonParty(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		if (oTarget.IsMember) then continue;
		if (User.DistTo(oTarget) > maxRange) then break;
		if IsClass_Bp(oTarget.ClassId) 
		and (oTarget.Dead)
		and IsTarget_Friendly(oTarget) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function GetCount_PartyBishopsDeadNear(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > maxRange) then continue;
		
		if IsClass_Bp(oTarget.ClassId) 
		and (oTarget.Dead) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function GetCount_BishopsDeadNear(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > maxRange) then continue;
		
		if IsClass_Bp(oTarget.ClassId) 
		and (oTarget.Dead) 
		and IsTarget_Friendly(oTarget) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function GetCount_FriendsDeadNear(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	if (User.Dead) then counter := 1;
	
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > maxRange) then break;
		
		if (oTarget.Dead)
		and (oTarget.IsMember or IsTarget_Friendly(oTarget)) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function GetCount_PartyDeadNear(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	if (User.Dead) then counter := 1;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > maxRange) then continue;
		
		if (oTarget.Dead) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function IsTime_ToHeal: Boolean;
//checked
var
i: Integer;
oTarget: Tl2Char;
begin
	result := False;
	if (GetMinPartyHp < 85) then begin
		result := True;
		Exit;
	end;
	for i:= 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then Continue;
		if (IsTarget_Debuffed_GetState(oTarget) > 0) or (oTarget.Dead) then begin
			result := True;
			Exit;
		end;
	end;
	if (DuoPartyMode) then begin
		if (GetCount_FriendlyBishopsDeadNear_NonParty(900) >= 2) then result := true;
		if (GetCount_FriendsDeadNear(900) >= 1) then result := true;
	end;
end;

function IsTime_ToHeal_Ee: Boolean;
//checked
var
i: Integer;
oTarget: Tl2Char;
begin
	result := False;
	if (GetMinPartyHp < 85) then begin
		result := True;
		Exit;
	end;
	exit; //Dont look at debuffs atm as elven elder
	for i:= 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then Continue;
		if (IsTarget_Debuffed_GetState(oTarget) > 0) or (oTarget.Dead) then begin
			result := True;
			Exit;
		end;
	end;
	if (DuoPartyMode) then begin
		if (GetCount_FriendlyBishopsDeadNear_NonParty(900) >= 2) then result := true;
		if (GetCount_FriendsDeadNear(900) >= 7) then result := true;
	end;
end;

function IsTime_ToBalanceLife: Boolean;
//checked
var
oTarget, oHealer: Tl2Char;
begin
	result := false;
	
	if (GetParty_AverageHp_AliveOnly < 55) then exit;
	
	oTarget := GetTarget_LowestHpAlive_Party;
  
	if not IsTarget_ValidAndVisible_Char(oTarget) then exit;
	
	if (oTarget.HP > 50)
	or (User.DistTo(oTarget) > 900) then Exit;
  
  
	if (User.Name = GetName_Healer1)
	and CharList.ByName(GetName_Healer2, oHealer)
	and IsTarget_ValidAndVisible_Char(oHealer)
	and (IsTarget_GoodState_Party(oHealer, 700))
	and (IsSkillReady_OtherBotChar(1335, oHealer.Name)) then Exit;
	
	result := true;
end;

function IsTime_ToSublime: Boolean;
var
lowMpCount, hpCost, mpCost: Integer;
oHealer: Tl2Char;
otherHealerRez: Tl2Skill;
begin
	result := false;
	hpCost := 8000;
	mpCost := 218;
	if (User.CurHp < hpCost) or (User.CurMp < mpCost) then exit;
	
	//Both bishops should be alive, so ourself and one party bishop
	if (GetCount_PartyBishopsDeadNear(1500) > 0) or User.Dead then exit;
	
	//If any Other Bishop Mana is below 10%
	if IsAnyPartyBishopLowMp_NotMyself(10) then begin
		result := true;
		exit;
	end;
	
	lowMpCount := GetCount_PartyMembers_WithManaLessThan_NonBishops(10);
	if ((lowMpCount > 2) and not PvpLoaded) 
	or ((lowMpCount > 1) and PvpLoaded) then begin
		if ShouldICastSpell_Healers_ByPriority(1505, hpCost, mpCost) and not IsAnyHealer_CastingSpellById(1505) then begin
			result := true;
			exit;	
		end;
	end;
	
end;
(*
function CheckUse_ToSublime_ByUser(control: Tl2Control): Boolean;
var
lowMpCount, hpCost, mpCost: Integer;
oHealer: Tl2Char;
otherHealerRez: Tl2Skill;
begin
	result := false;
	hpCost := 8000;
	mpCost := 218;
	if (control.CurHp < hpCost) or (control.CurMp < mpCost) then exit;
	
	//Both bishops should be alive, so ourself and one party bishop
	if (GetCount_BishopsDeadNear(1500) > 0) or control.Dead then exit;
	
	//If any Other Bishop Mana is below 10%
	if IsAnyPartyBishopLowMp_NotMyself(control, 10) then begin
		result := true;
		exit;
	end;
	
	lowMpCount := GetCount_PartyMembers_WithManaLessThan_NonBishops(10); //No need to alter this, as we never need to check ourself
	if ((lowMpCount > 3) and not PvpLoaded) 
	or ((lowMpCount > 1) and PvpLoaded) then begin
		result := true;
		exit;		
	end;
	
end;*)

function CheckUse_Sublime_Healer1Only(): Boolean;
var
i, lowMpCount, hpCost, mpCost: Integer;
oHealer: Tl2Char;
otherHealerRez: Tl2Skill;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	if not HasIntervalPassed_BySkillId(1505, 10000) then exit;
	if not IsUnderAttack then exit;
	
	hpCost := 8000;
	mpCost := 218;
	
	//All bishops should be alive, so ourself and all party bishops
	if (GetCount_PartyBishopsDeadNear(1500) > 0) or User.Dead then exit;
	
	lowMpCount := GetCount_PartyMembers_WithManaLessThan_NonBishops(10);
	if ((lowMpCount > 3) and not PvpLoaded) 
	or ((lowMpCount > 1) and PvpLoaded) then begin
		UseForMembers := true;
	end else 
		UseForMembers := false;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) then begin
			if IsClass_Bp(controlUser.ClassId) and (HasSkill_Ready(1505, control)) and not IsTarget_Disabled(controlUser) then begin
				if (controlUser.CurHp > hpCost) and (controlUser.CurMp > mpCost) then begin
					
					if (UseForMembers) then begin
						if control.DUseSkill(1505, true, false) then
							SetInterval_OnSkillId(1505, 10000);
						
						result := (control = Engine); //Only return true, if we, ourself, should cast sublime
						exit;
					end;
					
					//If any of the other Bishops Mana is below 10%
					if IsAnyPartyBishopLowMp_NotMyself(control, 10) then begin
						if control.DUseSkill(1505, true, false) then
							SetInterval_OnSkillId(1505, 10000);
							
						result := (control = Engine); //Only return true, if we, ourself, should cast sublime
						exit;
					end;
					
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;


function CheckUse_MassCleanse_Healer1Only(): Boolean;
var
i, lowMpCount, mpCost: Integer;
oHealer: Tl2Char;
otherHealerRez: Tl2Skill;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	if not PvpLoaded then exit;
	if not HasIntervalPassed_BySkillId(1425, 10000) then exit;
	
	mpCost := 80;
	
	//If less than six members has stage 3 (or higher) debuffs, dont use mass cleanse
	if (GetCount_MembersDebuffed_SelfIncluded_AliveOnly(3) < 6) then exit;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) then begin
		
			if IsClass_Bp(controlUser.ClassId) 
			and (HasSkill_Ready(1425, control)) 
			and (HasItem_MinCount(control, 8876, 1)) 
			and not IsTarget_Disabled(controlUser) then begin
			
				if (controlUser.CurMp > mpCost) then begin
					if control.DUseSkill(1425, true, false) then
						SetInterval_OnSkillId(1425, 10000);
							
					result := (control = Engine); //Only return true, if we, ourself, should cast mass cleanse
					exit;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;



function CheckUse_Miracle_Healer1Only(): Boolean;
var
i, lowMpCount, mpCost: Integer;
oHealer: Tl2Char;
otherHealerRez: Tl2Skill;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	if not PvpLoaded then exit;
	if not HasIntervalPassed_BySkillId(1426, 10000) then exit;
	
	mpCost := 80;
	
	//If less than 5 members has (less than 30% hp and doesnt have Seal of Limit Buff), dont use Miracle (clan 100% heal skill)
	if (GetCount_PartyMembers_WithHpLessThan_Alive_NoSealLimit(30) < 5) then exit;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) then begin
		
			if IsClass_Bp(controlUser.ClassId) 
			and (HasSkill_Ready(1426, control)) 
			and (HasItem_MinCount(control, 8876, 1)) 
			and not IsTarget_Disabled(controlUser) then begin
			
				if (controlUser.CurMp > mpCost) then begin
					if control.DUseSkill(1426, true, false) then
						SetInterval_OnSkillId(1426, 10000);
							
					result := (control = Engine); //Only return true, if we, ourself, should cast Miracle
					exit;
				end;
				
			end;
			
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;


function GetCount_MembersDebuffed_SelfIncluded_AliveOnly(minDebuffState: Integer): Integer;
var
count, i: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	count := 0;
	if (IsTarget_Debuffed_GetState(User) >= minDebuffState) then count := 1;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.name = '') or (oTarget.Dead) or (User.DistTo(oTarget) > MAX_RANGE_FRIEND) then continue;
		if (IsTarget_Debuffed_GetState(oTarget) >= minDebuffState) then Inc(count);
 	end;
	result := count;
end;

function IsAnyPartyBishopLowMp_NotMyself(maxMp : Integer): Boolean; overload;
var
i : Integer;
oTarget: Tl2Char;
begin
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		if (not IsClass_Bp(oTarget.ClassId)) 
		or (oTarget.Mp > maxMp) 
		or (oTarget.Dead) then continue;
		
		if (User.DistTo(oTarget) < 1000) then begin
			result := true;
			exit;
		end;
	end;
end;

function IsAnyPartyBishopLowMp_NotMyself(myControl: Tl2Control; maxMp : Integer): Boolean; overload;
var
i : Integer;
oTarget: Tl2Char;
myParty: TParty;
begin
	myParty := myControl.GetParty();
	for i := 0 to myParty.Chars.Count - 1 do begin
		oTarget := myParty.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		if (not IsClass_Bp(oTarget.ClassId)) 
		or (oTarget.Mp > maxMp) 
		or (oTarget.Dead) then continue;
		
		if (User.DistTo(oTarget) < 1000) then begin
			result := true;
			exit;
		end;
	end;
end;

function GetCount_PartyMembers_WithManaLessThan_NonBishops(maxMp: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	
	if (User.Mp < maxMp) then counter := 1
	else counter := 0;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (User.DistTo(oTarget) > MAX_RANGE_FRIEND) or (oTarget.Dead) then continue;
		if (IsClass_Bp(oTarget.ClassId)) then continue;
		
		if (oTarget.MP < maxMp) then Inc(counter);
	end;
	
	result := counter;
end;

function GetCount_PartyMembers_WithHpLessThan_Alive_NoSealLimit(maxHp: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
oBuff: Tl2Buff;
begin
	result := 0;
	
	if (User.Hp < maxHp) and not (User.Dead) then counter := 1
	else counter := 0;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (User.DistTo(oTarget) > MAX_RANGE_FRIEND) or (oTarget.Dead) then continue;
		
		if (oTarget.HP < maxHp) then begin
			if not oTarget.Buffs.ById(1509, oBuff) then //Only targets without Seal of Limit, so we can actually heal them
				Inc(counter);
		end;
	end;
	
	result := counter;
end;

function GetOtherPartyHealer_DuoBishOnly: Tl2Char;
var
oHealer: Tl2Char;
begin
	result := User;
	
	if (User.Name = GetName_Healer1) then begin
		if (Party.Chars.ByName(GetName_Healer2, oHealer)) then begin
			if not (oHealer = nil) and oHealer.Valid then begin
				result := oHealer;
			end;
		end;
	
	end else if (User.Name = GetName_Healer2) then begin
		if (Party.Chars.ByName(GetName_Healer1, oHealer)) then begin
			if not (oHealer = nil) and oHealer.Valid then begin
				result := oHealer;
			end;
		end;
	end;
end;

function GetParty_AverageHp_AliveOnly: Integer;
var
i, counter, CurHp, TotalHp: Integer;
oTarget: Tl2Char;
begin
	result := 100;
	TotalHp := 0;
	counter := 1;
	for i := 0 to Party.Chars.Count - 1 do begin
	
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then Continue;
		if (oTarget = nil) then Continue;   
		if (oTarget.Dead) or (User.DistTo(oTarget) > MAX_RANGE) then continue;  
		
		TotalHp := TotalHp + oTarget.Hp;
		Inc(counter);
	end;
	
	if (counter < 1) then exit;
	result := Round(TotalHp / counter);
end;



function GetParty_AverageHp_DeadIncluded: Integer;
var
i, counter, CurHp, TotalHp: Integer;
oTarget: Tl2Char;
begin
	result := 100;
	TotalHp := 0;
	counter := 1;
	for i := 0 to Party.Chars.Count - 1 do begin
	
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then Continue;
		if (oTarget = nil) then Continue;   
		if (User.DistTo(oTarget) > MAX_RANGE) then continue;  
		
		if not (oTarget.Dead) then
			TotalHp := TotalHp + oTarget.Hp;
			
		Inc(counter);
	end;
	
	if (counter < 1) then exit;
	result := Round(TotalHp / counter);
end;

function IsTime_ToPartyUd_Pve: Boolean;
var
i, DeadCount : Integer;
oTarget: Tl2Char;
begin
	result := false;
	
	DeadCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Dead)
		and (User.DistTo(oTarget) <= 900) then Inc(DeadCount);
	end;
	
	if (GetParty_AverageHp_AliveOnly < 55) 
	and (DeadCount < 4)
	and (GetCount_PartyBishopsAlive >= 1) then begin
		result := true;
	end;
end;

function IsTime_ToPartyUd_Pvp: Boolean;
var
i, DeadCount : Integer;
oTarget: Tl2Char;
begin
	result := false;
	
	DeadCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Dead)
		and (User.DistTo(oTarget) <= 900) then Inc(DeadCount);
	end;
	
	if (GetParty_AverageHp_AliveOnly < 70) 
	and (DeadCount < 4)
	and (GetCount_PartyBishopsAlive >= 1) then begin
		result := true;
	end;
end;

function GetCount_PartyBishopsAlive: Integer;
var
i, count: Integer;
oTarget: Tl2Char;
begin
	count := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Dead) or not (IsClass_Bp(oTarget.ClassId))then continue;
		if (User.DistTo(oTarget) > 900) then break;
		Inc(count);
	end;
	result := count;
end;

function IsTime_ToMassRez: Boolean;
var
i, DeadCount, MinDeadCount : Integer;
oTarget, heal1, heal2, oHealer: Tl2Char;
castForDuoParty: Boolean;
begin
	result := false;
	castForDuoParty := false;
	
	MinDeadCount := 4;
  
	if (CharList.ByName(GetName_Healer1, heal1) and IsTarget_ValidAndVisible_Char(heal1) and IsTarget_GoodState_Party(heal1, 900)) 
	or (CharList.ByName(GetName_Healer2, heal2) and IsTarget_ValidAndVisible_Char(heal2) and IsTarget_GoodState_Party(heal2, 900)) then begin
		MinDeadCount := 4;
	end else begin
		MinDeadCount := 5;
	end;
	DeadCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Dead)
		and (User.DistTo(oTarget) <= 900) then Inc(DeadCount);
	end;
	
	if DuoPartyMode 
	and ((GetCount_FriendlyBishopsDeadNear_NonParty(900) >= 2) or (GetCount_FriendsDeadNear(900) >= 7)) then castForDuoParty := true;
	
	if (DeadCount < MinDeadCount) and not (castForDuoParty) then exit;
	
	if not ShouldICastSpell_Healers_ByPriority(1254) then exit;

	if IsAnyHealer_CastingSpellById(1254) then exit;
	
	result := true;
end;

function IsTime_ToMajorGroupHeal: Boolean;
var
i, MinInjuredPartyCount, InjuredCount : Integer;
oTarget, heal1, heal2, oHealer: Tl2Char;
condition1, condition2: Boolean;
begin
	result := false;
	oHealer := user;
	
	condition1 := false;
	condition2 := false;
	
	MinInjuredPartyCount := 4;
	
	InjuredCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Hp < 87)
		and not (oTarget.Dead)
		and (User.DistTo(oTarget) <= 900) then Inc(InjuredCount);
	end;
	if (InjuredCount > 4) then begin
		condition1 := true;
	end;
	
  
	InjuredCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Hp < 85)
		and not (oTarget.Dead)
		and not (IsFriend_Invincible(oTarget))
		and (User.DistTo(oTarget) <= 900) then Inc(InjuredCount);
	end;
	
	if (InjuredCount >= MinInjuredPartyCount) then condition2 := true;
	
	
	if not ShouldICastSpell_Healers_ByPriority(1402) then Exit;	
		
	if IsAnyHealer_CastingSpellById(1402) then begin
		Exit;
	end;
		
		
	result := condition1 or condition2;
end;
function ShouldIAgro: Boolean;
var
oTank: Tl2Char;
begin
	result := true;
	if (User.Name = GetName_Sws) 
	and (CharList.ByName(GetName_Bd, oTank))
	and (IsTarget_GoodState_Party(oTank, 600))
	and (IsSkillReady_OtherBotChar(28, oTank.Name)) then result := false; //Aggresion
	
	if not HasSkill_Ready(28) then result := false;
end;

function GetTarget_MainAssist: Tl2Char;
var
i, partyNum: Integer;
oTarget: Tl2Char;
CharName: string;
MainAssistNameList: array of string;
begin  
	
	result := User;
	partyNum := GetPartyNum;
	if (partyNum = 1) then begin
		//Print('Find MA: 1st party');
		SetLength(MainAssistNameList, 6);
		MainAssistNameList[0] := 'iComet';
		MainAssistNameList[1] := 'Chaos';
		MainAssistNameList[2] := 'Reinn';
		MainAssistNameList[3] := 'NewEra';
		MainAssistNameList[4] := 'Spiker';
		MainAssistNameList[5] := 'Tallenlore';
	end else if (partyNum = 2) then begin
		//Print('Find MA: 2nd party');
		SetLength(MainAssistNameList, 6);
		MainAssistNameList[0] := 'Undisputed';
		MainAssistNameList[1] := 'Insanity';
		MainAssistNameList[2] := 'iFury';
		MainAssistNameList[3] := 'Nastmine';
		MainAssistNameList[4] := 'Eviscerator';
		MainAssistNameList[5] := 'Tranquility';
	end else begin
		//Print('Find MA: 3rd party');
		SetLength(MainAssistNameList, 6);
		MainAssistNameList[0] := 'iNuke';
		MainAssistNameList[1] := 'iSky';
		MainAssistNameList[2] := 'Immortality';
		MainAssistNameList[3] := 'iPain';
		MainAssistNameList[4] := 'Ragnator';
		MainAssistNameList[5] := 'iPole';
	end;
	for i := 0 to Length(MainAssistNameList) - 1 do begin
		CharName := MainAssistNameList[i];
		//print('Check main assist by name: ' + CharName);
		if (CharName = User.Name) 
		and not (IsTarget_Disabled(user)) then begin
			result := user;
			Exit;
		end;
		
		//CharList.ByName(CharName, oTarget);
		if (Party.Chars.ByName(CharName, oTarget))
		and not (oTarget = nil)
		and (User.DistTo(oTarget) < MAX_ASSIST_RANGE_PVP) 
		and not (IsMainAssistDisabled(oTarget)) then begin
			result := oTarget;
			Exit;
		end;
	end;
end;

function SetTarget_MainAssist: Boolean;
var
ma: Tl2Char;
oLiveTarget: Tl2Live;
begin
	result := false;
	
	ma := GetTarget_MainAssist;
	if (ma = nil) or (ma = user) then begin
		//if (ma = User) then print('I am main assist!')
		//else Print('Main assist not found!');
		exit;
	end;// else print('Main assist found: ' + ma.Name);
	
	oLiveTarget := ma.Target;
	if (oLiveTarget = nil) then begin 
		//Print('Main assist does NOT have a target!');
		exit;
	end;
	if (PvpLoaded) then begin
		if not IsTarget_Valid_CharAsLive(oLiveTarget) then begin
			print('Pvp Assist: Main assist''s target is not valid. target = ' + oLiveTarget.Name);
			exit;
		end;
		if not (User.Target = oLiveTarget) then begin
			Engine.CancelTarget();
			Engine.SetTarget(oLiveTarget);
			Print('Pvp Assist: Assist ' + ma.Name + ' - target -> ' + oLiveTarget.Name);
		end;
		result := true;
	end else begin
		if not IsTarget_Valid_Live(oLiveTarget) then begin
			//print('Main assist''s target is not valid!');
			exit;
		end;
		if not (User.Target = oLiveTarget) then begin
			Engine.CancelTarget();
			Engine.SetTarget(oLiveTarget);
		end;
		//Print('Assist target found: ' + oLiveTarget.Name);
		result := true;
	end;
end;

function IsMainAssistDisabled(oMainAssist: Tl2Char): Boolean;
var
i: Integer;
oTargetsTarget, tempLive: Tl2Live;
oTarget: Tl2Char;
begin
	result := true;
	if not IsTarget_ValidAndVisible_Char(oMainAssist) then exit;
	if (IsTarget_Disabled(oMainAssist)) then exit;
	
	oTargetsTarget := oMainAssist.Target;
	if (oTargetsTarget = nil) then exit;
  
  
	if PvpLoaded and (CharList.ByName(oTargetsTarget.Name, oTarget)) then begin
		if (IsTarget_Friendly(oTarget))
		or (User.DistTo(oMainAssist) > MAX_ASSIST_RANGE_PVP) 
		or (IsClass_Tank(oTarget.ClassId) and not (IsOnlyTanksLeft)) then begin
			result := true;
			exit;
		end;
	end else begin
		if (not allowEmptyStringMobNames) and not (NpcList.ByName(oTargetsTarget.Name, tempLive)) then begin
			result := true;
			exit;
		end;
	end;
	result := false;
end;


function IsOnlyTanksLeft: Boolean;
//checked
var
i: Integer;
oTarget: Tl2Char;
begin
	result := true;
	for i := 0 to CharList.Count -1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) then begin
			WriteError('IsOnlyTanksLeft: oTarget = nil');
			Continue;
		end;
		if (IsTarget_Valid_Char(oTarget)) then begin
			if not (IsClass_Tank(oTarget.ClassID)) then begin
				result := false;
				exit;
			end;
		end;
	end;
end;

function IsOtherPlayersNearby(minRange: Integer): Boolean;
var
i: Integer;
oTarget: Tl2Char;
begin
	result := false;
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		if not (oTarget.IsMember)
		and (User.DistTo(oTarget) < minRange) then begin
			result := true;
			Exit;
		end;
	end;


end;






function SetPoint_PartyCenter: void;
var
EndX, EndY, i, z, nCounter: Integer;
oTarget, obj, oLeader: Tl2Char;
begin
	PT_PX := User.X;
	PT_PY := User.Y;
	PARTY_PT_DIST := 0;
	
	nCounter := 1; //(1 because, we add Users location at start)
	EndX := User.X;
	EndY := User.Y;
	if not (DuoPartyMode) then begin
		for i := 0 to Party.Chars.Count - 1 do begin
			oTarget := Party.Chars.Items(i);
			if not IsTarget_ValidAndVisible_Char(oTarget) then begin
				continue;
			end;
			if (User.DistTo(oTarget) > MAX_RANGE_FRIEND) then break;
		
			EndX := EndX + oTarget.X;
			EndY := EndY + oTarget.Y;
			Inc(nCounter);
		end;
	end else begin
		for i := 0 to CharList.Count - 1 do begin
			oTarget := CharList.Items(i);
			if not IsTarget_ValidAndVisible_Char(oTarget) then begin
				continue;
			end;
			if (User.DistTo(oTarget) > MAX_RANGE_FRIEND) then break;
			
			if not (IsTarget_Friendly(oTarget)) then continue;
		
			EndX := EndX + oTarget.X;
			EndY := EndY + oTarget.Y;
			Inc(nCounter);
		end;
	end;
	
	if (nCounter >= 2) then begin
		EndX := EndX div nCounter;
		EndY := EndY div nCounter;
		PT_PX := EndX;
		PT_PY := EndY;
	end else begin
		if (CharList.ByName(GetName_LocalLeader, oLeader)) 
		and (User.DistTo(oLeader) < MAX_RANGE_FRIEND) then begin
			if (oLeader = nil) then WriteError('GetPartyCenterPoint: oLeader = nil');
			PT_PX := oLeader.X;
			PT_PY := oLeader.Y;
		end else begin
			PT_PX := user.X;
			PT_PY := user.y;
		end;
	end;
	z := User.z;
	PARTY_PT_DIST := User.DistTo(PT_PX, PT_PY, z);
end;

function ObjectDistTo_PartyCenter(obj: Tl2Spawn): Cardinal;
var
x, y: Integer;
begin
	result := 1000000;
	if (obj = nil) or ((obj.x = 0) and (obj.y = 0)) then exit;
	x := obj.x;
	y := obj.y;
	result := GetDistanceBetweenPoints(PT_PX, PT_PY, x, y);
end;

function GetPath_CharSettings: string;
begin
	result := Script.Path + 'Adrenalin Char Settings\\';
end;

function GetPath_FileSettings: string;
begin
	result := Script.Path + 'Adrenalin Folder Files\\';
end;
function GetPath_ZoneFolder: string;
begin
	result := Script.Path + 'Adrenalin Folder Files\\Settings\\';
end;

function cLoadZone(zoneName: string): Boolean;
begin
	result := Engine.LoadZone(GetPath_ZoneFolder + zoneName);
end;
function cLoadConfig(configName: string): Boolean;
begin
	result := Engine.LoadConfig(GetPath_CharSettings + configName);
end;

function GetName_Leader: string;
var
sName: string;
begin
	result := '';
	if (SettingList = nil) then Exit;
	sName := GetRowStrValueBelow('Leader:', SettingList);
	result := sName;
end;

function GetName_CoLeader: string;
var
sName: string;
begin
	result := '';
	if (SettingList = nil) then Exit;
	sName := GetRowStrValueBelow('CoLeader:', SettingList);
	result := sName;
end;

function GetName_SecondLeader: string;
var
sName: string;
begin
	result := '';
	if (SettingList = nil) then Exit;
	sName := GetRowStrValueBelow('SecondLeader:', SettingList);
	result := sName;
end;

function GetName_LocalLeader: string;
begin
	result := '';
	if (DuoPartyMode) then 
		result := GetName_Leader
	else if (GetPartyNum = 2) then 
		result := GetName_SecondLeader
	else
		result := GetName_Leader;
end;

function GetName_Server: string;
var
sName: string;
begin
	result := '';
	if (SettingList = nil) then Exit;
	sName := GetRowStrValueBelow('ServerName:', SettingList);
	result := sName;
end;


function GetName_Sws: string;
var
sName: string;
begin
	result := 'Elreolas';
end;
function GetName_Bd: string;
var
sName: string;
begin
	result := 'Unexpected';
end;
function GetName_Ee: string;
var
sName: string;
begin
	result := 'noSheyrena';
end;

function GetPartyNum: Integer;
var
oLeader: Tl2Char;
sLead1, sLead2: string;
begin
	result := 1;
	sLead1 := GetName_Leader;
	sLead2 := GetName_SecondLeader;
	
	if (User.Name = sLead1) then begin
		result := 1;
		exit;
	end else if (User.Name = sLead2) then begin
		result := 2;
		exit;
	end;
	
	
	if (Party.Chars.Count > 0) then begin
		if Party.Chars.ByName(sLead1, oLeader) then begin
			result := 1;
			exit;
		end else if (Party.Chars.ByName(sLead2, oLeader)) then begin
			result := 2;
			exit;
		end;		
	end;	
end;

function GetName_OtherHealer: string;
var
n1, n2, ownName: string;
begin
	result := '';
	n1 := GetName_Healer1;
	n2 := GetName_Healer2;
	ownName := User.Name;
	if (ownName = n1) then result := n2
	else if (ownName = n2) then result := n1;
end;

function GetName_Healer1: string;
var
sName: string;
partyNum: Integer;
begin
	result := '';
	if (SettingList = nil) then Exit;
	partyNum := GetPartyNum;
	if (partyNum = 1) then
		sName := GetRowStrValueBelow('Bishop_1:', SettingList)
	else if (partyNum = 2) then
		sName := GetRowStrValueBelow('Bishop_4:', SettingList)
	else if (partyNum = 3) then
		sName := GetRowStrValueBelow('Bishop_7:', SettingList);
		
	result := sName;
end;
function GetName_Healer2: string;
var
sName: string;
partyNum: Integer;
begin
	result := '';
	if (SettingList = nil) then Exit;
	partyNum := GetPartyNum;
	if (partyNum = 1) then
		sName := GetRowStrValueBelow('Bishop_2:', SettingList)
	else if (partyNum = 2) then
		sName := GetRowStrValueBelow('Bishop_5:', SettingList)
	else if (partyNum = 3) then
		sName := GetRowStrValueBelow('Bishop_8:', SettingList);
		
	result := sName;
end;
function GetName_Healer3: string;
var
sName: string;
partyNum: Integer;
begin
	result := '';
	if (SettingList = nil) then Exit;
	partyNum := GetPartyNum;
	if (partyNum = 1) then
		sName := GetRowStrValueBelow('Bishop_3:', SettingList)
	else if (partyNum = 2) then
		sName := GetRowStrValueBelow('Bishop_6:', SettingList)
	else if (partyNum = 3) then
		sName := GetRowStrValueBelow('Bishop_9:', SettingList);
		
	result := sName;
end;


function GetTarget_ToFollow(): Tl2Char;
var
oTargetToFollow: Tl2Char;
begin
	result := User;
	if (User.Name = GetName_LocalLeader) then exit;
	if CharList.ByName(GetName_LocalLeader, oTargetToFollow) and (User.DistTo(oTargetToFollow) < 7000) then begin
		result := oTargetToFollow;		
	end else if CharList.ByName(Party.Leader.Name, oTargetToFollow) and (User.DistTo(oTargetToFollow) < 7000) then begin
		result := oTargetToFollow;	
	end;
end;

function GetRowIntValueBelow(SearchString: string; SettingList: TStringList): Integer;
begin
  if (SettingList = nil) then WriteError('GetRowIntValueBelow: SettingList = nil');
  result := StrToInt(SettingList[((SettingList.IndexOf(SearchString)) + 1)]);
end;
function GetRowStrValueBelow(SearchString: string; SettingList: TStringList): string;
begin
  if (SettingList = nil) then WriteError('GetRowStrValueBelow: SettingList = nil');
  result := SettingList[((SettingList.IndexOf(SearchString)) + 1)];
end;
function GetRowBoolValueBelow(SearchString: string; SettingList: TStringList): Boolean;
var
TrueFalse: string;
begin
  if (SearchString = null) then WriteError('GetRowBoolValueBelow: SearchString = nil');
  if (SettingList = nil) then WriteError('GetRowBoolValueBelow: SettingList = nil');
  TrueFalse := SettingList[((SettingList.IndexOf(SearchString)) + 1)];
  if (TrueFalse = 'true') then
    result := true
  else 
    result := false;
end;




function GetCount_DeadPartyWithinRange(nMaxRange: Integer): Integer;
var
i, DeadCount : Integer;
oTarget, cchar: Tl2Char;
begin
result := 0;
  DeadCount := 0;
  for i := 0 to Party.Chars.Count -1 do begin
    oTarget := Party.Chars.Items(i);
	if IsTarget_ValidAndVisible_Char(oTarget) then continue;
    if (oTarget.Dead)
    and (User.DistTo(oTarget) < nMaxRange) then Inc(DeadCount);
  end;
  result := DeadCount;
end;


function CheckMove_DeadParty_LeaderOnly: Boolean;
var
deadMember : Tl2Char;
TempX, TempY: Integer;
begin
	result := false;
	
	if not (User.Name = GetName_LocalLeader) then exit;
	
	//If we are not under attack:	
	if (GetCount_DeadPartyWithinRange(1500) > 0) then begin
		deadMember := GetTarget_NearestDead_Party(1500);
		if not IsTarget_ValidAndVisible_Char(deadMember) then Exit;
		if (User.DistTo(deadMember) > 150)
		and not (deadMember = User) then begin
			TempX := deadMember.X;
			TempY := deadMember.Y;
			if (deadMember.InZone) then begin
				if not (User.InZone) then begin
					MoveTo_BackToZone;
				end;
				if (User.InZone) then begin
					result := MapMove(TempX, TempY);
				end else begin
				
					//	if user is not in zone
					MoveTo_Timer(TempX, TempY, 0);
					result := true;
				end;
			end else begin
			
				//  if deadMember is not in zone
				MoveTo_Timer(TempX, TempY, 0);
				result := true;
			end;
		end;
	end;
end;



function MapMove(X, Y: Integer): boolean;
var
 i, j, stepX,stepY, nCurrentX, nCurrentY, nCurrentZ, z, TempX, TempY, count: integer;
 oItem : Tl2Item;
 WasBotOn: Boolean;
begin
	result := false; 

	if (User.Dead) then Exit;

	if not (user.inzone) then 
		MoveTo_BackToZone;
		
	
	
	if not (User.InZone) then Begin
		Print('MapMove_: Could not find out way back into farming zone, exit!');
		Exit;
	end;
	
	count := curPath.Count; 
	
	//  If path is not yet created, 
	if (count <= 0) or (curPath = nil) then begin
		curPath := TList.Create;
		TempX := User.x; 
		TempY := User.Y;
		Engine.FindPath(TempX, TempY, X, Y, curPath);
		curPathStep := 0;
	end;
	
	//	Check for old unfinished path.
	//	If last step is not near our destination, create new path
	if (count >= 2) then begin
		stepX := integer(curPath[count - 2]);
		stepY := integer(curPath[count - 1]);
		if (abs(stepX - X) > 75) and (abs(stepY - Y) > 75) then begin
			curPath.Free;
			curPath := TList.Create;
			TempX := User.x; 
			TempY := User.Y;
			Engine.FindPath(TempX, TempY, X, Y, curPath);
			curPathStep := 0;
		end;
	end;
	  
	
	//  At this point, path is created, so move
	
	//  Are we done?
	z := User.Z;
	if (user.InRange(X, Y, z, 100)) or (curPathStep > (count div 2) - 1)   then begin
		result := true;
		curPath.Free;
		curPath := TList.Create;
		curPathStep := 0;
		Exit;
	
	end else begin
		//	If we are not yet done, pick up where we left off
		stepX := integer(curPath[curPathStep*2]);
		stepY := integer(curPath[(curPathStep*2)+1]);
		TempX := User.x; 
		TempY := User.Y;
		
		//	Step Completed?
		if (abs(TempX - stepX) < 40) and (abs(TempY - stepY) < 40) then begin
			Inc(curPathStep);
			Exit;
		
		//	If step is not complete, move to end of step!
		end else begin
			LockCheck_MoveAndBot_Off;
			Engine.CancelTarget;
			MoveTo_Timer(stepX, stepY, 0);
			Delay(1250);
			LockCheck_MoveAndBot_On;		
		end;
		
	end;
end;

function MoveTo_BackToZone: Boolean;
//checked
var
i, j, x, y, z, nRadius, nAngle, TempX, TempY: Integer;
begin
	result := false;
	x := 0;
	y := 0;
	z := User.z;
	if not (user.inzone) then begin
		for i:= 0 to 300 do begin
			for j := 0 to 72 do begin
				//Minimum range = 75
				nRadius := 75 + (5 * i);  //Start looking for a point at range = 75 distance away, and go up
				nAngle := 5*j; //Increase angle by 5 for every iteration
				TempX := User.X;
				TempY := User.Y;
				x := GetX_OnCircle(nRadius, TempX, nAngle);
				y := GetY_OnCircle(nRadius, TempY, nAngle);
				if (Engine.InZone(x, y, z)) then
					break;
			end;
			if (Engine.InZone(x, y, z)) then
				break;
		end;  
		if (Engine.InZone(x, y, z)) then begin
			MoveTo_Timer(x, y, z);
			Delay(600);
			MoveTo_Timer(x, y, z);
			Delay(600);
			result := true;
		end;
	end else begin
		result := true;
	end;
end;


function MoveToTarget_Timeout_Live(oTarget: Tl2Live; rangeToTarget, nTimeOut: Integer): Boolean;
var
movePoint: TPoint;
nTime, x1, x2, y1, y2, z: Integer;
begin
	result := false;
	if (oTarget = nil) or not oTarget.Valid then exit;
	
	nTime := 0;
	x1 := oTarget.X;
	y1 := oTarget.Y;
	x2 := User.X;
	y2 := User.Y;
	// negate rangeToTarget, so we get a point in front of target, instead of behind
	movePoint := GetPointBehindTargetFromTarget(x1, y1, x2, y2, -rangeToTarget);
	while true do begin
	
		if (oTarget = nil) then exit;
		if (User.DistTo(oTarget) <= rangeToTarget) 
		or (oTarget.Dead)
		or (nTime > nTimeOut) then break;
		
		z := oTarget.Z;
		MoveTo_Timer(movePoint.X, movePoint.Y, z);
		
		Delay(300);
		nTime := nTime + 300;
	end;
	result := (not (oTarget = nil)) and (User.DistTo(oTarget) <= rangeToTarget);
end;

function MoveTo_TimeOut(x, y, z, nMaxTime: Integer): Boolean;
var
nIterations, i: Integer;
begin
	result := false;
	if (nMaxTime < 200) then nMaxTime := 200;
	nIterations := Round(nMaxTime / 200);
	
	for i := 1 to nIterations do begin
		MoveTo_Timer(x, y, z);
		if (User.InRange(x, y, z, 25)) then begin
			result := true;
			exit;
		end;
		Delay(200);		
	end;	
end;

function IsUnderAttack: Boolean;
var
i, maxRange: Integer;
oTarget, oTargetsTarget: Tl2Live;
debug: Boolean;
begin
	debug := false;

	result := false;
	if (PvpLoaded = null) then WriteError('IsUnderAttack: PvpLoaded = null');
	if PvpLoaded then begin
		result := true;
		//if debug then Print('UnderAttack: We are in pvp - return true');
		Exit;
	end;
	//if (GetMinPartyHp < 76) and (Party.Chars.Count > 0) and GetIsSomeMemberInCombat then result := true;
	
	
	
	if (isJava) then begin
		if (Party.Chars.Count < 2) then maxRange := 900
		else maxRange := MAX_RANGE_NPC_ATTACKING;
		
		for i := 0 to NpcList.Count -1 do begin
			oTarget := NpcList.Items(i);
			if (oTarget = nil) then begin
				//if debug then Print('IsUnderAttack: oTarget = nil');
				Continue;
			end;
			
			//if debug then begin
				//Print('UnderAttack: ' + oTarget.Name + ' is valid = ' + BoolToStr(IsTarget_Valid_Live(oTarget)));
				//Print('UnderAttack: ' + oTarget.Name + ' is in combat = ' + BoolToStr(oTarget.InCombat));
				//Print('UnderAttack: ' + oTarget.Name + ' is on us = ' + BoolToStr(IsTarget_OnUs_Live(oTarget)));
			//end;
			if (User.DistTo(oTarget) > maxRange) then break;
			if IsTarget_Valid_Live(oTarget)
			//and (oTarget.InCombat)
			and IsTarget_OnUs_Live(oTarget) then begin
				result := true;
				Exit;
			end;
		end;
	end else begin
		for i := 0 to NpcList.Count -1 do begin
			oTarget := NpcList.Items(i);
			if (oTarget = nil) then begin
				Continue;
			end;
			oTargetsTarget := oTarget.Target;
			if (User.DistTo(oTarget) > MAX_RANGE_NPC_ATTACKING) then break;
			if ((oTargetsTarget.IsMember or (DuoPartyMode and (IsTarget_Friendly(oTargetsTarget))))
			or (oTargetsTarget = User))
			and IsTarget_Valid_Live(oTarget) then begin
				result := true;
				Exit;
			end;
		end;		
	end;
	if (result = null) then WriteError('IsUnderAttack: result = nil');
end;

function BoolToStr(statement: Boolean): string;
begin
	if (statement) then result := 'True'
	else result := 'False';
end;

function GetIsSomeMemberInCombat: Boolean;
var
i: Integer;
oTarget: Tl2Char;
begin
	result := false;
	if (User.InCombat) then begin
		result := true;
		exit;	
	end;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (not oTarget.Valid) or (oTarget.Name = '') then continue;
		if (User.DistTo(oTarget) > MAX_RANGE_FRIEND) then continue;
		if (oTarget.InCombat) then begin
			result := true;
			exit;
		end;
	end;
end;


function GetMinPartyHp: Integer;
//checked
var
i, nLastHp, nCurHp: Integer;
oTarget, cchar: Tl2Char;
begin 
  nLastHp := User.hp;
  for i := 0 to Party.Chars.Count -1 do begin
    oTarget := Party.Chars.Items(i);
	if (oTarget = nil) or (not (CharList.ByName(oTarget.Name, cchar))) then Continue;
	if(User.DistTo(oTarget) > 2000) then continue;
    nCurHp := oTarget.Hp;
	if (nCurHp < nLastHp) then nLastHp := nCurHp;
  end;
  result := nLastHp;
end;



function GetMinPartyMp: Integer;
//checked
var
i, nLastMp, nCurMp: Integer;
oTarget, cchar: Tl2Char;
begin
  nLastMp := User.Mp;
  for i := 0 to Party.Chars.Count -1 do begin
    oTarget := Party.Chars.Items(i);
	if (oTarget = nil) or (not (CharList.ByName(oTarget.Name, cchar))) then Continue;
	if(User.DistTo(oTarget) > 2000) then continue;
    nCurMp := oTarget.Mp;
	if (nCurMp < nLastMp) then nLastMp := nCurMp;
  end;
  result := nLastMp;
end;

function CheckFindNewMob: Boolean;
var
oTarget: Tl2Live;
x, y, z: Integer;
begin
	result := false;
	
	if (GetPartyNum = 2) then exit;
	
	if (ManaMattersMode and (GetMinPartyMp < 79)) then exit;
	
	if not (IsUnderAttack)
	and (GetMinPartyHp > 75) 
	and not (IsAnyoneMissingBuffs_Apocalyps) then begin
		oTarget := GetTarget_NearestInZone_Pve();
		if (oTarget = nil) then exit;
		x := oTarget.X; y := oTarget.Y; z := oTarget.Z;
		result := MoveTo_Timer(x, y, z);
		Delay(500);
	end;
end;



function WriteError(ErrorMessage : string): void;
var
ErrorStringList: TStringList;
StandardText, sFileName : string;
begin
	exit;
	if (ErrorMessage = '') then begin
		ErrorMessage := 'Empty string';
	end;
  sFileName := 'Fp_ErrorLog_' + User.Name + '.txt';
  ErrorStringList := TStringList.Create;
  
  if (fileexists(sFileName)) then
	ErrorStringList.LoadFromFile(sFileName);  
  
  
  
  StandardText := DateTimeToStr(now) + ' - ' + User.Name;
  
  ErrorStringList.Add(StandardText + ' - ' + ErrorMessage);
  Print(StandardText + ' - ' + ErrorMessage);
  ErrorStringList.SaveToFile(sFileName);
  
  ErrorStringList.Free();
end;








function GetKeyState(nVirtKey: integer): byte; stdcall;
external 'user32.dll' name 'GetKeyState' ;

function KeyDown(K : byte) : Boolean;
begin
	Result := (K = 128) or (K = 129)
end;

function SHIFT : boolean;
begin
	Result := KeyDown(GetKeyState($10));
end;

function CTRL : boolean;
begin
	Result := KeyDown(GetKeyState($11));
end;

function ALT : boolean;
begin
	Result := KeyDown(GetKeyState($12));
end;

function bHALF : boolean;
begin
	Result := KeyDown(GetKeyState($DC));
end;


function cEnterText(msg: string): Boolean;
begin
	while ALT do delay(150);
	result := Engine.EnterText(msg);
end;

procedure Anti_EventPopup;
var
counter: Integer;
sMessage, lastMessage: string;
player: Tl2Char;
begin
	Print('Anti Event Popup - Started.');
	counter := 0;
	lastMessage := '';
	while true do begin
		sMessage := Engine.ConfirmDlg.Sender;
		if not (CharList.ByName(sMessage, player)) then begin
			if (not (lastMessage = sMessage)) then begin
				lastMessage := sMessage;
				Print('Popup message changed: ' + sMessage);
				Delay(500);
				while (alt) do delay(20);
				Engine.UseKey('Enter');
			end;
		end;
		if ((counter mod 200) = 1) then begin
			while (alt) do delay(20);
			Engine.UseKey('Enter');
			Print('Popup message changed: ' + sMessage);
		end;
		Delay(3000);
		Inc(counter);
	end;
end;

function IsSpoilCorpseNear: Boolean;
var
i: Integer;
begin
  result := false;
  for i := 0 to NpcList.Count - 1 do begin
    if (User.DistTo(NpcList.Items(i)) > 300 ) then break;
    if (NpcList.Items(i).Dead)
    and (NpcList.Items(i).Sweepable) then begin
      result := true;
      Exit;
    end;
  end;

end;


function CheckSweep: boolean;
begin
	result := false;
    if (IsSpoilCorpseNear) then begin
		Engine.UseSkill(444);
		result := true;
    end;
end;



function GetOutOfCombat: void;
var
counter : Integer;
begin
	if not (IsUnderAttack) then begin
		Engine.FaceControl(0, False);
		Exit;
	end;
	counter := 0;
	while (User.InCombat) and not (User.Dead) do begin
		while (IsUnderAttack) and not (User.Dead) do begin
			if not(Engine.GetFaceState(0)) then
				Engine.FaceControl(0, true);
	
			Delay(500);
			if not (IsUnderAttack) then begin
				Engine.FaceControl(0, false);
				print('Waiting to get out of combat...');
				Delay(2000 + Random(3000));
				if not (User.InCombat) then break;
			end;
		end;  
		Delay(500);
		Inc(counter);
		if (counter > 100) then break;
	end;
	Engine.FaceControl(0, False);
	Delay(3000);
end;

function Check_ClusterCharge: Boolean;
begin
	result := false;
	if (PvpLoaded) then 
		result := Check_ClusterCharge_Pvp
	else 
		result := Check_ClusterCharge_Pve;

end;

function Check_ClusterCharge_Pvp(): Boolean;
var
dist: Integer;
begin
	result := false;
	
	if (SetTarget_MostClustered_Pvp) then begin
	
		if (User.Target = nil) then Exit;
		
		dist := User.DistTo(user.target);
		if (dist > 350) then begin
			if (HasSkill_Ready(995)) 
			and (dist < 600) then begin
			
				result := Engine.UseSkill(995);
			
			end else if (HasSkill_Ready(994))
			and (dist < 400) then begin
			
				result := Engine.UseSkill(994);
			
			//end else if (HasSkill_Ready(484))
			//and (dist < 400) then begin
			
				//result := Engine.UseSkill(484);
			
			end;
		
		end;	
	end;
end;
function Check_ClusterCharge_Pve(): Boolean;
var
dist: Integer;
begin
	result := false;
	if (SetTarget_MostClustered_Pve) then begin
		
		if (User.Target = nil) then Exit;
	
		dist := User.DistTo(user.target);
		if (dist > 250) then begin
			if (HasSkill_Ready(995)) 
			and (dist < 600) then begin
				
				result := Engine.UseSkill(995);
			
			end else if (HasSkill_Ready(994))
			and (dist < 400) then begin
			
				result := Engine.UseSkill(994);
			
			//end else if (HasSkill_Ready(484))
			//and (dist < 400) then begin
			
				//result := Engine.UseSkill(484);
			
			end;
		
		end;	
	end;
end;

function CheckUse_Charge(oTarget: Tl2Live): Boolean; Overload;
var
dist: Integer;
begin
	result := false;
	if (oTarget = nil) then Exit;
	
	dist := User.DistTo(oTarget);
	if (dist > 350) then begin
		if (HasSkill_Ready(995)) 
		and (dist < 600) then begin
				
			result := Engine.UseSkill(995);
			
		end else if (HasSkill_Ready(994))
		and (dist < 400) then begin
			
			result := Engine.UseSkill(994);
			
		//end else if (HasSkill_Ready(484))
		//and (dist < 400) then begin
			
			//result := Engine.UseSkill(484);
			
		end;
		
	end;
end;
function CheckUse_Charge(oTarget: Tl2Char): Boolean; Overload;
var
dist: Integer;
begin
	result := CheckUse_Charge(oTarget as Tl2Live);
end;

function CheckUse_FinalSecret(): Boolean;
begin
	result := false;
	if HasSkill_Ready(917) and not IHaveBuff(917) then begin
		result := true;
		print('Use final secret!');
		Engine.UseSkill(917);
	end;
end;

function InitializeVariables: void;
var
path: string;
begin
	Engine.FaceControl(1, true); //Make sure attacks are enabled by default
	
	//Game mode?
	interlude := false;
	canBuffNoblesse := true;
	isJava := true;
	DiscreteMode := false;
	PvpEnabled := false;
	ManaMattersMode := false;
	Mode_WaitForCasting := false;
	
	DuoPartyMode := false; //Can be changed by command

	allowEmptyStringMobNames := true;
	
	
	//Skill Cooldowns (milliseconds)
		//Bishop
		SKILL_CD_MASS_BLOCK_WW := 5000;
	
	
	playerDetectDistance := 4500;

	MONSTER_SOCIAL_RANGE 			:= 0;
	MAX_MOB_ON_US_RANGE				:= 900;
	MAX_RANGE 						:= 1000;
	MAX_RANGE_FRIEND				:= 1600;
	MAX_RANGE_AOE 					:= 300;
	MAX_RANGE_NPC_SEARCH 			:= 3000;
	MAX_RANGE_NPC_ATTACKING			:= 1600;
	MAX_DISTANCE_TO_PARTY_FOR_AOE 	:= 900;
	MAX_ASSIST_RANGE_PVP			:= MAX_RANGE;
	MAX_PARTY_PT_DIST				:= 700;
	MAX_RANGE_PVP_SEARCH			:= MAX_RANGE;

	FOLLOW_DIST := 133;
	FOLLOW_RANDOM_TIME_CHANGE := 3000; //Changes to a new random point every 3 seconds.
	FOLLOW_RANDOM_RANGE := 0;
	FOLLOW_Random_X := 0;
	FOLLOW_Random_Y := 0;
	FOLLOW_DELAY := 1000;
	Movement_Delay := 800;
	
	AOE_PX := 0;
	AOE_PY := 0;
	AOE_PT_DIST := 0;
	PT_PX := 0;
	PT_PY := 0;
	PARTY_PT_DIST := 0;
	curPathStep := 0;
	curPath := TList.Create;
	pullMobs_Cooldown := 0;
	weaponOid := 0;
	
	LastAttackTime := 0;
	
	
	(*
	LastAttackTime := User.AtkTime;
	TimeSinceLastAttack := LastAttackTime;
	
	AttackStartTime := MsToTime(LastAttackTime);	
	StartTime := now;
	TotalTimePassed := 0;
	
	print('Total Time passed = ' + IntToStr(GetMillisecondsInBetween(StartTime, now)));
	print('Time Since last Attack = ' + IntToStr(TimeSinceLastAttack));
	*)
	LowHpSettingLoaded := false;
	LowHpMode := false;
	DiscreteLoaded := false;
	PvpLoaded := false;
	PveLoaded := false;
	TempOff := false;
	IsMoving := false;
	MoveLock := false;
	PauseForBuffs := false;
	TotalPause := false;
	CombatEnabled := true;
	FollowEnabled := true;
	CircleAgroMode := false;
	PlayersNearby := false;
	AA_GoClose := false;
	AA_GoVeryClose := false;
	AA_AssistPk := false;
	AA_BringMobsMode := false;
	tempBuffBotPause := false;
	SOS_POP_MODE := false;
	SOS_TargetFound := false;
	LowHp_TargetFound := false;
	TargetSearch_LowestFirst := false;
	TargetSearch_StrongestFirst := false;
	AOE_ENABLED := true;
	
	SettingList := TStringList.Create;
	SettingList.LoadFromFile(GetPath_FileSettings + 'Pvp_Settings.txt'); 
	print('Leader: ' + GetName_Leader);
	print('Server: ' + GetName_Server);


	ClanList := TStringList.Create;
	ClanList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClanExceptions.txt');
	FriendList := TStringList.Create;
	FriendList.LoadFromFile(GetPath_FileSettings + 'Pvp_PlayerExceptions.txt');
	
	
    UdEffectList := TStringList.Create;
    UdEffectList.LoadFromFile(GetPath_FileSettings + 'Pvp_UD_Skills.txt');
	
	DbfImnEffectList := TStringList.Create;
    DbfImnEffectList.LoadFromFile(GetPath_FileSettings + 'Pvp_DebuffImmune_Skills.txt'); 
	
	UltimateEffectList := TStringList.Create;
    UltimateEffectList.LoadFromFile(GetPath_FileSettings + 'Pvp_Ultimate_Skills.txt'); 
	
    DebuffList_1 := TStringList.Create;
    DebuffList_1.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_DebuffNames_1.txt');
    DebuffList_2 := TStringList.Create;
    DebuffList_2.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_DebuffNames_2.txt');
    DebuffList_3 := TStringList.Create;
    DebuffList_3.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_DebuffNames_3.txt');
	
	
	
	DebuffListFighter_1 := TStringList.Create;
	DebuffListFighter_1.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_FighterDebuffNames_1.txt');
	DebuffListFighter_2 := TStringList.Create;
	DebuffListFighter_2.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_FighterDebuffNames_2.txt');
	DebuffListFighter_3 := TStringList.Create;
	DebuffListFighter_3.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_FighterDebuffNames_3.txt');
	
	
	DebuffListMage_1 := TStringList.Create;
	DebuffListMage_1.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_MageDebuffNames_1.txt');
	DebuffListMage_2 := TStringList.Create;
	DebuffListMage_2.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_MageDebuffNames_2.txt');
	DebuffListMage_3 := TStringList.Create;
	DebuffListMage_3.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_MageDebuffNames_3.txt');
	
	
	DisabledEffectList := TStringList.Create;
	DisabledEffectList.LoadFromFile(GetPath_FileSettings + 'Pvp_DisabledEffects.txt');
	
	BuffList_Mage := TStringList.Create;
	BuffList_Mage.LoadFromFile(GetPath_FileSettings + 'Pvp_BuffList_Mage.txt');
	
	BuffList_Fighter := TStringList.Create;
	BuffList_Fighter.LoadFromFile(GetPath_FileSettings + 'Pvp_BuffList_Fighter.txt');
	
	Mail_List := TStringList.Create;
	Mail_List.LoadFromFile(GetPath_FileSettings + 'Pvp_MailItems_IdList.txt');
	
	
	
	ClassList := TStringList.Create;
	if (User.Level < 86) then
		ClassList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClassPriority.txt')
	else 
		ClassList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClassPriority_Helios_Sigel.txt');
		
    ClassProtectionList := TStringList.Create;
    ClassProtectionList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClassProtectionPriority.txt');
    ClassAgroList:= TStringList.Create;
    ClassAgroList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClassAgroPriority.txt');
	
	CommandSenderList := TStringList.Create;

	fighterBuffExceptionList := TStringList.Create;
	fighterBuffExceptionList.Add('4703'); //Pony reuse buff
	fighterBuffExceptionList.Add('1004');//Paagrio Wisdom (Acumen)
	fighterBuffExceptionList.Add('1397');//Clarity
	
	fighterCasterBuffExList := TStringList.Create;
	fighterCasterBuffExList.Add('4703'); //Pony reuse buff
	fighterCasterBuffExList.Add('1397');//Clarity
	
	mageBuffExceptionList := TStringList.Create;
	mageBuffExceptionList.Add('1519');//Chant of blood awakening
	mageBuffExceptionList.Add('4699');//Blessing of Queen
	mageBuffExceptionList.Add('982');//Combat Aura
	mageBuffExceptionList.Add('1537');//Paagrio Crit Combi
	

	skillRecordList := TList.Create;

end;



function ResetVariables: void;
begin
	
	//Game mode?
	canBuffNoblesse := true;
	DiscreteMode := false;
	PvpEnabled := false;
	

	allowEmptyStringMobNames := true;
	
	playerDetectDistance := 4500;

	MONSTER_SOCIAL_RANGE 			:= 0;
	MAX_MOB_ON_US_RANGE				:= 900;
	MAX_RANGE 						:= 1000;
	MAX_RANGE_FRIEND				:= 1600;
	MAX_RANGE_AOE 					:= 300;
	MAX_RANGE_NPC_SEARCH 			:= 3000;
	MAX_RANGE_NPC_ATTACKING			:= 1600;
	MAX_DISTANCE_TO_PARTY_FOR_AOE 	:= 900;
	MAX_ASSIST_RANGE_PVP			:= MAX_RANGE;
	MAX_PARTY_PT_DIST				:= 700;
	MAX_RANGE_PVP_SEARCH			:= MAX_RANGE;

	FOLLOW_DIST := 133;
	FOLLOW_RANDOM_TIME_CHANGE := 3000; //Changes to a new random point every 3 seconds.
	FOLLOW_RANDOM_RANGE := 0;
	FOLLOW_Random_X := 0;
	FOLLOW_Random_Y := 0;
	
	
	LowHpMode := false;
	TempOff := false;
	IsMoving := false;
	MoveLock := false;
	TotalPause := false;
	CombatEnabled := true;
	FollowEnabled := true;
	CircleAgroMode := false;
	PlayersNearby := false;
	AA_GoClose := false;
	AA_GoVeryClose := false;
	AA_AssistPk := false;
	AA_BringMobsMode := false;
	tempBuffBotPause := false;
	SOS_POP_MODE := false;
	SOS_TargetFound := false;
	LowHp_TargetFound := false;

end;






function GetClosestNpcOfId(NpcId: Integer): Tl2Live;
var
i: Integer;
oTarget: Tl2Live;
begin
	result := User as Tl2Live;
	for i := 0 to NpcList.Count - 1 do begin
		oTarget := NpcList.Items(i);
		if (oTarget = nil) then Continue;
		if (User.DistTo(oTarget) > MAX_RANGE_NPC_SEARCH) then break;
		if (oTarget.Id = NpcId) then begin
			result := oTarget;
			Exit;
		end;	
	end;
end;

function HasSkill_Ready_Interval(nSkillId, interval_ms: Integer): Boolean;
var
skillRecord_Index, tempMilli: Integer;
skillRecord: TSkillRecord;
begin
	result := false;
	if HasSkill_Ready(nSkillId) then begin
		skillRecord_Index := IndexOf_SkillRecord_BySkillId(nSkillId);
		if (skillRecord_Index >= 0) then begin
			skillRecord := TSkillRecord(skillRecordList[skillRecord_Index]);
			if (skillRecord.skillId = nSkillId) then begin
				tempMilli := GetMillisecondsInBetween(skillRecord.lastUse, now);
				if (tempMilli >= interval_ms) then begin
					//At this point, the interval since last use has passed, and skill can now be used again.
					result := true;
					exit;
				end else begin
					print('Skill Interval:  Skill with ID = ' + IntToStr(nSkillId) + '  was not ready...    ' + IntToStr(interval_ms - tempMilli) + ' ms remains...');
				end;
			end else
				result := true;
		end else 
			result := true;
	end;
end;

function IndexOf_SkillRecord_BySkillId(nSkillId: Integer): Integer;
var
i: Integer;
skillRecord: TSkillRecord;
begin
	result := -1;
	if (skillRecordList = nil) or (skillRecordList.Count <= 0) then exit;
	for i := 0 to skillRecordList.Count - 1 do begin
		skillRecord := TSkillRecord(skillRecordList[i]);
		if (skillRecord = nil) or (skillRecord.skillId = 0) then continue;
		if (skillRecord.skillId = nSkillId) then begin
			result := i;
			exit;
		end;
	end;
end; 

function UseSkill_SetInterval(nSkillId, intervalToSet: Integer; force: Boolean = false): Boolean;
var
newRecord, skillRecord: TSkillRecord;
skillRecord_Index: Integer;
begin
	//Set cd per SKILL ID
	//Set a time 	DATE Time
	result := false;
	if HasSkill_Ready(nSkillId) then begin
		skillRecord_Index := IndexOf_SkillRecord_BySkillId(nSkillId);
		if (skillRecord_Index >= 0) then begin
			//Skill exists in list, use it, and update lastUse
			skillRecord := TSkillRecord(skillRecordList[skillRecord_Index]);
			if not (skillRecord.skillId = nSkillId) or (skillRecord = nil) then begin
				WriteError('something is very wrong, skillRecord recognized but then not');
				exit;
			end;
			if CUseSkill(nSkillId, force, false, Engine.GetFaceState(0)) then begin
				TSkillRecord(skillRecordList[skillRecord_Index]).lastUse := now;
				result := true;
			end;
		end else begin
			// Skill doesnt exist in list, use it, and add it to list
			if CUseSkill(nSkillId, force, false, Engine.GetFaceState(0)) then begin
				newRecord := TSkillRecord.Create();
				newRecord.lastUse := now;
				newRecord.skillId := nSkillId;
				skillRecordList.Add(newRecord);
				print('Added a new skill record to list.  Added skill with ID = ' + IntToStr(nSkillId));
				result := true;
			end;
		end;
	end;
end;


function SetInterval_OnSkillId(nSkillId, intervalToSet: Integer; force: Boolean = false): Boolean;
var
newRecord, skillRecord: TSkillRecord;
skillRecord_Index: Integer;
begin
	//Set cd per SKILL ID
	//Set a time 	DATE Time
	result := false;
	skillRecord_Index := IndexOf_SkillRecord_BySkillId(nSkillId);
	if (skillRecord_Index >= 0) then begin
		//Skill exists in list, use it, and update lastUse
		skillRecord := TSkillRecord(skillRecordList[skillRecord_Index]);
		if not (skillRecord.skillId = nSkillId) or (skillRecord = nil) then begin
			WriteError('something is very wrong, skillRecord recognized but then not');
			exit;
		end;
		TSkillRecord(skillRecordList[skillRecord_Index]).lastUse := now;
		result := true;
	end else begin
		// Skill doesnt exist in list, use it, and add it to list
		newRecord := TSkillRecord.Create();
		newRecord.lastUse := now;
		newRecord.skillId := nSkillId;
		skillRecordList.Add(newRecord);
		print('Added a new skill record to list.  Added skill with ID = ' + IntToStr(nSkillId));
		result := true;
	end;
end;

function HasIntervalPassed_BySkillId(nSkillId, interval_ms: Integer): Boolean;
var
skillRecord_Index, tempMilli: Integer;
skillRecord: TSkillRecord;
begin
	result := false;
	skillRecord_Index := IndexOf_SkillRecord_BySkillId(nSkillId);
	if (skillRecord_Index >= 0) then begin
		skillRecord := TSkillRecord(skillRecordList[skillRecord_Index]);
		if (skillRecord.skillId = nSkillId) then begin
			tempMilli := GetMillisecondsInBetween(skillRecord.lastUse, now);
			if (tempMilli >= interval_ms) then begin
				//At this point, the interval since last use has passed, and skill can now be used again.
				result := true;
				exit;
			end else begin
				//print('Skill Interval:  Skill with ID = ' + IntToStr(nSkillId) + '  was not ready...    ' + IntToStr(interval_ms - tempMilli) + ' ms remains...');
			end;
		end else
			result := true;
	end else 
		result := true;
end;

function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean): Boolean; Overload;
var
count, x, y, z : Integer;
begin
	result := false;
	count := 0;
	if not HasSkill_Ready(nSkillID) then exit;
	
	if botWasOn then Engine.FaceControl(0, false);
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 2000) do Delay(40);
	//while (User.Cast.EndTime <= 0) and (HasSkill_Ready(nSkillId)) do begin
	while (count < 8) and (HasSkill_Ready(nSkillId)) do begin
		Engine.DUseSkill(nSkillId, force, shift);
		Delay(40);
		count := count + 1 ;
		//if (count > 15) then break;
	end;
	
	if (count < 8) then begin
		result := true;
	end;
	
	if botWasOn then Engine.FaceControl(0, true);
end;

function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean; oTarget: Tl2Live; range: Integer = 900): Boolean; Overload;
var
count, moveCount, x, y, z : Integer;
begin
	result := false;
	count := 0;
	if not HasSkill_Ready(nSkillID) then exit;
	
	if (oTarget = nil) or not (oTarget.Valid) then begin
		print('UseSkill: Warning, target passed was nil or not valid');
		exit;
	end;
	
	if botWasOn then Engine.FaceControl(0, false);
	
	moveCount := 0;
	x := oTarget.X; y := oTarget.Y; z := oTarget.Z;
	while (User.DistTo(oTarget) > range) do begin
		MoveTo_Timer(x, y, z);
		Delay(300);
		x := oTarget.X; y := oTarget.Y; z := oTarget.Z;
		moveCount := moveCount + 1;
		if (moveCount > 5) then begin
			result := true;
			if botWasOn then Engine.FaceControl(0, true);
			exit;
		end;
	end;
	
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 2000) do Delay(40);
	//while (User.Cast.EndTime <= 0) and (HasSkill_Ready(nSkillId)) do begin
	while (count < 8) and (HasSkill_Ready(nSkillId)) do begin
		Engine.DUseSkill(nSkillId, force, shift);
		Delay(40);
		count := count + 1 ;
		//if (count > 15) then break;
	end;
	
	
	if (count < 8) then begin
		result := true;
	end;
	
	if botWasOn then Engine.FaceControl(0, true);
end;

function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean; oTarget: Tl2Char; range: Integer = 900): Boolean; Overload;
var
count, x, y, z : Integer;
begin
	CUseSkill(nSkillId, force, shift, botWasOn, (oTarget as Tl2Live), range);
end;

function GetMillisecondsInBetween(time1, time2: TDateTime): Cardinal;
var
time_to_ms: Cardinal;
begin
	//				ms	 sec  min  hour
	time_to_ms := 86400000; //; 1000 * 60 * 60 * 24 = 86 400 000
	result := abs ( Round( (time1 - time2) * time_to_ms ) );
end;

function TimeToMs(cTime: TDateTime): Cardinal;
begin
	result := Cardinal(cTime * 86400000);
end;
function MsToTime(ms: Cardinal): TDateTime;
begin
	result := ms / 86400000;
end;

function PrintAbnormalBitString(abnormalId: Cardinal): void;
var
data : int64;
i: Integer;
begin

	if (abnormalId = 0) then exit;
	data := int64(abnormalId);
    for i := 31 downto 0 do begin
        if ((data shr i) and 1) = 1 then print('1  i = ' + IntToStr(i))
        else print('0  i = ' + IntToStr(i));
	end;
end;

function IsAbnormalActive(searchId, abnormalId: Cardinal): Boolean;
var
data : int64;
i, index: Integer;
begin
	result := false;
	if (abnormalId = 0) then exit;
	//print('Start pringint gvalues');
	//PrintAbnormalBitString(abnormalId);
	data := int64(abnormalId);
	index := GetBitIndex_FromAPowerOfTwo(searchId);
	if (index < 0) then exit;
    //for i := 31 downto 0 do begin
	if ((data shr index) and 1) = 1 then begin
		//	if (i = index) then begin
				//print('Active Abnormal! i = index     ' + IntToStr(i) + ' = ' + IntToStr(index));
		result := true;
		exit;
		//	end;
	end;
	//end;
(*//data := $01 + ($00 shl 8 ) + ($00 shl 16 ) + ($FF shl 24);
data := int64(searchId);
    for i := 31 downto 0 do
        begin
          if ((data shr i) and 1) = 1 then print('data bit was one  i = ' + IntToStr(i))
          else print('data Bit was Zero  i = ' + IntToStr(i));
          end;
end;*)
end;

function GetBitIndex_FromAPowerOfTwo(po2: cardinal): Integer;
var
num : int64;
i: Integer;
begin
	num := 1;
	//print('GetBit : Search for num = ' + IntToStr(po2));
	for i := 0 to 31 do begin
		if (po2 = num) then begin
			//print('GetBit : found for i = ' + IntToStr(i));
			result := i;
			exit;
		end;
		num := num * 2;
	end;
	//print('GetBit : Not Recognized!');
	result := -1;
end;

function SetWeaponEquipped: Boolean;
var
i: Integer;
oWep: Tl2Item;
begin
	result := false;
	weaponOid := 0;
	for i := 0 to Inventory.User.Count - 1 do begin
		oWep := Inventory.User.Items(i);
		if (oWep.ItemType = 0) and (oWep.Equipped) then begin
			result := true;
			weaponOid := oWep.Oid;
			print('Recognized Main Weapon: ' + oWep.Name);
			exit;
		end;	
	end;
	print('WARNING: No equipped weapon found!');
end;

function IsWeaponEquipped: Boolean;
var
i: Integer;
oWep: Tl2Item;
begin
	result := false;
	for i := 0 to Inventory.User.Count - 1 do begin
		oWep := Inventory.User.Items(i);
		if (oWep.ItemType = 0) and (oWep.Oid = weaponOid) and (oWep.Equipped) then begin
			result := true;
			exit;
		end;	
	end;
end;

function EquipLowerWeapon: Boolean;
var
i, wepId: Integer;
oWep: Tl2Item;
begin
	result := false;
	
	if IsClass_Tyrant(User.ClassId) then begin
	
	end else if IsClass_Destro(User.ClassId) then begin
	
	end else if IsClass_Destro(User.ClassId) then begin
	
	end;
	
	
	for i := 0 to Inventory.User.Count - 1 do begin
		oWep := Inventory.User.Items(i);
		if (oWep.ItemType = 0) and (oWep.Oid = weaponOid) and (oWep.Equipped) then begin
			result := true;
			exit;
		end;	
	end;
end;


function EquipWeapon: Boolean;
var
i: Integer;
oWep: Tl2Item;
begin
	result := false;
	for i := 0 to Inventory.User.Count - 1 do begin
		oWep := Inventory.User.Items(i);
		if (oWep.ItemType = 0) and (oWep.Oid = weaponOid) and (not oWep.Equipped) then begin
			result := Engine.UseItem(oWep);
			exit;
		end;	
	end;
end;

function CheckDisarm(): Boolean;
var
oBuff: Tl2Buff;
begin
	result := false;
	if (weaponOid = 0) then begin
		print('WARNING: No Main Weapon!!!');
		exit;
	end;
	//if (LowHpMode) then begin
		//EquipLowerWeapon;
		//exit;
	//end;
	if not IsWeaponEquipped then begin
		if not User.Buffs.ById(485, oBuff) and not User.Buffs.ById(794, oBuff) then begin	//Check disarm debuffs
			result := EquipWeapon;
			Delay(1500);
		end;
	end;
end;


function wrap_Do_L2Idle_Rebuff: Boolean;
begin
	result := Do_L2Idle_Rebuff;
end;

function wrap_DoRebuff: Boolean;
begin
	result := DoRebuff;
end;

function CompleteAutoFarm: void;
var
lastLoadedZone, nZone, x, y, z, lastX, lastY, lastZ, posCount, counter: Integer;
clanRep: Boolean;
begin
	clanRep := IsClass_Sps(User.ClassId) and (User.level <= 40);
	if (clanRep) then begin
		print('Class Spellsinger detected, enable clan rep mode. Auto open packages/equip start gear');
		delay(1000);
	end;
	if IsClass_Sph(User.ClassId) then
		cLoadConfig('auto_sph.xml')
	else 
		cLoadConfig('auto_farm.xml');
	lastLoadedZone := 0;
	lastX := User.X; lastY := User.Y; lastZ := User.Z;
	posCount := 0;
	
	while true do begin
		Delay(2000);
		if (Check_AutoRelog) then begin
			Delay(5000);
			continue;
		end;
		CheckUseNewbieItems(clanRep);
		
		x := User.X; y := User.Y; z := User.Z;
		if (x = lastX) and (y = lastY) and (z = lastZ) then begin
			posCount := posCount + 1;
			//Print('Position same as last, posCount = ' + IntToStr(posCount));
			if (posCount > 40) and DetectStuck then begin
				Print('We have been standing the same place for too long, minimize/maximize to un-stuck.');
				Unstuck;
				posCount := 0;
			end;
		end else begin
			lastX := x;
			lastY := y;
			lastZ := z;
			posCount := 0;
			
			//Print('Position changed. posCount = ' + IntToStr(posCount));
		end;
		
		
		if (User.Dead) then begin
			Engine.GoHome();
			Delay(15000);
			Continue;
		end else if (User.Buffs.Count < 15) then begin //Missing Buffs
			Print('Buffs missing, go rebuff');
			GetOutOfCombat;
			DoRebuff;
			if DetectStuck then begin
				print('We cannot move!');
				continue;
			end;
			if (User.Level >= 20) and (User.DistTo(147803, -55348, -2728) < 500) then begin
				if Restock then begin
					Print('Restart game in order to leave Multisell chat field.');
					Engine.Restart();
					Delay(1000);
					Engine.GameStart();
					Delay(18000);
					counter := 0;
					x := User.X; y := User.Y; z := User.Z;
					Print('Initiate Minimize/Maximize procedure');
					Engine.SetGameWindow(true);
					Delay(3000);
					Engine.SetGameWindow(false);
					Delay(2000);
					Unstuck; //Anti relog movement bug.
					
				end;
			end;
			Continue;
		end else begin
			GoTo_Spot;
		end;
		
		nZone := GetZone;
		if (lastLoadedZone = 0) or not(lastLoadedZone = nZone) then begin
			Print('Load combat zone: ' + IntToStr(nZone));
			lastLoadedZone := SetZone;
		end;
		
		
	end;

end;

function CheckUseNewbieItems(clanRep: Boolean): Boolean;
var
oItem: Tl2Item;
begin
		if (Inventory.User.ById(21606, oItem)) then begin
			Engine.UseItem(21606);
			Delay(2000);
		end;
		if (Inventory.User.ById(20635, oItem)) then begin
			Engine.UseItem(20635);
			Delay(2000);
		end;
		if (Inventory.User.ById(20637, oItem)) then begin
			Engine.UseItem(20637);
			Delay(2000);
		end;
	if (clanRep) then begin
			
		if (User.level <= 19) then begin
			CheckHaveEquipItem(8977);
			CheckHaveEquipItem(9034);
			CheckHaveEquipItem(9035);
		end else if (User.Level >= 20) and (User.Level < 40) then begin
			CheckHaveEquipItem(20649);
			CheckHaveEquipItem(20650);
			CheckHaveEquipItem(20651);
			CheckHaveEquipItem(20652);
			CheckHaveEquipItem(20653);
			CheckHaveEquipItem(20645);
		end;
		
		if (User.Level >= 40) then begin
			print('We are level 40! Collect clan rep!');
			Engine.BlinkWindow();
		end else if (User.Level > 19) and (User.ClassId = 25) then begin
			print('We are level 20! Change class!');
			Engine.BlinkWindow();
		end;
		
	end;
end;

function CheckHaveEquipItem(itemId: Integer): Boolean;
var
oItem: Tl2Item;
begin
	if (Inventory.User.ById(itemId, oItem)) then begin
		if not (oItem.Equipped) then begin
			Engine.UseItem(oItem);
			Delay(1500);
		end;
	end;
end;

function DetectStuck: Boolean;
var
x, y, z, randX, randY: Integer;
begin
	result := false;
	if (User.Dead) then exit;
	x := User.X; y := User.Y; z := User.Z;
	while (User.Cast.EndTime > 0) do delay(250);
	
	if (Random(2) = 1) then 
		randX := 40
	else  
		randX := -40;
		
	if (Random(2) = 1) then 
		randY := 40
	else  
		randY := -40;
	
	if not Engine.MoveTo(x + randX, y + randY, z) then begin
		Print('Warning we are stuck!');
		result := true;
	end;
end;

function Unstuck: Boolean;
var
counter: Integer;
begin
	result := false;
	Print('Unstuck: Maximize/Minimize!');
	counter := 0;
	while (DetectStuck) do begin
		Engine.SetGameWindow(true);
		Print('Delaying for ' + IntToStr(2400 + (counter * 2300)) + ' milliseconds...');
		Delay(2400 + (counter * 2300));
		Engine.SetGameWindow(false);
		Delay(2000);
		Inc(counter);
		if (counter > 10) then exit;
	end;
	result := true;
end;

function KillAttackers: void;
var
counter : Integer;
begin
	if not (IsUnderAttack) then begin
		Engine.FaceControl(0, False);
		Exit;
	end;
	counter := 0;
	while (IsUnderAttack) and not (User.Dead) do begin
		if not(Engine.GetFaceState(0)) then
			Engine.FaceControl(0, true);
	
		Delay(500);
	end;  
	Engine.FaceControl(0, False);
	Delay(3000);
end;
function CMoveTo(x, y, z: Integer): boolean;
var
count, myZ: Integer;

begin
	count := 0;
	result := false;
	
	if (User.Dead) then exit;
	
	myZ := User.Z;
	if (User.DistTo(x, y, myZ) > 20000) then begin
		print('Distance is greater than 20.000, exit this move.  Distance to point = ' + IntToStr(User.DistTo(x, y, myZ)));
		exit;
	end;
	
	//result := Engine.MoveTo(x, y, z);
	//exit;
	myZ := User.Z;
	while (User.DistTo(x, y, myZ) > 100) do begin
		if (User.Dead) or (count > 70) then begin //counter = 20, is 25 sec?
			//Print('To long passed.. distance to point = ' + IntToStr(User.DistTo(x, y, myZ)));
			break;
		end;
		if (IsUnderAttack) then begin
			//print('We are under attack, kill attackers!');
			KillAttackers;
		end else begin
			//Print('We are not under attack, proceed');
		end;
		MoveTo_Timer(x, y, z);
		count := count + 1;
		Delay(700);
		myZ := User.Z;
	end;
	result := User.InRange(x, y, z, 100);
end;

function GoTo_Spot_GemDragon1: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 15) and not (nZone = 14) then begin
		Print('Go to level 84 spot, Dragon Valley - Gemdragons 1');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToDragonValleyMid;
		CMoveTo(100469, 111383, -3680);
		CMoveTo(99621, 110560, -3704);
		CMoveTo(98448, 109746, -3705);
		CMoveTo(97536, 109443, -3704);
		CMoveTo(97061, 109186, -3584);
		CMoveTo(96528, 108547, -3336);
		CMoveTo(96121, 108086, -3184);
		CMoveTo(95557, 107774, -3112);
		CMoveTo(94653, 107708, -3040);
		CMoveTo(93754, 107635, -3024);
		CMoveTo(92694, 107629, -3032);
		CMoveTo(91989, 107642, -3043);
		CMoveTo(90732, 107529, -3092);
		CMoveTo(89694, 107522, -3072);
		CMoveTo(88855, 107627, -3072);
		CMoveTo(88092, 107819, -3064);
		CMoveTo(87072, 108083, -3117);
		CMoveTo(85983, 108320, -3200);  
	end;
	result := true;
end;
function GoTo_Spot_GemDragon2: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 16) and not (nZone = 15) and not (nZone = 14) then begin
		Print('Go to level 84 spot, Dragon Valley - Gemdragons 2');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToDragonValleyMid;
		CMoveTo(100624, 111558, -3680);
		CMoveTo(100259, 111147, -3672);
		CMoveTo(99626, 110537, -3695);
		CMoveTo(99026, 110059, -3704);
		CMoveTo(98412, 109704, -3717);
		CMoveTo(97822, 109505, -3704);
		CMoveTo(97313, 109321, -3650);
		CMoveTo(96932, 109136, -3568);
		CMoveTo(96783, 108842, -3440);
		CMoveTo(96293, 108253, -3240);
		CMoveTo(95856, 107855, -3136);
		CMoveTo(95224, 107731, -3072);
		CMoveTo(94722, 107695, -3048);
		CMoveTo(94048, 107641, -3024);
		CMoveTo(93291, 107615, -3026);
		CMoveTo(92559, 107623, -3034);
		CMoveTo(92125, 107612, -3038);
		CMoveTo(90848, 107549, -3083);
		CMoveTo(89377, 107452, -3083);
		CMoveTo(88619, 107065, -3160);  
	end;
	result := true;
end;
function GoTo_Spot_GemDragon3: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 16) and not (nZone = 15) then begin
		Print('Go to level 84 spot, Dragon Valley - Gemdragons 3');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToDragonValleyMid;
		CMoveTo(100624, 111558, -3680);
		CMoveTo(100259, 111147, -3672);
		CMoveTo(99626, 110537, -3695);
		CMoveTo(99026, 110059, -3704);
		CMoveTo(98412, 109704, -3717);
		CMoveTo(97822, 109505, -3704);
		CMoveTo(97313, 109321, -3650);
		CMoveTo(96932, 109136, -3568);
		CMoveTo(96783, 108842, -3440);
		CMoveTo(96293, 108253, -3240);
		CMoveTo(95856, 107855, -3136);
		CMoveTo(95224, 107731, -3072);
		CMoveTo(94722, 107695, -3048);
		CMoveTo(94048, 107641, -3024);
		CMoveTo(93291, 107615, -3026);
		CMoveTo(92559, 107623, -3034);
		CMoveTo(92125, 107612, -3038);
		CMoveTo(90848, 107549, -3083);
	end;
	result := true;
end;

function GoTo_Spot_Sph84: Boolean;
begin
	result := false;
	if (User.name = 'Hubba') then 
		GoTo_Spot_GemDragon1
	else if (User.name = 'Bubba') then 
		GoTo_Spot_GemDragon2
	else if (User.Name = 'Gone') then
		GoTo_Spot_GemDragon3;
	
	result := true;
end;

function GoTo_Spot: Boolean;
begin
	result := false;
	if IsClass_Sph(User.ClassId) and (User.Level >= 84) then begin
		
		GoTo_Spot_Sph84;
	
	end else if (User.Level >= 79) then begin
		if not (GetZone = 13) then begin
			Print('Go to level 79 spot, Dragon Valley - Drakos, Necromancers');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToDragonValley;
			CMoveTo(73203, 118076, -3720);
			CMoveTo(73880, 117879, -3736);
			CMoveTo(74410, 117754, -3753);
			CMoveTo(75029, 117625, -3760);
			CMoveTo(75904, 117459, -3750);
			CMoveTo(76628, 117279, -3776);
			CMoveTo(77196, 117143, -3767);
			CMoveTo(77840, 116913, -3778);
			CMoveTo(78466, 116696, -3795);
			CMoveTo(79321, 116434, -3715);
			CMoveTo(80131, 116291, -3608);
			CMoveTo(80640, 116297, -3517);
			CMoveTo(81137, 116518, -3383);
			CMoveTo(81755, 116906, -3225);
			CMoveTo(82293, 117265, -3110);
			CMoveTo(82937, 117683, -3040);
		end;
	end else if (User.Level >= 71) then begin
		if not (GetZone = 10) then begin
			Print('Go to level 70 spot, Varka - Near Spawn');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToVarka;
		end;
	end else if (User.Level >= 67) 
	and (not (IsClass_FighterType(User.ClassId)) or IsClass_Nuker(User.ClassId) or IsClass_Bp(User.ClassId) or IsClass_Archer(User.ClassId) or IsClass_Trick(User.ClassId))
	and not IsClass_Wc(User.ClassId) then begin
		if not (GetZone = 12) then begin
			Print('Go to level 67+ Mage/Archer spot, Pavel Ruins');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortPavel;
			Engine.MoveTo(88937, -125350, -3808);
			Engine.MoveTo(89676, -124451, -3912);
			Engine.MoveTo(90733, -124080, -4059);
			Engine.MoveTo(91861, -123685, -4216);
			Engine.MoveTo(92382, -123327, -4280);
			Engine.MoveTo(93111, -122646, -4544);
		end;
	end else if (User.Level >= 67) or ((User.level >= 65) and IsClass_Tyrant(User.ClassId)) then begin
		if not (GetZone = 2) then begin
			Print('Go to level 67+ Fighter spot, Silent Valley (or lv. 65 for tyrant)');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortSilentValley;
			Engine.MoveTo(171039, 55884, -5344);
			Engine.MoveTo(171461, 56182, -5496);
			Engine.MoveTo(171964, 56514, -5664);
			Engine.MoveTo(172513, 56584, -5792);
			Engine.MoveTo(173479, 56245, -5931);
			Engine.MoveTo(175539, 55138, -6000);
			Engine.MoveTo(175987, 54962, -5992);
		end;
	end else if (User.Level >= 64) then begin
		if not (GetZone = 1) then begin
			Print('Go to level 64+ spot, Garden of beasts');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToGoddard;
			Engine.MoveTo(147458, -56178, -2776);
			Engine.MoveTo(146839, -56125, -2776);
			Engine.MoveTo(146184, -56418, -2776);
			Engine.MoveTo(145461, -56907, -2976);
			Engine.MoveTo(144739, -57550, -2976);
			Engine.MoveTo(144146, -57973, -3022);
			Engine.MoveTo(143065, -58691, -3448);
			Engine.MoveTo(142892, -59198, -3392);
			Engine.MoveTo(142784, -59240, -3360);
			Engine.MoveTo(142592, -59151, -3264);
			Engine.MoveTo(142089, -59515, -3176);
		end;
		
	end else if (User.Level >= 55) then begin
		if not (GetZone = 11) then begin
			Print('Go to level 55+ spot, Fields of Massacre');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToFieldsOfMassacre;
			Engine.MoveTo(183452, -15554, -2736);
			Engine.MoveTo(183411, -15935, -2712);
			Engine.MoveTo(183399, -16400, -2712);
			Engine.MoveTo(183435, -17096, -2800);
			Engine.MoveTo(183431, -17613, -2792);
			Engine.MoveTo(183604, -18351, -2760);
		end;
		
	end else if (User.Level >= 46) then begin
		if not (GetZone = 9) then begin
			Print('Go to level 46 spot, The Cemetary');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToCemetary;
			Engine.MoveTo(172152, 20092, -3328);
			Engine.MoveTo(171811, 19565, -3328);
			Engine.MoveTo(171341, 18941, -3328);
		end;
		
	end else if (User.Level >= 37) then begin
		if not (GetZone = 8) then begin
			Print('Go to level 37 spot, Ivory Tower - Crater');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToIvoryTower;
			Engine.MoveTo(85402, 16352, -3664);
			Engine.MoveTo(85342, 16568, -3608);
			Engine.MoveTo(85336, 17464, -3512);
			Engine.MoveTo(85321, 19827, -3784);
			Engine.MoveTo(85327, 22062, -3512);
			Engine.MoveTo(85328, 23375, -3520);
			Engine.MoveTo(85330, 24104, -3632);
			Engine.MoveTo(85004, 24046, -3616);
			Engine.MoveTo(84878, 23828, -3576);
			Engine.MoveTo(84492, 22773, -4848);
			Engine.MoveTo(84347, 22055, -5288);
			Engine.MoveTo(84274, 21259, -5280);
		end;
		
	end else if (User.Level >= 30) then begin
		if not (GetZone = 7) then begin
			Print('Go to level 30 spot, Cruma Marshlands - upper part');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToCruma;
			Engine.MoveTo(16778, 114173, -3440);
			Engine.MoveTo(16012, 114174, -3576);
			Engine.MoveTo(16143, 113937, -3576);
			Engine.MoveTo(16390, 113849, -3576);
			Engine.MoveTo(16585, 113432, -3576);
			Engine.MoveTo(17194, 112512, -3576);
			Engine.MoveTo(17797, 111827, -3576);
			Engine.MoveTo(18508, 110808, -3656);
			Engine.MoveTo(19037, 109818, -3688);
			Engine.MoveTo(19298, 109037, -3664);
		end;
		
	end else if (User.Level >= 23) then begin
		if not (GetZone = 6) then begin
			Print('Go to level 23 spot, Cruma Marshlands - lower part');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToCrumaMarsh;
			Engine.MoveTo(5564, 126367, -3672);
			Engine.MoveTo(6114, 125379, -3640);
			Engine.MoveTo(6964, 124635, -3664);
			Engine.MoveTo(7473, 124315, -3680);
		end;
		
	end else if (User.Level >= 16) then begin
		if not (GetZone = 5) then begin
			Print('Go to level 16 spot, Neutral Zone');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToNeutralZone;
			Engine.MoveTo(-10680, 76974, -3592);
			Engine.MoveTo(-10591, 77619, -3616);
			Engine.MoveTo(-10302, 78583, -3616);
			Engine.MoveTo(-10050, 79342, -3616);
		end;
		
	end else if (User.Level >= 6) then begin
		if not (GetZone = 4) then begin
			Print('Go to level 6 spot, Talking Island, north - golems');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToTalkingIsland;
			Engine.MoveTo(-84099, 243634, -3728);
			Engine.MoveTo(-84537, 243976, -3728);
			Engine.MoveTo(-84456, 244163, -3728);
			Engine.MoveTo(-84327, 244338, -3728);
			Engine.MoveTo(-84122, 244584, -3728);
			LeadDlg(30006, 3, 9);
			Delay(10000);
			Engine.MoveTo(-106435, 214664, -3424);
			Engine.MoveTo(-105775, 214688, -3408);
			Engine.MoveTo(-104694, 214835, -3424);
			Engine.MoveTo(-103797, 214921, -3424);
			Engine.MoveTo(-103081, 214738, -3288);
		end;
		
	end else if (User.Level >= 1) then begin
		if not (GetZone = 3) then begin
			Print('Go to level 1 spot, Talking Island, outside village');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToTalkingIsland;
			Engine.MoveTo(-83781, 243601, -3728);
			Engine.MoveTo(-83219, 244099, -3728);
			Engine.MoveTo(-82406, 244921, -3720);
		end;
		
		
	end;
	
	if not (Engine.GetFaceState(0)) then Engine.FaceControl(0, true);
	
	result := true;
end;

function SetZone(): Integer;
var
nZone: IntegeR;
begin
	nZone := GetZone;
	result := nZone;
	
	
	if IsClass_Sph(User.ClassId) and (User.Level >= 84) then begin
		if (User.name = 'Hubba') then begin
			cLoadZone('auto_gemdragon1.zmap');
			exit;
		end else if (User.name = 'Bubba') then begin 
			cLoadZone('auto_gemdragon2.zmap');
			exit;
		end else if (User.Name = 'Gone') then begin
			cLoadZone('auto_gemdragon3.zmap');
			exit;
		end;
	
	end;
	
	case nZone of
		1: cLoadZone('auto_gardenOfBeasts1.zmap'); 	//made
		2: cLoadZone('auto_silentValley_Mid.zmap'); 	//made
		3: cLoadZone('auto_talkingIsland_vilout.zmap'); //made
		4: cLoadZone('auto_talkingIsland_north_golems.zmap'); //done
		5: cLoadZone('auto_neutralZone.zmap'); //done
		6: cLoadZone('auto_crumaMarshLow.zmap'); //done
		7: cLoadZone('auto_crumaMarshHigh.zmap'); //done
		8: cLoadZone('auto_ivoryCrater.zmap'); //done
		9: cLoadZone('auto_cemetary.zmap'); 
		10: cLoadZone('auto_varka.zmap'); //done
		11: cLoadZone('auto_fieldsOfMassacre.zmap'); //made
		12: cLoadZone('auto_pavel.zmap');
		13: cLoadZone('auto_dv_dracos.zmap');
		14: cLoadZone('auto_gemdragon1.zmap');
		15: cLoadZone('auto_gemdragon2.zmap');
		16: cLoadZone('auto_gemdragon3.zmap');
		
		
	end;
	
end;

function GetZone: Integer;
var
z: Integer;
debugP: Boolean;
begin
	result := 0;
	debugP := false;
	z := User.Z;
	//Town of Goddard
	if (User.DistTo(147662, -56254, z) < 4500) then begin
		result := 100;
		if debugP then print('Zone 100 recognized - Town of Goddard');
		exit;
	
	//Garden of Beasts outside goddard
	end else if (User.DistTo(140465, -63188, z) < 7300)
	or (User.DistTo(137146, -52719, z) < 8000) then begin
		result := 1;
		if debugP then print('Zone 1 recognized');
		
	//Silent Valley
	end else if (User.DistTo(179258, 53995, z) < 9000) then begin
		result := 2;
		if debugP then print('Zone 2 recognized');
		
	//Talking Island, outside village
	end else if (User.DistTo(-79657, 246841, z) < 5000) then begin
		result := 3;
		if debugP then print('Zone 3 recognized');
		
	//Talking Island, north - golems
	end else if (User.DistTo(-101861, 216217, z) < 5200) then begin
		result := 4;
		if debugP then print('Zone 4 recognized');
		
	//Neutral Zone
	end else if (User.DistTo(-10050, 79342, z) < 16000) then begin
		result := 5;
		if debugP then print('Zone 5 recognized');
		
	//Cruma Marshlands Lower part
	end else if (User.DistTo(16031, 123728, z) < 10000) then begin
		result := 6;
		if debugP then print('Zone 6 recognized');
		
	//Cruma Marshlands Upper part
	end else if (User.DistTo(22023, 104945, z) < 8200) then begin
		result := 7;
		if debugP then print('Zone 7 recognized');
		
	//Ivory Crater
	end else if (User.DistTo(84093, 19896, z) < 11000)
		and (abs(z - (-5288)) < 300) then begin
		result := 8;
		if debugP then print('Zone 8 recognized');
		
	//Cemetary
	end else if (User.DistTo(172748, 17628, z) < 9000) then begin
		result := 9;
		if debugP then print('Zone 9 recognized');
		
	//Varka Spawn
	end else if (User.DistTo(125744, -40864, z) < 13000) then begin
		result := 10;
		if debugP then print('Zone 10 recognized');
		
	//Fields of Massacre
	end else if (User.DistTo(180852, -21055, z) < 15000) then begin
		result := 11;
		if debugP then print('Zone 11 recognized');
		
	//Pavel Ruins
	end else if (User.DistTo(94220, -121241, z) < 3500) then begin
		result := 12;
		if debugP then print('Zone 12 recognized');
		
	//Dragon Valley - Drakos, Necromancers
	end else if (User.DistTo(84366, 119274, z) < 4200) then begin
		result := 13;
		if debugP then print('Zone 13 recognized');
	
	//Dragon Valley - Gemdragons 1
	end else if (User.DistTo(85453, 108039, z) < 3000) and (User.Z > -3350) then begin
		result := 14;
		if debugP then print('Zone 14 recognized');
	
	//Dragon Valley - Gemdragons 2
	end else if (User.DistTo(88619, 107065, z) < 3000) and (User.Z > -3350) then begin
		result := 15;
		if debugP then print('Zone 15 recognized');
	
	//Dragon Valley - Gemdragons 3
	end else if (User.DistTo(90848, 107549, z) < 3300) and (User.Z > -3350) then begin
		result := 16;
		if debugP then print('Zone 16 recognized');
	
		
	end;
	
	
end;


function CheckDispellBuffs(idList: array of integer): Boolean;
var
i, len: Integer;
oBuff: Tl2Buff;
begin
	result := false;
	
	len := Length(idList);
	for i := 0 to len - 1 do begin
		if (User.Buffs.ById(idList[i], oBuff)) then begin
			Engine.Dispel(oBuff.Name);
			result := true;
			exit;
		end;
	end;
end;

function CheckUse_HeroSelfBuffs: Boolean;
begin
	result := false;
	if not User.Hero then exit;
	
	if (CheckUse_HeroicUD) then begin
		result := true;
		exit;
	end;
end;

function CheckUse_HeroicUD: Boolean;
begin
	result := false;
	if HasSkill_Ready(395) //395 = Heroic Miracle
	and not GetMemberHasUdBuff(User)
	and HasItem_MinCount(Engine, 1785, 40) then begin	//Have 40+ soul ore?
		if (User.Cp < 50) 
		and (User.Hp < 60) 
		and (GetCount_HasCharAsTarget_PvpOrPve(User) > 2) then begin
			Print('Use Heroic Miracle! [Buff: UD]');
			
			//Dispell Hero Zerk incase
			CheckDispellBuffs([396]);
			result := CUseSkill(395, false, false, Engine.GetFaceState(0));
		end;
	end;
end;

function CheckUse_HeroicValor_LeaderOnly: Boolean;
var
i: Integer;
begin
	result := false;
	
	if not (User.Name = GetName_Leader) then exit;
	
	if PvpLoaded 
	and HasIntervalPassed_BySkillId(1374, 4000)
	and (GetCount_PartyMembersHasBuff(1374) < 3) then begin	//	1374 = Heroic Valor
		print('Find member to use Heroic Valor');	
		if Use_HeroicValor_OnFirstAvailableHero then begin
			print('Use Heroic Valor');
			SetInterval_OnSkillId(1374, 4000);
			result := true;
		end;
	end;
	
end;

function Use_HeroicValor_OnFirstAvailableHero(): Boolean;
var
i: Integer;
targetControl: Tl2Control;
oSkill : Tl2Skill;
begin
	result := false;
	i := 0;
	targetControl := GetControlByIndex(i);
	while Assigned(targetControl) do begin
		if (targetControl.GetUser.Hero) 
		and (IsTarget_GoodState_Party(targetControl.GetUser, 700))
		and (targetControl.GetSkillList.ById(1374, oSkill))
		and not (oSkill = nil)
		and (oSkill.Valid) 
		and (oSkill.EndTime <= 0) 
		and HasItem_MinCount(targetControl, 3031, 80) then begin  //Has 80 spirit Ore?
			result := targetControl.DUseSkill(1374, false, false);
			result := targetControl.DUseSkill(1374, false, false);
			result := targetControl.DUseSkill(1374, false, false);
			exit;
		end;	
		i := i + 1;
		targetControl := GetControlByIndex(i);
	end;
end;

function GetCount_PartyMembersHasBuff(nBuffId: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
oBuff: Tl2Buff;
begin
	result := -1;
	if (User.Buffs.ById(nBuffId, oBuff)) then
		counter := 1
	else
		counter := 0;
		
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') or not (oTarget.Valid) then continue;
		if (oTarget.Buffs.ById(nBuffId, oBuff)) then Inc(counter);
	end;
	result := counter;
end;


end.