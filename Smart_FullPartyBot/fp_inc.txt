unit fp_inc;
interface


function CheckRemove_OrbisCurse: Boolean;

function InitializeVariables: void;
function ResetVariables: void;

//function SetAttackTime: Boolean;





function wrap_DoRebuff(takeShadow: Boolean = false): Boolean;
function CheckMode_KillAll: Boolean;

function IsTime_ToRebuff(): Boolean;
function CheckParty_DoCancelSleep: boolean;
function MapMove(X, Y: Integer): boolean;
function MoveTo_BackToZone: Boolean;
function MoveTo_AoePoint(rangeToPoint: Integer = 100; disableBot: Boolean = true): Boolean;
function MoveTo_AoePoint_WaitForFinish(rangeToPoint: Integer = 100): Boolean;
function MoveTo_AoePoint_Continuous(rangeToPoint: Integer = 100): Boolean;
function MoveTo_AoePoint_RestoreSettings: void;
function MoveTo_AoeAgroPoint(rangeToPoint: Integer = 100): Boolean;
function IsSkillReady_OtherBotChar(skillId: Integer; sCharName: string; hpCost: Integer = 0; mpCost: Integer = 0): Boolean;

function CheckUse_AssistDebuff(skillId, interval: Integer): Boolean;

function CheckDo_DeadActions_Healer1: Boolean;
function CheckUse_MassBlockWindWalk: Boolean;
function CheckUse_AuraFlash: Boolean;
function CheckUse_DeathHowl: Boolean;
function CheckUse_DeathMark(): Boolean;
function CheckUse_Fear_Pvp(maxRange: Integer = 5000): Boolean;
function CheckUse_Fear_Pvp_GOD(maxRange: Integer = 5000): Boolean;
function CheckUse_AoeSkill_Nuker: Boolean;
function CheckUse_AoeSkill_Nuker_Pvp: Boolean;
function Check_ClusterCharge: Boolean;
function Check_ClusterCharge_Pvp(): Boolean;
function Check_ClusterCharge_Pve(): Boolean;
function CheckUse_Charge(oTarget: Tl2Live): Boolean; Overload;
function CheckUse_Charge(oTarget: Tl2Char): Boolean; Overload;
function CheckUse_FinalSecret(): Boolean;
function CheckUse_Enlightenment_Healer(maxManaForUse: Integer): Boolean;
function CheckUse_HeroicValor_LeaderOnly: Boolean;
function CheckUse_HeroSelfBuffs: Boolean;
function Check_Trigger_TankSeed: Boolean;

function CheckUseRez_Iss: Boolean;

function IsMy_TreeOfLifeUp: Boolean;

function UseSkill_Safe(SkillId: Integer; oTarget: Tl2Live = nil; IsAttackSkill: Boolean = true; UseForUser: Boolean = false): Boolean; Overload;
function UseSkill_Safe(SkillId: Integer; oTarget: Tl2Char = nil; IsAttackSkill: Boolean = true; UseForUser: Boolean = false): Boolean; Overload;

function CheckMove_DeadParty_LeaderOnly: Boolean;
function VoiceCommand_Listen: Boolean;
function DoActions: Boolean;
function IsInPvp: Boolean;
function SetPvpStance: Boolean;
function GetName_Ee: string;
function SetPoint_PartyCenter: void;
function SetDistance_AoePointDistance: void;
function SetDistance_AoeAgroPointDistance: void;
function SetPoint_AoePosition(onlyAgroed: Boolean = false; AoeRange: Integer = 0): TPoint;
function SetPoint_AoeAgroPosition(): TPoint;
function IsAoePoint_Valid: Boolean;
function IsAoeAgroPoint_Valid: Boolean;
function IsOnlyTanksLeft: Boolean;
function IsOtherPlayersNearby(minRange: Integer): Boolean;
function ShouldIAgro: Boolean;

function GetTimeSinceLastAttack(attackTime: Cardinal): Cardinal;

function IsTarget_Casting_Damaging_GroundSkill(oTarget: Tl2Char): Boolean;
function IsTarget_Casting_DayOfDoom(oTarget: Tl2Char): Boolean;

function GetOutOfCombat: void;
function IsUnderAttack: Boolean;
function IsTime_ToAoe: Boolean;
function IsTime_ToAoe_Pvp: Boolean;
function IsTime_ToAoe_Pve: Boolean;
function IsTime_ToMajorGroupHeal: Boolean;
function IsTime_ToBrilliantHeal: Boolean;
function CheckUse_Recharge_Healer1Only(maxMpForRecharge: Cardinal): Boolean;
function CheckUse_Sublime_Healer1Only(): Boolean;
function CheckUse_Rebirth_Healer1Only(): Boolean;
function CheckUse_Rebirth_Healer1Only_V2(): Boolean;
function CheckUse_MassCleanse_Healer1Only(): Boolean;
function CheckUse_BalanceLife_Healer1Only(): Boolean;
function CheckUse_MassRez_Healer1Only(): Boolean;
function CheckUse_Miracle_Healer1Only(): Boolean;
function HandleResurrection_Healer1Only: Boolean;
function HandleCleanse_Healer1Only: Boolean;
//function CheckUse_Rez_Healer1Only(): Boolean;
//function CheckUse_Cleanse_Healer1Only(): Boolean;
function IsTime_ToHeal: Boolean;
function IsTime_ToPickup: Boolean;
function IsTime_ToHeal_Ee: Boolean;
function IsTime_ToPartyUd_Pve: Boolean;
function IsTime_ToPartyUd_Pvp: Boolean;
function LockCheck_MoveAndBot_Off: Boolean;
function LockCheck_MoveAndBot_On: Boolean;
function MoveToTarget_Timeout_Live(oTarget: Tl2Live; rangeToTarget, nTimeOut: Integer): Boolean;
function MoveTo_TimeOut(x, y, z, nMaxTime: Integer): Boolean;

function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean): Boolean; Overload;
function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean; oTarget: Tl2Live; range: Integer = 900): Boolean; Overload;
function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean; oTarget: Tl2Char; range: Integer = 900): Boolean; Overload;

function GetPartyNum: Integer;

function GetTarget_ToFollow(): Tl2Char;
function GetName_Healer1_ByPartyNum(partyNum: Integer): string;
function GetName_Healer1: string;
function GetName_Healer2: string;
function GetName_Healer3: string;
function GetName_Server: string;
function GetPath_CharSettings: string;
function GetPath_FileSettings: string;
function GetPath_ZoneFolder: string;
function cLoadZone(zoneName: string): Boolean;
function cLoadConfig(configName: string): Boolean;
function GetName_Leader: string;
function GetName_CoLeader: string;
function GetName_SecondLeader: string;
function GetName_ThirdLeader: string;
function GetName_FourthLeader: string;
function GetName_FifthLeader: string;
function GetName_LocalLeader: string;
function GetTarget_MainAssist: Tl2Char;
function SetTarget_MainAssist: Boolean;

function GetParty_AverageHp_AliveOnly: Integer;
function GetParty_AverageHp_DeadIncluded: Integer;
function GetMinPartyHp: Integer;
function GetMinPartyMp: Integer;
function GetCount_DeadPartyWithinRange(nMaxRange: Integer; skipDodTarget: Boolean = true): Integer;
function GetCount_MagesClustered_NearChar_Pvp(oCenterTarget: Tl2Char; range: Integer): Integer;
function GetCount_DamageDealers_NearChar_Pvp(oCenterTarget: Tl2Char; range: Integer): Integer;
function GetCount_BishopsAliveInParty_SelfIncluded(maxRange: Integer): Integer;
function WriteError(ErrorMessage : string): void;

function ObjectDistTo_PartyCenter(obj: Tl2Spawn): Cardinal;

function IsSkillReady(skillID: Integer): Boolean; Overload;
function IsSkillReady(skillID: Integer; control: Tl2Control): Boolean; Overload;
function HasSkill_Ready_Interval(nSkillId, interval_ms: Integer): Boolean;
function UseSkill_SetInterval(nSkillId, intervalToSet: Integer; force: Boolean = false): Boolean;

function SetInterval_OnSkillId(nSkillId, intervalToSet: Integer; force: Boolean = false): Boolean;
function HasIntervalPassed_BySkillId(nSkillId, interval_ms: Integer): Boolean;

function IsAnyPartyBishopLowMp_NotMyself(maxMp : Integer): Boolean; overload;
function IsAnyPartyBishopLowMp_NotMyself(myControl: Tl2Control; maxMp : Integer): Boolean; overload;

function CheckSweep: boolean;
function CheckCancelCast(skillId: Integer): Boolean;

procedure Anti_EventPopup;

function SHIFT : boolean;
function CTRL : boolean;
function ALT : boolean;
function bHALF : boolean;

function BoolToStr(statement: Boolean): string;

function cEnterText(msg: string): Boolean;

function GetZone: Integer;
function GetClosestNpcOfId(NpcId: Integer): Tl2Live;

function IsAbnormalActive(searchId, abnormalId: Cardinal): Boolean;

function SetWeaponEquipped: Boolean;
function CheckDisarm(): Boolean;

function CompleteAutoFarm: void;

function KillAttackers: void;
function CMoveTo(x, y, z: Integer): boolean;

function CheckDispellBuffs(idList: array of integer): Boolean;
function CheckFindNewMob: Boolean;
function WaitForCasting: void;

function CheckLeaderDistance(maxDist : Integer = -1; FollowFear: Boolean = true): Boolean;

function TimerExpired_OnPerson(oID, InstanceId: Cardinal): Boolean;
function SetTimer_OnPerson(oID, InstanceId, nTime: Cardinal): Boolean;


function LoadVariableValue_FromProfile(varName : string): string;
function SaveVariable_ToProfile(varName, varValue : string): void;


function GetSettingXmlNamePrefix: string;

procedure Detect_CannotSeeTarget;
function CheckPrevent_CannotSeeTarget: Boolean;


function GetSubPartyNum(control: Tl2Control): Integer; overload;
function GetSubPartyNum(): Integer; overload;


function IsTarget_Leader(sName: string): Boolean;
function IsTarget_InMyGroup(control: Tl2Control): Boolean;


function GetName_SubPartyLeader(PartyNum: Integer): string;


function CheckUse_Stigma: Boolean;
function CheckUse_PainOfShilen_LeaderTypeOnly(): Boolean;


function Handle_Pickup_Healer1Only: Boolean;

implementation
uses
SysUtils, Classes, global_vars, fp_target_inc, fp_char_info, fp_actions_inc, fp_ap, fp_math_inc, class_unit, fp_AutoRelog, fp_skills;


function VoiceCommand_Listen: Boolean;
var
sCommand, prefix, temp: string;
words: array of string;
oSender: Tl2Char;
oSkill: Tl2Skill;
oItem: Tl2Item;
x, y, z, adenaCount, number, count: Integer;
privateCommand: Boolean;
begin
	result := false;
	//Print('Voice command listen: started');
	prefix := 'c';
	oSender := nil;
	if (ChatMessage.Unread)
	and (ChatMessage.Time < 10000)
	and (Party.Chars.ByName(ChatMessage.Sender, oSender) 
		or (ChatMessage.Sender = GetName_Leader) 
		or (ChatMessage.Sender = GetName_SecondLeader)
		or (ChatMessage.Sender = GetName_ThirdLeader)
		or (ChatMessage.Sender = GetName_CoLeader) 
		or (ChatMessage.Sender = GetName_LocalCoLeader) 
		or (ChatMessage.Sender = User.Name)) then begin //Only accept command from ourself, if we are the leader (the guy who types the commands)
	//and not (ChatMessage.Sender = User.Name) then begin
	
		//Only listen to our own commands, if we are the local Leader
		if (ChatMessage.Sender = User.Name) then begin
		
			//Only allow local leaders to listen to own commands.
			if not (User.Name = GetName_LocalLeader) then begin
				exit;
			end;
			
		end;
	
		sCommand := ChatMessage.Text;
		words := sCommand.Split(' ');
		if (Length(words) < 1) then begin
			Print('Voice command listen: ended, too short command');
			Exit;
		end;
		
		if not (words[0] = prefix) then begin
			Print('Voice command listen: ended, wrong prefix');
			Exit;
		end;
		
		//private command?
		privateCommand := false;
		if (Length(words) >= 2) then begin
			if (words[1] = 'us') then begin
				privateCommand := true;
				temp := FilterWordFromCommand('us', words);
				if (temp = '') then begin
					Print('Error: FilterWordFromCommand return nothing');
					exit;
				end;
				sCommand := temp;
				words := sCommand.Split(' ');
				if (Length(words) < 1) then begin
					Print('Voice command listen: ended, too short command');
					Exit;
				end;
			end;
		end;
		
		if (User.Name = GetName_LocalCoLeader) then begin
			Simple_PassCommandToSubParty(sCommand);
		end else if (User.Name = GetName_SubPartyLeader(GetPartyNum)) then begin
			//SubParty-Leader should pass commands along to his party
			if (Party.Chars.Count > 0) then
				Engine.Say(sCommand, 3, '');
		end;
		
		if DuoPartyMode then begin
			if not Party.Chars.ByName(GetName_LocalLeader, oSender) then CharList.ByName(GetName_LocalLeader, oSender);
			if not privateCommand and (User.Name = GetName_CoLeader) then begin
				//Co-Leader should pass commands along to Second-Leader
				PassCommandAlongTo_SecondLeader(sCommand);
				PassCommandAlongTo_ThirdLeader(sCommand);
			end else if (User.Name = GetName_SecondLeader) or (User.Name = GetName_ThirdLeader) then begin
				//Second-Leader should pass commands along to his party
				if (Party.Chars.Count > 0) then
					Engine.Say(sCommand, 3, '');
			end;
		end;
		if (GetSubPartyNum > 0) then begin
			CharList.ByName(GetName_LocalLeader, oSender);
		end;
		
		result := true;
		
		if (sCommand = prefix + ' confirm dlg') then begin
			Engine.ConfirmDialog(true);
		
		end else if (sCommand = prefix + ' enable fear') then begin
			FEAR_ENABLED := true;
			Print('Enabled Fear');
		
		end else if (sCommand = prefix + ' disable fear') then begin
			FEAR_ENABLED := false;
			Print('Disabled Fear');
		
		end else if (sCommand = prefix + ' start all') then begin
			Engine.FaceControl(0, true);
			TotalPause := false;
		
		end else if (sCommand = prefix + ' pause all') then begin
			Engine.FaceControl(0, false);
			TotalPause := true;
		
		end else if (sCommand = prefix + ' start heal') and (GetClassValue_Healer(User.ClassId) > 0) then begin
			Engine.FaceControl(0, true);
			TotalPause := false;
		
		end else if (sCommand = prefix + ' pause heal') and (GetClassValue_Healer(User.ClassId) > 0) then begin
			Engine.FaceControl(0, false);
			TotalPause := true;
		
		end else if (sCommand = prefix + ' pvp on') then begin
			PvpEnabled := true;
			Print('pvp on');
			
		end else if (sCommand = prefix + ' pvp off') then begin //and (IsClass_DD(User.ClassId)) then begin
			PvpEnabled := false;
			Print('pvp off');
		
		end else if (sCommand = prefix + ' pk on') and (IsClass_DD(User.ClassId)) then begin
			TotalPause := true;
			AA_AssistPk := true;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			CommandSenderList.Add(oSender.Name);
		
		end else if (sCommand = prefix + ' pk off') then begin
			TotalPause := false;
			AA_AssistPk := false;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
				
		end else if (sCommand = prefix + ' rbf') then begin
			DoRebuff;
			DoRebuff_Pet;
		
		end else if (sCommand = prefix + ' rbf slow') then begin
			Delay(Random(10000));
			DoRebuff;
			DoRebuff_Pet;
			
		end else if (IsClass_Summoner(User.ClassId) or IsClass_Judi(User.ClassId) or (User.name = 'Tictuu')) 
		and (sCommand = prefix + ' pull mobs') 
		and not AA_BringMobsMode then begin
			print('start pulling...');
			AA_BringMobsMode := true;
			if (MAX_PARTY_PT_DIST < 1200) then 
				temp_Max_Party_Pt_Dist := MAX_PARTY_PT_DIST;
			MAX_PARTY_PT_DIST := 1200;
			pulledMobList := TList.Create();
			
		end else if (sCommand = prefix + ' stop pull mobs') 
		and AA_BringMobsMode then begin
			print('stop pulling...');
			AA_BringMobsMode := false;
			MAX_PARTY_PT_DIST := temp_Max_Party_Pt_Dist;
			if not (pulledMobList = nil) and (pulledMobList.Count > 0) then pulledMobList.Free();
		
		end else if (sCommand = prefix + ' go close') then begin
			Engine.FaceControl(0, false);
			TotalPause := true;
			IsMoving := true;
			AA_GoClose := true;
			AA_GoVeryClose := false;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			CommandSenderList.Add(oSender.Name);
		
		end else if (sCommand = prefix + ' go very close') then begin
			Engine.FaceControl(0, false);
			TotalPause := true;
			IsMoving := true;
			AA_GoClose := false;
			AA_GoVeryClose := true;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			CommandSenderList.Add(oSender.Name);
		
		end else if (sCommand = prefix + ' disable combat') then begin
			CombatEnabled := false;
		
		end else if (sCommand = prefix + ' enable combat') then begin
			CombatEnabled := true;
		
		end else if (sCommand = prefix + ' disable follow') then begin
			FollowEnabled := false;
		
		end else if (sCommand = prefix + ' enable follow') then begin
			FollowEnabled := true;
		
		
		end else if (sCommand = prefix + ' disable aoe') then begin
			AOE_ENABLED := false;
			
			//Reload adrenalin setting file
			PvpLoaded := false;
			PveLoaded := false;
		
		end else if (sCommand = prefix + ' enable aoe') then begin
			AOE_ENABLED := true;
			
			//Reload adrenalin setting file
			PvpLoaded := false;
			PveLoaded := false;
			
		end else if (sCommand = prefix + ' spread') then begin
			Engine.FaceControl(0, true);
			TotalPause := false;
			IsMoving := false;
			AA_GoClose := false;
			AA_GoVeryClose := false;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			
		end else if (sCommand = prefix + ' heal spread') and (GetClassValue_Healer(User.ClassID) > 0) then begin
			Engine.FaceControl(0, true);
			TotalPause := false;
			IsMoving := false;
			AA_GoClose := false;
			AA_GoVeryClose := false;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
		
		end else if (IsClass_Tank(User.ClassID)) and (sCommand = prefix + ' circle agro on') then begin
			CircleAgroMode := true;
			Engine.FaceControl(0, false);
			
		end else if (IsClass_Tank(User.ClassID)) and (sCommand = prefix + ' circle agro off') then begin
			CircleAgroMode := false;
		
		end else if (sCommand = prefix + ' discrete mode on') then begin
			DiscreteMode := true;
			
		end else if (sCommand = prefix + ' discrete mode off') then begin
			DiscreteMode := false;
			
		end else if (sCommand = prefix + ' focus on') then begin
			if not (oSender.Target = nil) and not (oSender.Target.Oid <= 0) then begin
				Print('Switched to focus mode. Only take the leaders current target');
				FOCUS_MOB_OID := oSender.Target.Oid;
				Mode_Focus := true;
			end else begin
				Print('Focus mode failed, leader does not have a valid target.');
			end;
			
		end else if (sCommand = prefix + ' focus off') then begin
			Mode_Focus := false;
			FOCUS_MOB_OID := 0;
			Print('Switched off focus mode. ');
			
		

		end else if (sCommand = prefix + ' use soe') then begin
			if (Inventory.user.ById(736, oItem)) then begin
				Engine.FaceControl(0, false);
				Engine.UseItem(736);
			end; 
			
		end else if (IsClass_Summoner(User.ClassId)) 
		and (sCommand = prefix + ' summon me') then begin
			if (SkillList.ById(1403, oSkill)) then begin
				if (oSkill.EndTime <= 0) or (oSkill.Endtime > 500000) then begin
					Engine.FaceControl(0, false);
					Delay(500);
					Engine.CancelTarget;
					Engine.SetTarget(ChatMessage.Sender);
					Engine.UseSkill(1403);
					Engine.FaceControl(0, true);
				end;
				
			end;
					
					
					
		end else if (interlude) then begin 
			//  If interlude mode is enabled, block the following commands.
			result := false;
			Print('Voice command ended, its interlude');
			exit;
				
		end else if (Length(words) >= 2) and (words[1] = 'port') then begin
			HandleCommand_Port(sCommand);
				
		end else if (Length(words) >= 3) and (words[1] = 'talk') then begin
			HandleCommand_TalkToNpc(sCommand, oSender);
		
		end else if (sCommand = prefix + ' enter fog') then begin
			MoveTo_InsideFog;
		
		end else if (sCommand = prefix + ' enter lower fog') then begin
			LeadDlg(32645, 1);
		
		end else if (sCommand = prefix + ' take 7rb quest') then begin
			LeadDlg(30754, 2, 1, 1, 1, 1, 1);
			
		end else if (sCommand = prefix + ' enter baium') then begin
			LeadDlg(31862, 1, 1);
		
		end else if (sCommand = prefix + ' enter dv north') then begin
			if not LeadDlg(32870, 3) then LeadDlg(32865, 3);
		
		end else if (sCommand = prefix + ' mail me adena') then begin
			DoMails([57, 9547, 6393, 959, 9627, 9554, 10639]);
		
		end else if (sCommand = prefix + ' mail me everything') then begin
			DoAllMails();
			
		end else if (sCommand = prefix + ' restock') then begin
			Restock;
		
		end else if (sCommand = prefix + ' sell items') then begin
			SellAllItems;
		
		end else if (sCommand = prefix + ' store items') then begin
			DepositAllItems_ToClanWh;
		
		end else if (sCommand = prefix + ' ' + User.Name + ' buy dyes for everyone') then begin
			BuyAndSendDyesToParty;
		
		end else if (sCommand = prefix + ' enter soa') then begin
			LeadDlg(32734, 1);
		
		end else if (sCommand = prefix + ' walk soa tunnel') then begin
			SoaTunnelMove(3000);
		
		end else if (sCommand = prefix + ' move zaken') then begin
			MoveZaken();
		
		end else if (sCommand = prefix + ' exit instance') then begin
			ExitInstance();
		
		end else if (sCommand = prefix + ' move freya') then begin
			if (GetName_Server = 'Idle') then begin
				OpenGk;
				Delay(1000);
				Engine.DlgSel('Schuttgart Area');
				Delay(1000);
				Engine.DlgSel(7);
				Delay(5000);
			end else
				MoveFreya();
		
		end else if (sCommand = prefix + ' move loa bridge') then begin
			MoveTo_LoaForceFieldBridge();
			
			
		
		end else if (sCommand = prefix + ' take core') then begin
			if (User.Inrange(102504, -124440, -2760, 1000)) and not (Inventory.user.ById(15469, oItem)) then begin
				Delay(Random(15000));
				Engine.FaceControl(0, False);
				Engine.MoveTo(102504 + RandomizeNumber(50, 25), -124440 + RandomizeNumber(50, 25), -2760);
				Engine.CancelTarget;
				LeadDlg(32761, 1);
			end;
		
		end else if (sCommand = prefix + ' use core') then begin
			Engine.FaceControl(0, False);
			Delay(500);
			Engine.StopCasting();
			WalkRandom(10, 20);
			Delay(500);
			Engine.UseItem(15469);
			Engine.UseItem(15469);
			Engine.UseItem(15469);
			print('Use Core!!!');
			While (User.Cast.EndTime > 0 ) do delay(500);
			Engine.FaceControl(0, True);
			
			
			
		
		end else if (sCommand = prefix + ' max dps') then begin
			count := 0;
			//count = 50 -> 10 seconds
			while (count < 50) and HasSkill_Ready(1532) and not IHaveBuff(1532) do begin
				Engine.DUseSkill(1532, false, false);
				Delay(200);
				count := count + 1; 
			end;
		
		end else if (sCommand = prefix + ' shut everything down!') then begin
			Delay(3000);
			Engine.GameClose;
			
		
		end else if (sCommand = prefix + ' to village') then begin
			Engine.GoHome(rtTown);
		end else if (sCommand = prefix + ' to clan hall') then begin
			Engine.GoHome(rtClanHall);
		end else if (sCommand = prefix + ' to castle') then begin
			Engine.GoHome(rtCastle);
		end else if (sCommand = prefix + ' to fort') then begin
			Engine.GoHome(rtFort);
		end else if (sCommand = prefix + ' to outpost') then begin
			Engine.GoHome(rtFlags);
			
		end else if (sCommand = prefix + ' drop adena') then begin
			if (Inventory.user.ById(57, oItem)) then begin
				x := User.X; y := User.Y; z := User.Z;
				adenaCount := oItem.Count;
				if (adenaCount > 100000) then begin
					Engine.dropitem(57, adenaCount - 90000, x, y, z);
					delay(3000);
				end;
			end; 
			if (Inventory.user.ById(6361, oItem)) then begin
				x := User.X; y := User.Y; z := User.Z;
				adenaCount := oItem.Count;
				if (adenaCount > 0) then begin
					Engine.dropitem(6361, adenaCount, x, y, z);
					delay(3000);
				end;
			end; 
					
		end else if (sCommand = prefix + ' item count') then begin
			Speak_ItemsCount_Party;
					
		end else if (sCommand = prefix + ' take vit') then begin
			if (Engine.SetTarget(4306)) then 
				LeadDlg(4306, 1);
					
		end else if (sCommand = prefix + ' reset vars') then begin
			ResetVariables;
					
		end else if (sCommand = prefix + ' enable killall') then begin
			Mode_KillAll := true;
					
		end else if (sCommand = prefix + ' disable killall') then begin
			Mode_KillAll := false;
					
		end else if (sCommand = prefix + ' fol m1') then begin
			FOLLOW_CURRENT_POSITION := false;
			FOLLOW_RANDOM_RANGE := 150;
			FOLLOW_DIST := 25;
					
		end else if (sCommand = prefix + ' fol m2') then begin
			FOLLOW_CURRENT_POSITION := true;
			FOLLOW_RANDOM_RANGE := 0;
			FOLLOW_DIST := 0;
					
		end else if (sCommand = prefix + ' fol m3') then begin
			FOLLOW_CURRENT_POSITION := true;
			FOLLOW_RANDOM_RANGE := 40;
			FOLLOW_DIST := 35;
					
		end else if (sCommand = prefix + ' fol cur pos') then begin
			FOLLOW_CURRENT_POSITION := true;
					
		end else if (sCommand = prefix + ' fol end pos') then begin
			FOLLOW_CURRENT_POSITION := false;
					
		end else if (sCommand = prefix + ' inc fol rand') then begin
			FOLLOW_RANDOM_RANGE := FOLLOW_RANDOM_RANGE + 50;
			
		end else if (sCommand = prefix + ' inc fol dist') then begin
			FOLLOW_DIST := FOLLOW_DIST + 25;
					
		end else if (sCommand = prefix + ' dec fol rand') then begin
			if (FOLLOW_RANDOM_RANGE > 50) then
				FOLLOW_RANDOM_RANGE := FOLLOW_RANDOM_RANGE - 50
			else
				FOLLOW_RANDOM_RANGE := 0;
			
		end else if (sCommand = prefix + ' dec fol dist') then begin
			if (FOLLOW_DIST > 25) then
				FOLLOW_DIST := FOLLOW_DIST - 25
			else
				FOLLOW_DIST := 0;
			
		end else if (Length(words) = 5)
		and (words[0] = 'c') //Example command: "c set follow dist 700", will change the follow distance to 700.
		and (words[1] = 'set')
		and (words[2] = 'fol') 
		and (words[3] = 'dist') then begin
			number := StrToIntDef(words[4], -1);
			if (number >= 0) then begin 
				FOLLOW_DIST := number;
			end;
			
		end else if (Length(words) = 5)
		and (words[0] = 'c') //Example command: "c set follow rand 300", will change the random position to a radius of 300
		and (words[1] = 'set')
		and (words[2] = 'fol') 
		and (words[3] = 'rand') then begin
			number := StrToIntDef(words[4], -1);
			if (number >= 0) then begin 
				FOLLOW_RANDOM_RANGE := number;
			end;
			
		
		end else if (sCommand = prefix + ' fol setting') then begin			
			if (User.Name = GetName_CoLeader) then begin
				Delay(1000);
				Engine.Say('Follow distance = ' + IntToStr(FOLLOW_DIST), 3, '');
				Engine.Say('Follow random range = ' + IntToStr(FOLLOW_RANDOM_RANGE), 3, '');
				Engine.Say('Follow current position = ' + BoolToStr(FOLLOW_CURRENT_POSITION), 3, '');
				
			end;
			
		end else if (Length(words) = 5)
		and (words[0] = 'c') //Example command: "c set agro dist 300", will change the the range of targets to agro to 300
		and (words[1] = 'set')
		and (words[2] = 'agro') 
		and (words[3] = 'dist') then begin
			number := StrToIntDef(words[4], -1);
			if (number >= 0) then begin 
				MAX_RANGE_TOAGRO := number;
			end;
			
		end else if (sCommand = prefix + ' lower') then begin
			LowHpMode := true;
			SetInterval_OnSkillId(99999, 120000);
			
		end else if (sCommand = prefix + ' stop lower') then begin
			LowHpMode := false;
			
		end else if (sCommand = prefix + ' stay close on') then begin
			Mode_StayClose := true;
			Range_StayClose := 250;
			
		end else if (sCommand = prefix + ' stay close off') then begin
			Mode_StayClose := false;
			Range_StayClose := 250;
			
		end else if (sCommand = prefix + ' duo mode on') then begin
			DuoPartyMode := true;
			print('Switched to duo party mode');
			
		end else if (sCommand = prefix + ' duo mode off') then begin
			DuoPartyMode := false;
			if (IsTarget_Leader(User.Name)) then foundTargetToFollow := false;
			print('Switched to single party mode');
			
		end else if (sCommand = prefix + ' seed mode on') then begin
			SEED_POP_MODE := true;
			print('Switched to Tank Seed triggering mode');
			
		end else if (sCommand = prefix + ' seed mode off') then begin
			SEED_POP_MODE := false;
			print('Switched off from Tank Seed triggering mode');
			
		end else if (sCommand = prefix + ' closest first on') then begin
			TargetSearch_ClosestFirst := true;
			print('Switched to ''Closest First'' target search mode');
		end else if (sCommand = prefix + ' closest first off') then begin
			TargetSearch_ClosestFirst := false;
			print('Switched to ''Closest First'' target search mode');
			
		end else if (sCommand = prefix + ' lowest first on') then begin
			TargetSearch_LowestFirst := true;
			print('Switched to ''Lowest First'' target search mode');
			
		end else if (sCommand = prefix + ' lowest first off') then begin
			TargetSearch_LowestFirst := false;
			print('Switched off from ''Lowest First'' target search mode');
			
		end else if (sCommand = prefix + ' strongest first on') then begin
			TargetSearch_StrongestFirst := true;
			print('Switched to ''Strongest First'' target search mode');
			
		end else if (sCommand = prefix + ' strongest first off') then begin
			TargetSearch_StrongestFirst := false;
			print('Switched off from ''Strongest First'' target search mode');
			
		end else if (sCommand = prefix + ' assist leader on') then begin
			Mode_AssistLeader := true;
			print('Switched to assist leader mode');
			
		end else if (sCommand = prefix + ' assist leader off') then begin
			Mode_AssistLeader := false;
			print('Switched off from assist leader mode');
			
		
		
		end else if (sCommand = prefix + ' do restart') then begin
			print('Make Restart');
			Engine.FaceControl(0, false);
			Delay(1000);
			Engine.Restart();
			Delay(2000);
			Engine.GameStart();
			Delay(4000);
			
		end else if (sCommand = prefix + ' bash gate') then begin
			print('Bash Gate');
			Mode_BashGate := true;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			CommandSenderList.Add(oSender.Name);
			
		end else if (sCommand = prefix + ' stop bash gate') then begin
			print('Bash Gate off');
			Mode_BashGate := false;
			if not (CommandSenderList = nil) or (CommandSenderList.count > 0) then CommandSenderList.Free;
			CommandSenderList := TStringList.Create;
			
		end else if (sCommand = prefix + ' soe to castle') then begin
			print('SOEing to Castle');
			if (Inventory.User.ById(1830, oItem)) then begin
				Engine.UseItem(1830);
			end;
			
		end else if (sCommand = prefix + ' cancel buffs') then begin
			print('Walk to buffer and cancel buffs.');
			CancelAllBuffs;
		
		
		end else if (sCommand = prefix + ' enable pickup2') then begin
			print('Switch to pickup Mode');
			Mode_Pickup := true;
			if (User.Name = GetName_Healer1) then 
				DropDistributionList := TStringList.Create;
		
		
		end else if (sCommand = prefix + ' disable pickup2') then begin
			print('Switch to pickup Mode');
			Mode_Pickup := false;
			if (User.Name = GetName_Healer1) then 
				DropDistributionList.Free;
		
		end else if (sCommand = prefix + ' enable pickup1') then begin
			print('Switch to normal pickup Mode');
			Mode_Standard_Pickup := true;
			
		end else if (sCommand = prefix + ' disable pickup1') then begin
			print('Switch to normal pickup Mode');
			Mode_Standard_Pickup := false;
		
		
		end else
			result := false;
		
		
		
	end;
	
	//Print('Voice command listen: ended.');
end;


function FilterWordFromCommand(wordToFilter: string; words: array of string): string;
var
i, len: Integer;
resultWord: string;
wordToFilter_Found: Boolean;
begin
	result := '';
	if (wordToFilter = '') then exit;
	
	len := Length(words);
	if (len < 2) then exit; //minimum 2 words
	resultWord := '';
	wordToFilter_Found := false;
	for i := 0 to len - 1 do begin
		if not (words[i] = wordToFilter) then begin
			resultWord := resultWord + words[i];
			if not (i = len - 1) then resultWord := resultWord + ' '; //add spaces, but not for last iteration.
			
		end else begin
			if not (wordToFilter_Found) then begin
				wordToFilter_Found := true;
			end else begin
				result := '';
				Print('error, found 2 words to skip');
				exit;
			end;
		end;
	end;
	
	if not (wordToFilter_Found) then begin
		Print('Error: Found no words to filter');
		result := '';
		exit;
	end;	
	
	result := resultWord;
end;

function PassCommandAlongTo_SecondLeader(sCommand: string): Boolean;
begin
	//Send commands two times, incase of miss-read
	Engine.Say(sCommand, 2, GetName_SecondLeader());
	Engine.Say(sCommand, 2, GetName_SecondLeader());
end;
function PassCommandAlongTo_ThirdLeader(sCommand: string): Boolean;
begin
	//Send commands two times, incase of miss-read
	Engine.Say(sCommand, 2, GetName_ThirdLeader());
	Engine.Say(sCommand, 2, GetName_ThirdLeader());
end;

function HandleCommand_Port(sMessage: string): Boolean;
var
sCommand: string;
words: array of string;
i: Integer;
begin
	result := false;
	
	words := sMessage.Split(' ');	
	
	sCommand := '';
	for i := 1 to Length(words) - 1 do begin
		if not(i = 1) then sCommand := sCommand + ' ';
		sCommand := sCommand + words[i];
	end;	
	
	result := true;
	
	if (sCommand = 'port toi1') then begin
		PortToi1;
	end else if (sCommand = 'port toi2') then begin
		PortToi2;
	end else if (sCommand = 'port toi3') then begin
		PortToi3;
	end else if (sCommand = 'port toi4') then begin
		PortToi4;
	end else if (sCommand = 'port toi5') then begin
		PortToi5;
	end else if (sCommand = 'port toi6') then begin
		PortToi6;
	end else if (sCommand = 'port toi7') then begin
		PortToi7;
	end else if (sCommand = 'port toi8') then begin
		PortToi8;
	end else if (sCommand = 'port toi9') then begin
		PortToi9;
	end else if (sCommand = 'port toi10') then begin
		PortToi10;
	end else if (sCommand = 'port toi11') then begin
		PortToi11;
	end else if (sCommand = 'port toi12') then begin
		PortToi12;
	end else if (sCommand = 'port toi13') then begin
		PortToi13;
	end else if (sCommand = 'port pavel') then begin
		PortPavel;
	end else if (sCommand = 'port fog') then begin
		PortFog;
	end else if (sCommand = 'port ev') then begin
		PortToEnchantedValley;
	end else if (sCommand = 'port breka') then begin
		PortToBreka;
	end else if (sCommand = 'port vos') then begin
		PortToValleyOfSaints;
	end else if (sCommand = 'port ivory') then begin
		PortToIvoryTower;
	end else if (sCommand = 'port abg') then begin
		PortToABG;
	end else if (sCommand = 'port cemetary') then begin
		PortToCemetary;
	end else if (sCommand = 'port beehive') then begin
		PortToBeehive;
	end else if (sCommand = 'port sos') then begin
		PortToSwampOfScreams;
	end else if (sCommand = 'port dv') then begin
		PortToDragonValley;
	end else if (sCommand = 'port dv mid') then begin
		PortToDragonValleyMid;
	end else if (sCommand = 'port loa') then begin
		PortToAntharasLair;
	end else if (sCommand = 'port orc barracks') then begin
		PortToOrcBarracks;
	end else if (sCommand = 'port windy hill') then begin
		PortWindyHill;
	end else if (sCommand = 'port town') then begin
		PortRandomTown;
	end else if (sCommand = 'port giran') then begin
		PortToGiran;
	end else if (sCommand = 'port heine') then begin
		PortToHeine;
	end else if (sCommand = 'port rune') then begin
		PortToRune;
	end else if (sCommand = 'port dion') then begin
		PortToDion;
	end else if (sCommand = 'port aden') then begin
		PortToAden;
	end else if (sCommand = 'port soa') then begin
		PortSoa;
	end else if (sCommand = 'port soi') then begin
		PortSoI;
	end else if (sCommand = 'port sod') then begin
		PortSoD;
	end else if (sCommand = 'port silent valley') then begin
		PortSilentValley;
	end else if (sCommand = 'port it') then begin
		PortImperialTomb;
	end else if (sCommand = 'port mos') then begin
		PortMonastery;
	end else if (sCommand = 'port mos upper') then begin
		PortMonasteryUpper;
	end else if (sCommand = 'port varka') then begin
		PortToVarka;
	end else if (sCommand = 'port den of evil') then begin
		PortDenOfEvil;
	end else if (sCommand = 'port gc') then begin
		PortGiantsCave;
	end else if (sCommand = 'port ketra') then begin
		PortToKetra;
	end else if (sCommand = 'port varka') then begin
		PortToVarka;
		
		
		
		
	end else if (sCommand = 'port hb dunes') then begin
		PortToHellboundDunes;
		
	end else if (sCommand = 'port hb entrance') then begin
		PortToHellboundEntrance;
	end else if (sCommand = 'port hb quary') then begin
		PortToHellboundQuary;
	end else if (sCommand = 'port hb oasis') then begin
		PortToHellboundOasis;
	end else if (sCommand = 'port hb temple') then begin
		PortToHellboundAncientTemple;
	end else if (sCommand = 'port hb battered') then begin
		PortToHellboundBatteredLands;
	end else if (sCommand = 'port hb foundry') then begin
		PortToHellboundAtmoicFoundry;

	end else if (sCommand = 'port pagan') then begin
		PortPagan;
		Engine.MoveTo(34916, -49756, -760);
		Engine.SetTarget(32039);
		Delay(500);
		Engine.DlgOpen();
		Delay(3000);
		Engine.MoveTo(-13102, -35817, -10848);
		Engine.MoveTo(-15262, -35831, -10736);
		Engine.MoveTo(-16379, -36518, -10720);
		Engine.MoveTo(-16245, -36709, -10720);
		
		
		
	end else if (sCommand = 'port dark omens') then begin
		PortCataDarkOmens;
	end else if (sCommand = 'port forbidden path') then begin
		PortCataForbiddenPath;
	end else if (sCommand = 'port witch') then begin
		PortCataWitch;
	end else if (sCommand = 'port apostate') then begin
		PortCataApostate;
	end else if (sCommand = 'port branded') then begin
		PortCataBranded;
	end else if (sCommand = 'port heretics') then begin
		PortCataHeretics;
	end else if (sCommand = 'port saints') then begin
		PortNecroSaints;
	end else if (sCommand = 'port disciples') then begin
		PortNecroDisciple;
	end else if (sCommand = 'port martyrdom') then begin
		PortNecroMartyrdom;
	end else if (sCommand = 'port devotion') then begin
		PortNecroDevotion;
	end else if (sCommand = 'port patriots') then begin
		PortNecroPatriots;
	end else if (sCommand = 'port worshippers') then begin
		PortNecroWorshippers;
	end else if (sCommand = 'port pilgrims') then begin
		PortNecroPilgrims;
	end else if (sCommand = 'port sacrifice') then begin
		PortNecroSacrifice;
	
	
	
	
	
	
	
	
	
	end else 
		result := false;
	

end;

function HandleCommand_TalkToNpc(sMessage: string; oCommander: Tl2Char): Boolean;
var
sCommand: string;
words: array of string;
talkIndices: array of Integer;
npcId, commandLength: Integer;
i: Integer;
oNpc: Tl2Live;
begin
	result := false;
	
	words := sMessage.Split(' ');	
	commandLength := Length(words);
	if (commandLength < 3) then exit;
	if (oCommander = nil) or (oCommander.Target = nil) then exit;
	
	if (words[0] = 'c')
	and (words[1] = 'talk') then begin
		
		SetLength(talkIndices, commandLength - 2);
		for i := 0 to Length(talkIndices) - 1 do begin
			//Skip the first 2 words. ('c', 'talk')
			talkIndices[i] := StrToIntDef(words[i + 2], 0);
			if (talkIndices[i] = 0) then begin
				print(words[i + 2] + ' is not recognized as a number.');
				exit;
			end;
		end;
	
		oNpc := oCommander.target;
		
		//Check if the desired npc is present
		if not (oNpc = nil) then begin
			
			//Fail safe
			if (not oNpc.Valid)
			or (User.DistTo(oNpc) > 1000)
			or (oNpc.Attackable) then begin
				Print('Npc: ' + oNpc.Name + ' is not available.');
				exit;
			end;
			
			//Speak to npc
			Engine.CancelTarget();
			Engine.SetTarget(oNpc);
			Delay(200);
			if (User.DistTo(oNpc) > 75) then Engine.MoveToTarget(-75);
			Delay(500);
			Engine.DlgOpen();
			Delay(1000);
			for i := 0 to Length(talkIndices) - 1 do begin
				if not Engine.DlgSel(talkIndices[i]) then exit;
				Delay(1000);
			end;
			
			result := true;
		end;
	end;
end;


function IsTime_ToTrigger_Seed_OnTarget(oTarget: Tl2Char): Boolean;
var
oBuff: Tl2Buff;
baseId, triggeredId, buffId: Integer;
begin
	result := false;
	
	if (oTarget = nil) or not oTarget.IsMember then exit;
	
	if IsClass_Sk(oTarget.ClassId) then begin
		baseId := 788;
		triggeredId := 5564;
		buffId := 789;
	end else if (IsClass_HK(oTarget.ClassId)) then begin
		baseId := 761;
		triggeredId := 5561;
		buffId := 0;
	end else if (IsClass_Pala(oTarget.ClassId)) then begin
		baseId := 784;
		triggeredId := 5562;
		buffId := 785;
	end else if (IsClass_Tk(oTarget.ClassId)) then begin
		baseId := 786;
		triggeredId := 5563;
		buffId := 787;
	end else exit;
	
	
	if User.DistTo(oTarget) > 1000 then exit;
	
	//If we already have Spirit of shilen, then false.
	If User.Buffs.ById(buffId, oBuff) or oTarget.Buffs.ById(buffId, oBuff) then begin
		if (oBuff.EndTime > 10000) then exit;
	end;
	
	if oTarget.Buffs.ById(baseId, oBuff)
	or ((oTarget.Buffs.ById(triggeredId, oBuff)) and (oBuff.Level < 3)) then result := true
end;

function Check_Trigger_TankSeed: Boolean;
var
i, x, y, z: Integer;
oTarget, oResult: Tl2Char;
found: Boolean;
begin
	result := false;
	if not SEED_POP_MODE then exit;
	
	found := false;
	oResult := nil;
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) then continue;
		if not oTarget.Dead 
		and (oTarget.Hp > 60) 
		and IsTime_ToTrigger_Seed_OnTarget(oTarget) then begin
			found := true;
			oResult := oTarget;
		end;
	end;
	
	if found and not (oResult = nil) then begin
		if not (User.Target = oResult) then begin
			Engine.CancelTarget;
			Engine.SetTarget(oResult);
		end;
		
		if (User.DistTo(User.Target) > 900) then begin
			x := User.Target.X; 
			y := user.Target.Y; 
			z := User.Target.Z;
			Engine.DMoveTo(x, y, z);
			result := true;
			exit;
		end;
		
		if not Action_UseSingleSkill_Force() then begin
			(* the following part will never be used! since Action_UseSingleSkill_Force always return true, it will standard attack if no skill found*)
			x := User.Target.X; 
			y := user.Target.Y; 
			z := User.Target.Z;
			if (User.DistTo(User.Target) > 200) then begin
				Engine.DMoveTo(x, y, z);
				result := true;
				exit;
			end;
			Engine.Attack(50, true);
		end;
		SOS_TargetFound := true;
		result := true;
	end else if SOS_TargetFound then begin
		WalkRandom(5, 10);
		SOS_TargetFound := false;
	end;
	
end;

function CheckDo_DeadActions_Healer1: Boolean;
begin
	result := false;
	
	if (User.Dead) and ((User.Name = GetName_Healer1) or (User.Name = GetName_SubPartyLeader(GetPartyNum))) then begin
		if CheckUse_MassRez_Healer1Only
		or HandleResurrection_Healer1Only
		or ((*PvpLoaded and *)CheckUse_MassCleanse_Healer1Only)
		or HandleCleanse_Healer1Only
		or ((*PvpLoaded and *)CheckUse_Sublime_Healer1Only)
		or ((*PvpLoaded and *)CheckUse_Miracle_Healer1Only)
		or (not LowHpMode and CheckUse_BalanceLife_Healer1Only) then begin
			result := true;
			exit;
		end;
	end;	
end;

function CheckParty_DoCancelSleep: boolean;
var
i: Integer;
oTarget, temp: Tl2Char;
begin
	result := false;
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or not (CharList.ByName(oTarget.Name, temp)) then continue;
		
		if not(oTarget.Dead)
		and IsAbnormalActive(128, oTarget.AbnormalId) then begin
			result := true;
			engine.SetTarget(oTarget);
			Engine.Attack(500, true);
			exit;
		end;
	end;
end;

function DoMails(IdList: array of Cardinal): Boolean;
var
i, j, IDLength: Integer;
TempMailList, MailList: array of Cardinal;
ItemCount: Cardinal;
oItem: Tl2Item;
HasItem: Boolean;
recipentName: string;
begin
	//print('Mail adena initiated.');
  j := 0;
  IdLength := Length(IdList);
  SetLength(TempMailList, (2 * (IdLength)));
  for i := 0 to IdLength - 1 do begin
  HasItem := Inventory.User.ByID(IdList[i], oItem);
    if (HasItem) then begin
	  if (oItem.ID = 57) then begin
        ItemCount := oItem.count - 10000000;
        if (ItemCount < 30000) then continue;
      end else begin
        ItemCount := oItem.Count;
      end;	  
	  if (ItemCount > 0) then begin
	    TempMailList[j*2] := IdList[i];
		TempMailList[(j*2)+1] := ItemCount;
		Inc(j);
	  end;
	end;
  end;  
	
	//print('Found ' + IntToStr(j) + ' items to mail.');
  if (j > 0) then begin
    SetLength(MailList, (j*2));
    for i := 0 to j - 1 do begin
	  MailList[i*2] := TempMailList[i*2];
	  MailList[(i*2)+1] := TempMailList[(i*2) + 1];
	  print('Added item with id = ' + IntToStr(MailList[i*2]) + ' with count = ' + IntToStr(MailList[(i*2)+1]));
	end;
	recipentName := GetName_LocalLeader;
	//print('Send mail to ' + recipentName);
    Engine.SendMail(recipentName, 'Thanks for the help', 'I suck big time :D', MailList);
  end;
end;



function DoAllMails(): Boolean;
var
i, j, mailIndex, IDLength: Integer;
TempMailList, MailList: array of Cardinal;
ItemCount: Cardinal;
oItem: Tl2Item;
leaderName: string;
exceptionList: TStringList;
begin
	print('Start Mailing');
	result := false;
	j := 0;
	
	exceptionList := TStringList.Create();
	
	IdLength := Mail_List.Count;
	if (IdLength <= 0) then begin
		print('mail list not found');
		exit;
	end;
	
	leaderName := 'Aristarchus';
	if (leaderName = '') then begin
		Print('no mail leader found');
		exit;
	end;
	
	SetLength(TempMailList, (2 * (IdLength)));
	for i := 0 to IdLength - 1 do begin
		if (Inventory.User.ByID(StrToInt(Mail_List[i]), oItem)) then begin
			if (oItem.ID = 57) then begin
				if (GetSubPartyNum() > 0) then 
					ItemCount := oItem.count - 200000000 //Leave 200 millions for subparties, since they wont get adena by farming'
				else
					ItemCount := oItem.count - 50000000;
					
				if (ItemCount < 30000) then continue;
			end else begin
				ItemCount := oItem.Count;
			end;	  
			if (ItemCount > 0) 
			and not (oItem.Equipped) 
			and (exceptionList.IndexOf(Mail_List[i]) = -1) 
			and ((oItem.ItemType = 5) or (oItem.ItemType = 4)) then begin
				print('Found Item to mail: ' + oItem.Name + ' with count = ' + IntToStr(ItemCount));
				TempMailList[j*2] := StrToInt(Mail_List[i]);
				TempMailList[(j*2)+1] := ItemCount;
				exceptionList.Add(Mail_List[i]);
				Inc(j);
			end;
		end;
	end;  
	print('We found ' + IntToStr(j) + ' items to mail');
	while (j > 0) do begin
	
		if (j <= 8) then begin
			SetLength(MailList, (j*2));
			for i := 0 to j - 1 do begin
				MailList[i*2] := TempMailList[i*2];
				MailList[(i*2)+1] := TempMailList[(i*2) + 1];
			end;
			j := j - 8;
			Engine.SendMail(leaderName, 'Last mail', 'items...', MailList);
			print('Send last Mail with ' + IntToStr(Length(MailList) div 2) + ' items.' );
		end else if (j > 8) then begin
			SetLength(MailList, 16);
			mailIndex := 0;
			for i := j - 8 to j - 1 do begin
				MailList[mailIndex * 2] := TempMailList[i*2];
				MailList[(mailIndex * 2)+1] := TempMailList[(i*2) + 1];
				Inc(mailIndex);
			end;
			j := j - 8;
			Engine.SendMail(leaderName, 'More mails comming...', 'items...', MailList);
			print('Send Mail with ' + IntToStr(Length(MailList) div 2) + ' items.' );
			
		end;
		Delay(20000);
	end;
	
	print('Ended Mailing');
end;

function DoActions: Boolean;
var
caller: Tl2Char;
callerFound: Boolean;
oBuff: Tl2Buff;
callerName: string;
begin
	result := true;
	////Print('DoActions: Started');
	if (Check_AutoRelog) then begin
		Delay(5000);
		//Print('DoActions: Ended 1');
		exit;
	end;
	CheckCreateParty;
	HandleOopBuffing_LeaderTypeOnly;
	
	if IsClass_Bp(User.ClassId) or IsClass_Aeore(User.ClassId) then begin
		if not (WasInParty) then begin
			if (Party.Chars.Count > 0) then begin
				//Reload settings for healers
				PvpLoaded := false;
				PveLoaded := false;
				WasInParty := true;
				Print('Party detected: reload settings');
			end;
		end else begin
			if (Party.Chars.Count <= 0) then WasInParty := false;
		end;
	end;
	
	if (CheckBuffs_L2Idle) then begin
		//Print('DoActions: Ended 2');
		exit;
	end;
	
	if MODE_GOD and CheckRemove_OrbisCurse then begin
		//Print('DoActions: Ended 3');
		exit;
	end;
	//if Check_AvoidBubbles then exit;
	
	if Handle_Pickup_Healer1Only then exit;
	
	CheckDisarm();
	
	if CheckPrevent_CannotSeeTarget() then begin
		//Print('DoActions: Ended 4');
		exit;
	end;
	
	if CheckPickupDrops then begin
		exit;
	end;
	
	if not (GetName_Server = 'Off') then begin
		if IsMissingBuffs then begin
		
			if CombatEnabled and not PauseForBuffs then begin
				PauseForBuffs := true;
				CombatEnabled := false;
			end;
		
			if IsTime_ToRebuff then begin
				Print('Time to rebuff ourself');
				DoRebuff;
				
				if PauseForBuffs then begin
					PauseForBuffs := false;
					CombatEnabled := true;
				end;
				
			end;
			
			//Allow healers to continue
			if not (GetClassValue_Healer(User.ClassId) > 0) then begin
				if not TotalPause then AutoFollow();
				//Print('DoActions: Ended 5');
				exit;
			end;
			
		end else if not User.InCombat and not User.Pvp and not User.PK and not User.Dead 
		and (GetCount_BuffsWithTimeLessThan(1800000) > 20) then begin
			Print('Buffs are low on time, and we are out of combat. Do rebuff');
			DoRebuff;
		end;
		
		if IsTime_ToRebuff_Pet then begin
			print('Time to rebuff pet');
			DoRebuff_Pet;
		end;	
	end;
	
	if DuoPartyMode then begin
		callerName := GetName_LocalLeader;
		callerFound := Party.Chars.ByName(callerName, caller) or CharList.ByName(callerName, caller);
	end else begin
	
		if (CommandSenderList.Count > 0) then
			callerFound := CharList.ByName(CommandSenderList[0], caller)
		else
			callerFound := false;
		
		callerName := caller.Name;
	end;
	
	if (Mode_BashGate and callerFound) then begin
		if CheckBashGate(callerName) then begin
			//Print('DoActions: Ended 6');
			exit;
		end;
	end;
	
	if (AA_GoClose) and callerFound then begin
		Action_GoClose(callerName, 70);
	
	end else if (AA_GoVeryClose) and callerFound then begin
		Action_GoClose(callerName, 20);
	
	end else if (AA_AssistPk) and callerFound then begin
		Action_AssistPk(callerName);
	
	end else
		result := false;
		
		
	
	if CombatEnabled then begin
		if IsClass_Sps(User.ClassId)
		or IsClass_Sorc(User.ClassId)
		or IsClass_Sph(User.ClassId)
		or IsClass_Dagger(User.ClassId)
		or IsClass_Db(User.ClassId) then begin
			if Check_Trigger_TankSeed then begin
				result := true;
			end;
		end;
	end;
		
	
	//Print('DoActions: Ended');
end;

function IsTime_ToRebuff(): Boolean;
var
oBuff: Tl2Effect;
begin
	result := false;
	if (interlude) or (GetName_Server = 'Idle') then exit;
	
	if (user.InCombat or User.PVP or User.PK) or User.Dead then exit;
	
	if (User.Buffs.Count < 18) then begin
		result := true;
		exit;
	end;
	//If no noblesse or Salvation
	if not canBuffNoblesse then begin
		if not User.Buffs.ByID(1323, oBuff) and not User.Buffs.ByID(1410, oBuff) then begin
			result := true;
			exit;
		end;
	end;
end;

function IsMissingBuffs(): Boolean;
var
oBuff: Tl2Effect;
begin
	result := false;
	if (interlude) or (GetName_Server = 'Idle') then exit;
	
	if (User.Buffs.Count < 18) then begin
		result := true;
		exit;
	end;
	//If no noblesse or Salvation
	if not canBuffNoblesse then begin
		if not User.Buffs.ByID(1323, oBuff) and not User.Buffs.ByID(1410, oBuff) then begin
			result := true;
			exit;
		end;
	end;
end;

function CheckCancelCast(skillId: Integer): Boolean;
begin
	result := false;
	
	//Cancel recharge if we are trying to get unflagged.
	if (User.Cast.EndTime > 0) and (User.Cast.Id = skillId) then begin
		Engine.StopCasting();
	end;
end;

function GetCount_BuffsWithTimeLessThan(nTime: Cardinal): Cardinal;
var
oBuff: Tl2Buff;
counter, i : Integer;
begin
	counter := 0;
	for i := 0 to User.Buffs.Count - 1 do begin
		oBuff := User.Buffs.Items(i);
		if (oBuff = nil) then continue;
		if (oBuff.EndTime < nTime) then Inc(counter);
	end;
	result := counter;
end;
function IsAnyoneMissingBuffs_Apocalyps: Boolean;
var
i: Integer;
oTarget: Tl2Char;
oBuff: Tl2Buff;
begin
	result := false;
	for i := 0 to Party.Chars.Count do begin
		if (i = Party.Chars.Count) then oTarget := User
		else oTarget := Party.Chars.Items(i);
		
		if (oTarget = nil) then continue;
		if (not oTarget.Buffs.ById(1323, oBuff) and not oTarget.Buffs.ByID(1410, oBuff)) 
		or (oTarget.Buffs.Count < 15) then begin
			result := true;
			exit;
		end;
	
	end;
end;
function IsTime_ToRebuff_Pet(): Boolean;
var
oBuff: Tl2Effect;
oPet: Tl2Pet;
begin
	result := false;
	if (interlude) or (GetName_Server = 'Idle') then exit;
	
	if (user.InCombat or User.PVP or User.PK) or User.Dead then exit;
	
	if (PetList.Count < 1) then exit;
	oPet := PetList.Items(0);
	if (oPet = nil) or (oPet.Dead) or (not oPet.Valid) then exit;
	
	if (oPet.Buffs.Count < 18) then begin
		result := true;
		exit;
	end;
	//If no noblesse or Salvation
	if not canBuffNoblesse then begin
		if not oPet.Buffs.ByID(1323, oBuff) and not oPet.Buffs.ByID(1410, oBuff) then begin
			result := true;
			exit;
		end;
	end;
end;
(*
function SetAttackTime: Boolean;
var
currentAttackTime: Cardinal;
currentTime: TDateTime;
begin
	result := false;
	
	print('LastAttackTime = ' + IntToStr(LastAttackTime));
	
	currentAttackTime := user.AtkTime;
	print('currentAttackTime = ' + IntToStr(currentAttackTime));
	
	currentTime := now;
	TotalTimePassed := GetMillisecondsInBetween(StartTime, currentTime);
	AttackStartTime := AttackStartTime + (currentTime - StartTime);
	StartTime := currentTime;
	
	print('AttackStartTime = ' + TimeToStr(AttackStartTime));
	print('AttackStartTime in ms= ' + IntToStr(TimeToMs(AttackStartTime)));
	
	//We have made a new attack
	if (currentAttackTime > LastAttackTime) then begin
		if (AttackStartTime >= MsToTime(currentAttackTime)) then
			TimeSinceLastAttack := TimeToMs(AttackStartTime) - currentAttackTime
		else 
			TimeSinceLastAttack := 0;
			
		LastAttackTime := currentAttackTime;
		print('LastAttackTime = ' + IntToStr(LastAttackTime));
		
		
	//We have not attacked since last time, update time since last attack
	end else if (currentAttackTime = LastAttackTime) then begin
		TimeSinceLastAttack := TimeToMs(AttackStartTime) - LastAttackTime;
		print('Time since last attack is ' + IntToStr(TimeSinceLastAttack div 1000));
	end else begin
		print('WARNING ERROR!!! SetAttackTime: Variable Overflow!');
		print('currentAttackTime = ' + IntToStr(currentAttackTime));
		print('TotalTimePassed = ' + IntToStr(TotalTimePassed));
		print('LastAttackTime = ' + IntToStr(LastAttackTime));
		print('TimeSinceLastAttack = ' + IntToStr(TimeSinceLastAttack));
		
	end;
	
	result := true;
end;
*)
function SetPvpStance: Boolean;
var
inPvp: Boolean;
configName: string;
begin
	result := false;
	//Print('SetPvpStance: Started');
	if (TotalPause) then exit;
	
	//Print('SetPvpStance: 2');
	if DiscreteMode and (PlayersNearby) then begin
		//Print('SetPvpStance: Discrete!');
		PvpLoaded := false;
		PveLoaded := false;
		if not DiscreteLoaded then begin
			//Print('SetPvpStance: Discrete entered!');
			DiscreteLoaded := true;
			configName := GetSettingXmlNamePrefix;
			if (configName = '') then begin
				Print('SetPvpStance: GetSettingXmlNamePrefix returned empty');
				exit;
			end;
			//Print('SetPvpStance: Discrete entered 2!');
			cLoadConfig(configName +'_Off.xml');
			Print('Loaded Discrete Settings');
		end;
		//Print('Switched to Discrete/Off Mode');
		Exit;
	end;
	
	//Print('SetPvpStance: 3');
	if LowHpMode then begin
		//Print('SetPvpStance: Low Hp Mode!');
		PvpLoaded := false;
		PveLoaded := false;
		DiscreteLoaded := false;
		if not LowHpSettingLoaded then begin
			if IsClass_ZealotType(User.ClassId) then begin
				Engine.FaceControl(0, false);
			end;
			//Print('SetPvpStance: Low Hp Mode 2!');
			configName := GetSettingXmlNamePrefix;
			if (configName = '') then begin
				Print('SetPvpStance: GetSettingXmlNamePrefix returned empty');
				exit;
			end;
			//Print('SetPvpStance: Low Hp Mode 3!');
			cLoadConfig(configName +'_LowHp.xml');
			//Print('SetPvpStance: Low Hp Mode 4!');
			LowHpSettingLoaded := true;
			Engine.AutoSoulShot('Soulshot (S-Grade)', false);
			Print('Loaded Low Hp Settings');
		end;
		Exit;
	end;
	
	//Print('SetPvpStance: 4');
	if LowHpSettingLoaded then begin
		Print('Left LowHpMode, reload soulshots, and possibly interface control');
		Engine.AutoSoulShot('Soulshot (S-Grade)', true);
		if not TempOff and not TotalPause then
			Engine.FaceControl(0, true);
	end;
	
	
	
	
	
	//Print('SetPvpStance: is in pvp?');
	inPvp := IsInPvp;
	//Print('SetPvpStance: is in pvp? passed');
	if (inPvp) and not PvpLoaded then begin
		//Print('SetPvpStance: Pvp 1');
		PvpLoaded := true;
		PveLoaded := false;
		//Print('SetPvpStance: Pvp 2');
		configName := GetSettingXmlNamePrefix;
			if (configName = '') then begin
				Print('SetPvpStance: GetSettingXmlNamePrefix returned empty');
				exit;
			end;
		//Print('SetPvpStance: Pvp 3');
		cLoadConfig(configName +'_PvP.xml');
		Print('Switched to Pvp Mode');
		DiscreteLoaded := false;
		LowHpSettingLoaded := false;
	end else if (not inPvp) and not PveLoaded then begin
		PvpLoaded := false;
		PveLoaded := true;
		//Print('SetPvpStance: ---- 1');
		configName := GetSettingXmlNamePrefix;
			if (configName = '') then begin
				Print('SetPvpStance: GetSettingXmlNamePrefix returned empty');
				exit;
			end;
		//Print('SetPvpStance: ---- 2');
		if not AOE_ENABLED then begin
			if not LoadSingleTargetConfig(configName) then cLoadConfig(configName +'_Pve.xml');
		end else begin
			cLoadConfig(configName +'_Pve.xml');
			Print('Switched to Pve Mode');
		end;
		DiscreteLoaded := false;
		LowHpSettingLoaded := false;
	end;
	
	//Print('SetPvpStance: Ended!');
	result := true;
end;
function LoadSingleTargetConfig(configName: string): Boolean;
begin
	result := false;
	if (configName = '') then exit;
	
	if IsClass_Sorc(User.ClassId) 
	or IsClass_Sps(User.ClassID) 
	//or IsClass_Tyrant(User.ClassID) already only single target
	//or IsClass_Db(User.ClassID)already only single target
	or IsClass_Wl(User.ClassID) 
	or IsClass_Ol(User.ClassID)
	//or IsClass_Gh(User.ClassID) already single
	or IsClass_Slh(User.ClassID) then begin
		result := cLoadConfig(configName +'_Single.xml');
	end;
	
end;
function IsInPvp: Boolean;
//checked
var
i, x, y, TempX, TempY: Integer;
oTarget: Tl2Char;
begin
	//print('IsInPvp: Started');
	result := false;
	if not(PvpEnabled) then Exit;
	
	//print('IsInPvp: entered');
	
	for i := 0 to CharList.Count - 1 do begin
		//Print('IsInPvp: for loop: start');
		oTarget := CharList.Items(i);
		//Print('IsInPvp: for loop: took target');
		if (oTarget = nil) then begin
			Continue;
		end;
		
		//print('IsInPvp: Checking: ' + oTarget.Name);
	
		x := oTarget.x;
		y := oTarget.Y;
		TempX := PT_PX;
		TempY := PT_PY;
		if (GetDistanceBetweenPoints(TempX, TempY, x, y) > MAX_RANGE_PVP_SEARCH) then continue;
		
		//print('IsInPvp: not too far away');
		if (IsTarget_Pvp(oTarget)) then begin
			result := true;
			//Print('IsInPvp: Ended succesfully');
			Exit;
		end;
		//print('IsInPvp: ' + oTarget.Name + ' was not a pvp target');
	end;
	//Print('IsInPvp: Ended unseccesfully');
end;


function LockCheck_MoveAndBot_Off: Boolean;
begin
	result := false;
	if (TempOff) or IsMoving or MoveLock then Exit;
	
	if (Engine.GetFaceState(0)) then begin
		Engine.FaceControl(0, false);
		TempOff := true;
	end;
	IsMoving := true;
	MoveLock := true;
	
	
	result := true;
end;
function LockCheck_MoveAndBot_On: Boolean;
begin
	result := false;
	
	if (MoveLock) then begin
		if (TempOff) then begin
			Engine.FaceControl(0, true);
			TempOff := false;
		end;
		IsMoving := false;
		MoveLock := false;
		
		result := true;
	end;
end;

function WaitForCasting: void;
var
castTime: Cardinal;
begin
	while (User.Cast.EndTime > 0) do begin
		castTime := User.Cast.EndTime;
		if (castTime > 60000) then begin
			Print('Abnormal casting time detected, escape!');
			exit;
		end else if (castTime > 1000) and (castTime <= 60000) then begin
			Delay(950);
		end else if (castTime > 100) and (castTime <= 1000) then begin
			Delay(95);
		end else if (castTime > 0) and (castTime <= 100) then begin
			Delay(20);
		end;
	end;
end;

function MoveTo_AoePoint(rangeToPoint: Integer = 100; disableBot: Boolean = true): Boolean;
var
BotWasOn: Boolean;
z, counter : Integer;
begin
	result := false;
	if not (IsAoePoint_Valid) then exit;
	
	BotWasOn := Engine.GetFaceState(0);
	if disableBot and (BotWasOn) and not MovingTo_AoePoint then begin
		MovingTo_AoePoint := true;
		Engine.FaceControl(0, false);
	end;
	z := User.Z;
	if not (User.Target.Oid = user.Oid) then
		Engine.SetTarget(User);
	if (FOLLOW_DELAY <=	0) then begin
		counter := 0;
		while (User.DistTo(AOE_PX, AOE_PY, z) > rangeToPoint) do begin
			MoveTo_Timer(AOE_PX, AOE_PY, z);
			Delay(100);
			counter := counter + 1;
			if (counter >= 2) then break;
		end;
	end else begin
		MoveTo_Timer(AOE_PX, AOE_PY, z);
	end;
	z := User.Z;
	result := User.InRange(AOE_PX, AOE_PY, z, rangeToPoint);
end;

function MoveTo_AoeAgroPoint(rangeToPoint: Integer = 100): Boolean;
var
BotWasOn: Boolean;
z, counter : Integer;
begin
	result := false;
	if not (IsAoeAgroPoint_Valid) then exit;
	
	if not (User.Target.Oid = user.Oid) then
		Engine.SetTarget(User);
		
	if (FOLLOW_DELAY <=	0) then begin
		counter := 0;
		z := User.Z;
		while (User.DistTo(AOEAGRO_PX, AOEAGRO_PY, z) > rangeToPoint) do begin
			MoveTo_Timer(AOEAGRO_PX, AOEAGRO_PY, z);
			Delay(100);
			counter := counter + 1;
			if (counter >= 2) then break;
			z := User.Z;
		end;
	end else begin
		z := User.Z;
		MoveTo_Timer(AOEAGRO_PX, AOEAGRO_PY, z);
	end;
	z := User.Z;
	result := (User.DistTo(AOEAGRO_PX, AOEAGRO_PY, z) < rangeToPoint);
end;
function MoveTo_AoePoint_RestoreSettings: void;
begin
	if MovingTo_AoePoint then begin
		MovingTo_AoePoint := false;
		Engine.FaceControl(0, true);
	end;
end;
(* before changes
function MoveTo_AoePoint(rangeToPoint: Integer = 100): Boolean;
var
BotWasOn: Boolean;
z, counter : Integer;
begin
	result := false;
	if not (IsAoePoint_Valid) or IsMoving or TempOff then exit;
	BotWasOn := Engine.GetFaceState(0);
	if (BotWasOn) and not (TempOff) and not IsMoving then begin
		TempOff := true;
		IsMoving := true;
		Engine.FaceControl(0, false);
	end;
	z := User.Z;
	if not (User.Target.Oid = user.Oid) then
		Engine.SetTarget(User);
	if (FOLLOW_DELAY <=	0) then begin
		counter := 0;
		while (User.DistTo(AOE_PX, AOE_PY, z) > rangeToPoint) do begin
			MoveTo_Timer(AOE_PX, AOE_PY, z);
			Delay(200);
			counter := counter + 1;
			if (counter >= 3) then break;
		end;
	end else begin
		MoveTo_Timer(AOE_PX, AOE_PY, z);
	end;
	if (BotWasOn) and TempOff and IsMoving then begin
		TempOff := false;
		IsMoving := false;
		Engine.FaceControl(0, true);
	end;
	z := User.Z;
	result := User.InRange(AOE_PX, AOE_PY, z, rangeToPoint);
end;*)


function MoveTo_AoePoint_WaitForFinish(rangeToPoint: Integer = 100): Boolean;
var
BotWasOn: Boolean;
z, counter : Integer;
begin
	result := false;
	if not (IsAoePoint_Valid) then exit;
	
	BotWasOn := Engine.GetFaceState(0);
	if (BotWasOn) and not MovingTo_AoePoint then begin
		MovingTo_AoePoint := true;
		Engine.FaceControl(0, false);
	end;
	
	if not (User.Target.Oid = user.Oid) then
		Engine.SetTarget(User);
		
	counter := 0;
	while (User.DistTo(AOE_PX, AOE_PY, z) > rangeToPoint)
	and (not User.Dead) do begin
		z := User.Z;
		MoveTo_Timer(AOE_PX, AOE_PY, z);
		Delay(100);
			
		//Escape if it is no longer time to Aoe
		if IsTime_ToAoe then SetPoint_AoePosition
		else break;
		
			
		counter := counter + 1;
		if (counter >= 25) then break; //Break after 25*100 ms = 2500 ms = 2,5 seconds
	end;

	if MovingTo_AoePoint then begin
		MovingTo_AoePoint := false;
		Engine.FaceControl(0, true);
	end;
	
	z := User.Z;
	result := User.InRange(AOE_PX, AOE_PY, z, rangeToPoint);
end;

function MoveTo_AoePoint_Continuous(rangeToPoint: Integer = 100): Boolean;
var
BotWasOn: Boolean;
z, counter : Integer;
begin
	result := false;
	if not (IsAoePoint_Valid) then exit;
	
	if not (User.Target.Oid = user.Oid) then
		Engine.SetTarget(User);
		
	z := User.Z;
	MoveTo_Timer(AOE_PX, AOE_PY, z);

	result := User.InRange(AOE_PX, AOE_PY, z, rangeToPoint);
end;

function SetDistance_AoePointDistance: void;
var
z : Integer;
begin
	if not IsAoePoint_Valid then begin
		AOE_PT_DIST := 0;
		Print('Warning! AoePoint Distance is setto 0');
	end else begin
		z := User.z;
		AOE_PT_DIST := User.DistTo(AOE_PX, AOE_PY, z);
	end;
end;
function SetDistance_AoeAgroPointDistance: void;
var
z : Integer;
begin
	if not IsAoeAgroPoint_Valid then begin
		AOEAGRO_PT_DIST := 0;
		Print('Warning! AoeAgroPoint Distance is set to 0');
	end else begin
		z := User.z;
		AOEAGRO_PT_DIST := User.DistTo(AOEAGRO_PX, AOEAGRO_PY, z);
	end;
end;

function IsAoePoint_Valid: Boolean;
begin
	if (AOE_PX = 0) and (AOE_PY = 0) then result := false
	else result := true;
end;

function IsAoeAgroPoint_Valid: Boolean;
begin
	if (AOEAGRO_PX = 0) and (AOEAGRO_PY = 0) then result := false
	else result := true;
end;


function IsSkillReady_OtherBotChar(skillId: Integer; sCharName: string; hpCost: Integer = 0; mpCost: Integer = 0): Boolean;
//checked
var
nEndTime: Integer;
oSkill: Tl2Skill;
oOtherChar: Tl2Char;
control: Tl2Control;
begin
	//print('IsSkillReady_OtherBotChar: Started, checking ' + sCharName + ', for skill = ' + IntToStr(skillID));
	result := false;
	control := getControl(sCharName);
	  
	if CharList.ByName(sCharName, oOtherChar)
	and (assigned(control)) then begin
	//print('IsSkillReady_OtherBotChar: Assigned: ' + oOtherChar.Name);
	
		if (hpCost > 0) then begin
			if (control.GetUser.CurHp < hpCost) then exit;
		end;
		if (mpCost > 0) then begin
			if (control.GetUser.CurMp < mpCost) then exit;
		end;
	
		if (skillID = 1409) then begin //Check cleanse item...
			if not HasItem_MinCount(control, 8874, 1) then exit;
		end;
	
		oSkill := nil;
		control.GetSkillList.ByID(skillId, oSkill);
		
		if (oSkill = nil) or (oSkill.Disabled) then begin 
			WriteError('IsOtherBotChar_SkillReady: oSkill = nil 1.');
			Exit;
		end;
		nEndTime := oSkill.EndTime;
		if ((nEndTime = 0) or (nEndTime >= 760000))
		or (oOtherChar.cast.Id = skillId) and (oOtherChar.Cast.EndTime > 0) then begin
		  result := True;
		  //print('IsOtherBotChar_SkillReady: result is true, ' + sCharName + ' has skill ready!');
		end;
	end;
end;


function GetSkill_OnOtherBotChar(skillId: Integer; sCharName: string): Tl2Skill;
//checked
var
nEndTime: Integer;
oSkill: Tl2Skill;
oOtherChar: Tl2Char;
control: Tl2Control;
begin
	//print('IsSkillReady_OtherBotChar: Started, checking ' + sCharName + ', for skill = ' + IntToStr(skillID));
	result := nil;
	control := getControl(sCharName);
	  
	if CharList.ByName(sCharName, oOtherChar)
	and (assigned(control)) then begin
	//print('IsSkillReady_OtherBotChar: Assigned: ' + oOtherChar.Name);
	
		oSkill := nil;
		if control.GetSkillList.ByID(skillId, oSkill) then begin
		
			if (oSkill = nil) or (oSkill.Disabled) then begin 
				WriteError('GetSkill_OnOtherBotChar: oSkill = nil 1.');
				Exit;
			end;
			result := oSkill;
		end;
	end;
end;

function IsSkillReady(skillID: Integer): Boolean; Overload;
var
skill: Tl2Skill;
begin
	result := false;
	if not (SkillList.ByID(skillID, skill)) then exit;
	
	if (skill.EndTime <= 0) or (skill.EndTime > 7600000) then result := true;
end;
function IsSkillReady(skillID: Integer; control: Tl2Control): Boolean; Overload;
var
skill: Tl2Skill;
begin
	result := false;
	if Assigned(control) then begin
		if not (control.GetSkillList.ByID(skillID, skill)) then exit;
		
		if (skill.EndTime <= 0) or (skill.EndTime > 7600000) then result := true;
	end;
end;

function SetPoint_AoeAgroPosition(): TPoint;
var
pt: TPoint;
begin
	pt := Point(0, 0);
	if (PvpLoaded = null) then WriteError('CalculateBestAoePosition: PvpLoaded = nil');
	if (PvpLoaded) then 
		pt := GetPoint_AoeAgroPosition_Pvp
	else 
		pt := GetPoint_AoeAgroPosition_Pve;  

	AOEAGRO_PX := pt.X;
	AOEAGRO_PY := pt.Y;
	result := pt;
end;
function SetPoint_AoePosition(onlyAgroed: Boolean = false; AoeRange: Integer = 0): TPoint;
var
pt: TPoint;
temp: Integer;
begin
	pt := Point(0, 0);
	if (PvpLoaded = null) then WriteError('CalculateBestAoePosition: PvpLoaded = nil');
	
	if (AoeRange > 0) then begin
		temp := MAX_RANGE_AOE;
		MAX_RANGE_AOE := AoeRange;
	end;
	
	if (PvpLoaded) then 
		pt := GetPoint_AoePosition_Pvp
	else 
		pt := GetPoint_AoePosition_Pve(onlyAgroed);  

	AOE_PX := pt.X;
	AOE_PY := pt.Y;
	
	if (AoeRange > 0) then begin
		MAX_RANGE_AOE := temp;
	end;
	
	result := pt;
end;

function GetPoint_AoePosition_Pvp: TPoint;
var
oTarget, oCenterTarget, cchar: Tl2Char;
i, EndX, EndY, nDivider: Integer;
begin
	result := Point(0, 0);
	EndX := 0;
	EndY := 0;
	nDivider := 0;
  
	oCenterTarget := GetTarget_MostClustered_Char;
	if not IsTarget_ValidAndVisible_Char(oCenterTarget) then begin
		Exit;
	end;
	
	//Investigate all enemies within range of 1k
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) then begin
			WriteError('CalculateBestAoePosition_Pvp: oTarget = nil');
			Continue;
		end;
		if (User.DistTo(oTarget) > MAX_RANGE_PVP_SEARCH + MAX_RANGE_AOE) then break;
		if (oCenterTarget.DistTo(oTarget) > (MAX_RANGE_AOE + 75))
		or not (IsTarget_Valid_Char(oTarget)) then Continue;
	
		EndX := EndX + oTarget.X;
		EndY := EndY + oTarget.Y;
		nDivider := nDivider + 1;
	end;

	AoePoint_ClusterCount := nDivider;
	if (nDivider > 1) then begin
		EndX := EndX div nDivider;
		EndY := EndY div nDivider;
	end;
  
	if (EndX = 0) and (EndY = 0) then begin
		result := Point(0, 0);
	end else begin
		result := Point(EndX, EndY);
	end;
end;

function GetPoint_AoePosition_Pve(onlyAgroed: Boolean = false): TPoint;
var
oTarget, oCenterTarget, temp: Tl2Live;
i, EndX, EndY, nDivider, x, y: Integer;
begin
  result := Point(0, 0);
  EndX := 0;
  EndY := 0;
  nDivider := 0;
  oCenterTarget := GetTarget_MostClustered_Live(onlyAgroed);
  if not IsTarget_ValidAndVisible_Live(oCenterTarget) then begin
    Exit;
  end;

  //Investigate all enemies within range of 1k
  for i := 0 to NpcList.Count - 1 do begin
    oTarget := NpcList.Items(i);
	if (oTarget = nil) then begin
	  WriteError('CalculateBestAoePosition_Pve: oTarget = nil');
	  Continue;
	end;
	if (User.DistTo(oTarget) > MAX_RANGE_NPC_SEARCH) then break;
	if (oCenterTarget.DistTo(oTarget) > (MAX_RANGE_AOE + 25))
	or not (IsTarget_Valid_Live(oTarget)) then Continue;
	
	EndX := EndX + oTarget.X;
	EndY := EndY + oTarget.Y;
	nDivider := nDivider + 1;
  end;

	AoePoint_ClusterCount := nDivider;
	if (nDivider > 1) then begin
		EndX := EndX div nDivider;
		EndY := EndY div nDivider;
	end;
	if (EndX = 0) and (EndY = 0) then begin
		WriteError('CalculateBestAoePosition_Pve: Point = (0, 0)');
		result := Point(0, 0);
	end else begin
		result := Point(EndX, EndY);
	end;
end;


function GetPoint_AoeAgroPosition_Pve(): TPoint;
var
oTarget, oCenterTarget, temp: Tl2Live;
i, EndX, EndY, nDivider, x, y: Integer;
begin
	result := Point(0, 0);
	EndX := 0;
	EndY := 0;
	nDivider := 0;
	oCenterTarget := GetTarget_MostClusteredToAgro_Live();
	if not IsTarget_ValidAndVisible_Live(oCenterTarget) then begin
		Exit;
	end;
	
	//Investigate all enemies close to center target
	for i := 0 to NpcList.Count - 1 do begin
		oTarget := NpcList.Items(i);
		if (oTarget = nil) then begin
			WriteError('CalculateBestAoePosition_Pve: oTarget = nil');
			Continue;
		end;
		
		if (User.DistTo(oTarget) > MAX_RANGE_TOAGRO) then break;
		if (oCenterTarget.DistTo(oTarget) > (SIGEL_AOE_AGRO_RANGE + 50))
		or not (IsTarget_Valid_Live(oTarget)) then Continue;
		
		if (IsTarget_AttackingTarget_Live(oTarget, User)) then continue;
		
		EndX := EndX + oTarget.X;
		EndY := EndY + oTarget.Y;
		nDivider := nDivider + 1;
	end;
	AoePoint_ClusterCount := nDivider;
	if (nDivider > 1) then begin
		EndX := EndX div nDivider;
		EndY := EndY div nDivider;
	end;
	if (EndX = 0) and (EndY = 0) then begin
		WriteError('CalculateBestAoePosition_Pve: Point = (0, 0)');
		result := Point(0, 0);
	end else begin
		result := Point(EndX, EndY);
	end;
end;

function GetPoint_AoeAgroPosition_Pvp(): TPoint;
var
oTarget, oCenterTarget: Tl2Char;
oTargetsTarget: Tl2Live;
i, EndX, EndY, nDivider, x, y: Integer;
begin
	result := Point(0, 0);
	EndX := 0;
	EndY := 0;
	nDivider := 0;
	oCenterTarget := GetTarget_MostClusteredToAgro_Char();
	if not IsTarget_ValidAndVisible_Live(oCenterTarget) then begin
		Exit;
	end;
	
	//Investigate all enemies close to center target
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) then begin
			WriteError('CalculateBestAoePosition_Pve: oTarget = nil');
			Continue;
		end;
		
		if (User.DistTo(oTarget) > MAX_RANGE_PVP_SEARCH) then break;
		if (oCenterTarget.DistTo(oTarget) > (SIGEL_AOE_AGRO_RANGE + 50))
		or not (IsTarget_Valid_Char(oTarget)) then Continue;
		
		oTargetsTarget := oTarget.Target;
		if (oTargetsTarget = nil) then continue;
		
		if not (oTargetsTarget is Tl2Char) then continue;
		
		if IsClass_Tank((Tl2Char(oTargetsTarget)).ClassId) 
		or not IsTarget_OnUs_Char(oTarget) then continue;

		
		EndX := EndX + oTarget.X;
		EndY := EndY + oTarget.Y;
		nDivider := nDivider + 1;
	end;
	AoePoint_ClusterCount := nDivider;
	if (nDivider > 1) then begin
		EndX := EndX div nDivider;
		EndY := EndY div nDivider;
	end;
	if (EndX = 0) and (EndY = 0) then begin
		WriteError('CalculateBestAoePosition_Pve: Point = (0, 0)');
		result := Point(0, 0);
	end else begin
		result := Point(EndX, EndY);
	end;
end;


function IsTime_ToAoe: Boolean;
begin
	result := false;
	if not AOE_ENABLED then exit;
	if IsClass_Necro(User.ClassId) then exit;
	
	if (PvpLoaded = null) then WriteError('IsTime_ToAoe: PvpLoaded = null');
	if (PvpLoaded) then 
		result := IsTime_ToAoe_Pvp
	else 
		result := IsTime_ToAoe_Pve;
end;

function IsTime_ToAoe_Pvp: Boolean;
var
oTarget, oTarget2: Tl2Char;
i, j, searchRange, dist1, count, minClusterCount: Integer;
begin
	result := false;
	if not AOE_ENABLED_PVP then exit;
  
	searchRange := 650;
	count := 0;
	minClusterCount := 5;
	for i := 0 to CharList.Count-2 do begin
		oTarget := CharList.Items(i);
		
		if (oTarget = nil) then begin
		  WriteError('IsTime_ToAoe_Pvp: oTarget = nil');
		  Continue;
		end;
		dist1 := User.DistTo(oTarget);
		if (dist1 > searchRange) then break;
		if not (IsTarget_Valid_Char(oTarget)) then continue;
		
		count := 0;
		
		for j := (i + 1) to CharList.Count-1 do begin
			if (j = i) then Continue;
			oTarget2 := CharList.Items(j);
			if (oTarget2 = nil) then begin
				WriteError('IsTime_ToAoe_Pvp: oTarget2 = nil');
				Continue;
			end;
			
			if (User.DistTo(oTarget2) > searchRange + MAX_RANGE_AOE) then break;
			
			if (oTarget.DistTo(oTarget2) <= MAX_RANGE_AOE) 
			and (IsTarget_Valid_Char(oTarget2)) then begin
				count := count + 1;
			end;
		end; 
		if (count >= minClusterCount) then begin
			result := true;
			//print('Time to aoe true - Target count = ' + IntToStr(count));
			exit;
		end;
	end;
end;
(*
function UseRangedAoeSkill(SkillId, SkillRange, SkillRadius: Cardinal; Cooldown: Cardinal = 0): Boolean;
var
oTarget: Tl2Char;
begin
	result := false;
	
	if not HasSkill_Ready(SkillId) then exit;
	
	
	
	
	result := true;
end;
*)


function IsTime_ToAoe_Pve: Boolean;
var
oTarget, oTarget2: Tl2Live;
i, j, counter: Integer;
begin
  result := false;
  if not AOE_ENABLED_PVE then exit;
  counter := 0;
  
  for i := 0 to NpcList.Count-1 do begin
    oTarget := NpcList.Items(i);
	
	if (oTarget = nil) then begin
	  WriteError('IsTime_ToAoe_Pve: oTarget = nil, solved?');
	  Continue;
	end;
	if (User.DistTo(oTarget) > 650) then break;
	if not (IsTarget_Valid_Live(oTarget))
	or not IsTarget_OnUs_Live(oTarget) then continue;
	
	if (GetCount_EnemiesNearTarget_Pve_Live(oTarget) > 2) then begin
		result := true;
		Exit;
	end;
	(*
	for j := 0 to NpcList.Count-1 do begin
	  if (j = i) then Continue;
	  oTarget2 := NpcList.Items(j);
	  if (oTarget2 = nil) then begin
	    WriteError('IsTime_ToAoe_Pve: oTarget2 = nil');
	    Continue;
	  end;
	  if (oTarget = nil) then begin
	    WriteError('IsTime_ToAoe_Pve: oTarget = nil');
	    Continue;
	  end;
	  if (oTarget.DistTo(oTarget2) <= MAX_RANGE_AOE) 
	  and (IsTarget_Valid_Live(oTarget2)) then begin
	    Inc(counter);
	  end;
	end;*) 
  end;
end;

function CheckUse_AoeSkill_Nuker: Boolean;
var
botWasOn: Boolean;
begin
	//botWasOn := Engine.GetFaceState(0);
	//if botWasOn then Engine.FaceControl(0, false);
	result := CheckUse_AoeSkill_Nuker_Pvp;
	//if botWasOn then Engine.FaceControl(0, true);
end;

function CheckUse_AoeSkill_Nuker_Pvp: Boolean;
var
myClass, dist: Integer;
castLongRange, classSorcerer, classSpellsinger: Boolean;
begin
	result := false;
	myClass := User.ClassId;
	castLongRange := false;
	classSorcerer := false;
	classSpellsinger := false;
	dist := 0;
	
	if IsClass_Sorc(myClass) then classSorcerer := true
	else if IsClass_Sps(myClass) then classSpellsinger := true
	else begin
		Print('CheckUse_AoeSkill_Nuker: Error - class not recognized!');
		exit;
	end;
	//Has any long range aoe-attacks ready?
	if (IsClass_Sorc(myClass)) then begin
		if HasSkill_Ready(1467) //Meteor has 600 range
		or HasSkill_Ready(1554) //Aura Blast has 900 range
		or HasSkill_Ready(1296) then //Rain of Fire has 500 range
			castLongRange := true;
	end else if IsClass_Sps(myClass) then begin
		if HasSkill_Ready(1468) //Star Fall has 600 range
		or HasSkill_Ready(1554) //Aura Blast has 900 range
		or HasSkill_Ready(1295) then //Aqua Splash has 500 range
			castLongRange := true;
	end;
	//Close range aoe attacks
	SetPoint_AoePosition;
	if not IsAoePoint_Valid then begin
		Print('CheckUse_AoeSkill_Nuker: Error - Failed to set aoe point');
		exit;
	end;
	SetDistance_AoePointDistance;
	
	if castLongRange 
	and (AOE_PT_DIST > 150) 
	and SetTarget_MostClustered_Pvp then begin
	
		//Long range aoe attacks
		dist := User.DistTo(User.Target);
		if (dist <= 0) then begin
			Print('CheckUse_AoeSkill_Nuker: Error - distance was 0');
			exit;
		end;
		
		if classSorcerer then begin
			//Sorcerer Long range aoe attack
			if (dist > 650) and HasSkill_Ready(1554) then begin //Aura Blast, from far distance
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if HasSkill_Ready(1467) then begin // Meteor
				result := Engine.DUseSkill(1467, true, false);
				exit;
			end else if (HasSkill_Ready(1554)) then begin //Aura Blast, regardless of range
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if (dist > 300) and (HasSkill_Ready(1296)) then begin //Rain of fire
				result := Engine.DUseSkill(1296, true, false);
				exit;
			end;
			
		end else if classSpellsinger then begin
			//Spellsinger Long range aoe attack
			if (dist > 650) and HasSkill_Ready(1554) then begin //Aura Blast, from far distance
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if HasSkill_Ready(1468) then begin // Star Fall
				result := Engine.DUseSkill(1468, true, false);
				exit;
			end else if (HasSkill_Ready(1554)) then begin //Aura Blast, regardless of range
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if (dist > 300) and (HasSkill_Ready(1295)) then begin //Aqua Splash
				result := Engine.DUseSkill(1295, true, false);
				exit;
			end;
			
		end;
	
	end;
		
	if (AOE_PT_DIST > 120) then begin
		MoveTo_AoePoint(70, false); //Dont disable bot from here, since we are already attack paused. 
		result := true;
		exit; 
	end;
		
	if SetTarget_Nearest_Pvp then begin
		if classSorcerer then begin
			//Sorcerer close range aoe attack
			if HasSkill_Ready(1467) then begin // Meteor
				result := Engine.DUseSkill(1467, true, false);
				exit;
			end else if (HasSkill_Ready(1554)) then begin //Aura Blast
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if HasSkill_Ready(1417) then begin //Aura Flash
				result := Engine.DUseSkill(1417, true, false);
				exit;
			end else if HasSkill_Ready(1171) then begin // Blazing Circle
				result := Engine.DUseSkill(1171, true, false);
				exit;
			end else if (HasSkill_Ready(1296)) then begin //Rain of fire
				result := Engine.DUseSkill(1296, true, false);
				exit;
			end;
			
		end else if classSpellsinger then begin
			//Spellsinger close range aoe attack
			if HasSkill_Ready(1468) then begin // Star Fall
				result := Engine.DUseSkill(1468, true, false);
				exit;
			end else if (HasSkill_Ready(1554)) then begin //Aura Blast
				result := Engine.DUseSkill(1554, true, false);
				exit;
			end else if HasSkill_Ready(1417) then begin //Aura Flash
				result := Engine.DUseSkill(1417, true, false);
				exit;
			end else if HasSkill_Ready(1454) then begin // Diamond Dust
				result := Engine.DUseSkill(1454, true, false);
				exit;
			end else if (HasSkill_Ready(1174)) then begin //Frost Wall
				result := Engine.DUseSkill(1174, true, false);
				exit;
			end else if (HasSkill_Ready(1295)) then begin //Aqua Splash
				result := Engine.DUseSkill(1295, true, false);
				exit;
			end;
				
		end;
	end;
	
end;


function CheckUse_Fear_Pvp(maxRange: Integer = 5000): Boolean;
//checked
var
oTarget: Tl2Char;
attackWasOn: Boolean;
begin
	result := false;
	
	if not IsClass_Necro(User.ClassId) and not FEAR_ENABLED then exit;
	
	if not HasSkill_Ready(1169) then exit;
	oTarget := GetTarget_ToFear_Pvp(maxRange);
	if (oTarget.Oid = User.Oid) or (oTarget = nil) or not IsTarget_ValidAndVisible_Char(oTarget) then Exit;
	
	attackWasOn := Engine.GetFaceState(1); //Attacks enabled?
	if attackWasOn then begin
		Engine.FaceControl(1, false);
	end;
	//Wait for casting to finish
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 3000) do Delay(175);
	while (User.Cast.EndTime > 0) and (User.Cast.EndTime < 210) do Delay(20);
	
	if not (User.Target = oTarget) then begin
		Engine.SetTarget(oTarget);
	end;
	result := Engine.DUseSkill(1169, true, false); //Curse Fear 
	
	if attackWasOn then begin
		Engine.FaceControl(1, true);
	end;
	
end;


function CheckUse_Fear_Pvp_GOD(maxRange: Integer = 5000): Boolean;
//checked
var
oTarget: Tl2Char;
attackWasOn: Boolean;
begin
	result := false;
	
	if not HasSkill_Ready(11055) then exit;
	oTarget := GetTarget_ToFear_Pvp(maxRange);
	if (oTarget.Oid = User.Oid) or (oTarget = nil) or not IsTarget_ValidAndVisible_Char(oTarget) then Exit;
	
	attackWasOn := Engine.GetFaceState(1); //Attacks enabled?
	if attackWasOn then begin
		Engine.FaceControl(1, false);
	end;
	//Wait for casting to finish
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 3000) do Delay(175);
	while (User.Cast.EndTime > 0) and (User.Cast.EndTime < 210) do Delay(20);
	
	if not (User.Target = oTarget) then begin
		Engine.SetTarget(oTarget);
	end;
	
	result := Engine.DUseSkill(11055, true, false); //Death Fear 
	
	if attackWasOn then begin
		Engine.FaceControl(1, true);
	end;
	
end;

function UseSkill_Safe(SkillId: Integer; oTarget: Tl2Live = nil; IsAttackSkill: Boolean = true; UseForUser: Boolean = false): Boolean; Overload;
var
interfaceWasOn: Boolean;
begin
	result := false;
	
	if not HasSkill_Ready(SkillId) then exit;
	
	if IsAttackSkill then begin
		interfaceWasOn := Engine.GetFaceState(1); //Attacks enabled?
	end else begin
		interfaceWasOn := Engine.GetFaceState(2) or Engine.GetFaceState(3); //Heal/Buff enabled?
	end;
	if interfaceWasOn then begin
		if (IsAttackSkill) then begin
			Engine.FaceControl(1, false);
		end else begin
			Engine.FaceControl(2, false);
			Engine.FaceControl(3, false);
		end;
	end;
	
	//Wait for any casting to finish
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 3000) do Delay(175);
	while (User.Cast.EndTime > 0) and (User.Cast.EndTime < 210) do Delay(20);
	
	if UseForUser then begin
		if (oTarget.Oid = User.Oid) 
		and not (User.Target.Oid = user.Oid) then Engine.SetTarget(User);
		
	end else if not (oTarget = nil) 
	and not (oTarget.Oid = User.Oid)
	and not (User.Target = oTarget) then begin
		Engine.SetTarget(oTarget);
	end;
	
	result := Engine.DUseSkill(SkillId, true, false);
	
	if interfaceWasOn then begin
		if (IsAttackSkill) then begin
			Engine.FaceControl(1, true);
		end else begin
			Engine.FaceControl(2, true);
			Engine.FaceControl(3, true);
		end;
	end;
	
end;

function UseSkill_Safe(SkillId: Integer; oTarget: Tl2Char = nil; IsAttackSkill: Boolean = true; UseForUser: Boolean = false): Boolean; Overload;
begin
	result := UseSkill_Safe(SkillId, (oTarget as Tl2Live), IsAttackSkill, UseForUser)
end;

function CheckUse_MassBlockWindWalk: Boolean;
var
maxRange: Integer;
begin
	//GetTarget_Char(EvalFunc: TEvaluateCharFunction; maxRange: Integer): Tl2Char; Overload;
	result := false;
	maxRange := 200;
	if TimerEx(Timer_BlockWw, SKILL_CD_MASS_BLOCK_WW) and not (GetTarget_Char(EvaluateChar_Valid, maxRange) = nil) then begin
		result := Engine.DUseSkill(1361, true, false);
	end;
end;

function CheckUse_AuraFlash: Boolean;
var
maxRange: Integer;
begin
	//GetTarget_Char(EvalFunc: TEvaluateCharFunction; maxRange: Integer): Tl2Char; Overload;
	result := false;
	maxRange := 200;
	if not (HasSkill_Ready(1417)) then exit;
	if not (GetTarget_Char(EvaluateChar_ValidNotDisabled, maxRange) = nil) then begin
		result := Engine.DUseSkill(1417, true, false);
	end;
end;

function CheckUse_DeathHowl: Boolean;
var
maxRange: Integer;
begin
	//GetTarget_Char(EvalFunc: TEvaluateCharFunction; maxRange: Integer): Tl2Char; Overload;
	result := false;
	maxRange := 200;
	if not (HasSkill_Ready(11032)) then exit;
	if not (GetTarget_Char(EvaluateChar_ValidNotDisabled, maxRange) = nil) then begin
		result := Engine.DUseSkill(11032, true, false);
	end;
end;

function CheckUse_DeathMark(): Boolean;
var
ma: Tl2Char;
oLiveTarget: Tl2Live;
begin
	result := false;
	
	//Check main assist's target for death mark
	if HasSkill_Ready(1435) then begin
	
		ma := GetTarget_MainAssist;
		oLiveTarget := ma.Target;
		if not (ma = nil)
		and not (ma.Oid = user.Oid)
		and not (oLiveTarget = nil) then begin
		
			if (PvpLoaded and IsTarget_Valid_Char(oLiveTarget))
			or (not PvpLoaded and IsTarget_Valid_Live(oLiveTarget)) then begin
			
				if not IsTarget_DeathMarked(oLiveTarget) then begin
					Engine.CancelTarget();
					Engine.SetTarget(oLiveTarget);
					Engine.DUseSkill(1435, true, false);
					Engine.DUseSkill(1435, true, false);
					result := true;
				end;
				
			end;
			
		end;
		
	end;
end;




function CheckUse_AssistDebuff(skillId, interval: Integer): Boolean;
var
ma: Tl2Char;
oLiveTarget: Tl2Live;
begin
	result := false;
	
	if (skillId <= 0) or (interval <= 0) then exit;
	if not HasIntervalPassed_BySkillId(skillId, interval) then exit;
	
	
	//Check main assist's target
	if HasSkill_Ready(skillId) then begin
	
		ma := GetTarget_MainAssist;
		oLiveTarget := ma.Target;
		if not (ma = nil)
		and not (ma.Oid = user.Oid)
		and not (oLiveTarget = nil) then begin
		
			if (PvpLoaded and IsTarget_Valid_Char(oLiveTarget))
			or (not PvpLoaded and IsTarget_Valid_Live(oLiveTarget)) then begin
			
				if not (User.Target = oLiveTarget) then begin
					Engine.CancelTarget();
					Engine.SetTarget(oLiveTarget);
				end;
				SpamSkill_WhileNotReady(skillId, false, 1000);
				SetInterval_OnSkillId(skillId, interval);
				result := true;
				
			end;
			
		end;
		
	end;
end;

(*
function CheckUse_SlhSilence_Pvp(maxRange: Integer = 5000; TimeInterval: Cardinal = 5000): Boolean;
var
oTarget: Tl2Char;
attackWasOn: Boolean;
begin
	result := false;
	//if not TimerEx(Timer_SlhSilence, TimeInterval) then 
	
	if not HasSkill_Ready(1169) then exit;
	oTarget := GetTarget_ToFear_Pvp(maxRange);
	if (oTarget.Oid = User.Oid) or (oTarget = nil) or not IsTarget_ValidAndVisible_Char(oTarget) then Exit;
	
	attackWasOn := Engine.GetFaceState(1); //Attacks enabled?
	if attackWasOn then begin
		Engine.FaceControl(1, false);
	end;
	//Wait for casting to finish
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 3000) do Delay(175);
	while (User.Cast.EndTime > 0) and (User.Cast.EndTime < 210) do Delay(20);
	
	if not (User.Target = oTarget) then begin
		Engine.SetTarget(oTarget);
	end;
	result := Engine.DUseSkill(1169, true, false); //Curse Fear 
	
	if attackWasOn then begin
		Engine.FaceControl(1, true);
	end;
end;
	*)

function IsTarget_Casting_Damaging_GroundSkill(oTarget: Tl2Char): Boolean;
begin
	result := false;
	if (oTarget = nil) or (oTarget.Name = '') then exit;
	if (oTarget.Cast.EndTime > 0) then begin
		result := IsSpell_Damaging_GroundSkill(oTarget.Cast.Id);
	end;
end;

function IsTarget_Casting_DayOfDoom(oTarget: Tl2Char): Boolean;
begin
	result := false;
	if (oTarget = nil) or (oTarget.Name = '') then exit;
	if (oTarget.Cast.EndTime > 0) then begin
		result := oTarget.Cast.Id = DAY_OF_DOOM_ID;
	end;
end;

function IsSpell_Damaging_GroundSkill(nSpellId: Integer): Boolean;
begin
	result := false;
	case nSpellId of 
		1419: result := true; //Volcano (Sorc 80)
		1423: result := true; //Gahenna (Necro 80)
		1421: result := true; //Raging Waves (Spellsinger 80)  
		1420: result := true; //Cyclone (Spellhowler 80)
	end;
end;

function GetCount_ClusteredMages_Pvp: Integer;
var
oTarget, oTarget2: Tl2Char;
i, j, count: Integer;
begin
	result := 0;
	count := 0;
	for i := 0 to CharList.Count-1 do begin
		oTarget := CharList.Items(i);
	
		if (oTarget = nil) then begin
			WriteError('IsTime_ToAoe_Pvp: oTarget = nil');
			Continue;
		end;
	
		if (User.DistTo(oTarget) > MAX_PARTY_PT_DIST) 
		or not (IsTarget_Valid_Char(oTarget))
		or IsClass_FighterType(oTarget.ClassId) then continue;
	
		for j := 0 to CharList.Count-1 do begin
			if (j = i) then Continue;
			oTarget2 := CharList.Items(j);
			if (oTarget2 = nil) then begin
				WriteError('IsTime_ToAoe_Pvp: oTarget2 = nil');
				Continue;
			end;
			if (oTarget.DistTo(oTarget2) <= MAX_RANGE_AOE) 
			and (IsTarget_Valid_Char(oTarget2)) 
			and not IsClass_FighterType(oTarget2.ClassId) then begin
				Inc(count);
			end;
		end; 
	end;
	result := count;
end;

function GetCount_MagesClustered_NearChar_Pvp(oCenterTarget: Tl2Char; range: Integer): Integer;
var
oTarget, oTarget2: Tl2Char;
i, j, count: Integer;
begin
	result := 0;
	if (oCenterTarget = nil) or (not oCenterTarget.Valid) or (oCenterTarget.Name = '') then exit;
	count := 0;
	for i := 0 to CharList.Count-1 do begin
		oTarget := CharList.Items(i);
	
		if (oTarget = nil) then begin
			WriteError('IsTime_ToAoe_Pvp: oTarget = nil');
			Continue;
		end;
	
		if (oCenterTarget.DistTo(oTarget) > range) then continue;
		if (User.DistTo(oTarget) > MAX_RANGE_PVP_SEARCH) then break;
		
		if not (IsTarget_Valid_Char(oTarget))
		or IsClass_FighterType(oTarget.ClassId) then continue;
	
		Inc(count);
	end;
	result := count;
end;

function GetCount_DamageDealers_NearChar_Pvp(oCenterTarget: Tl2Char; range: Integer): Integer;
var
oTarget, oTarget2: Tl2Char;
i, j, count: Integer;
begin
	result := 0;
	if (oCenterTarget = nil) or (not oCenterTarget.Valid) or (oCenterTarget.Name = '') then exit;
	count := 0;
	for i := 0 to CharList.Count-1 do begin
		oTarget := CharList.Items(i);
	
		if (oTarget = nil) then begin
			WriteError('IsTime_ToAoe_Pvp: oTarget = nil');
			Continue;
		end;
	
		if (oCenterTarget.DistTo(oTarget) > range) then continue;
		if (User.DistTo(oTarget) > MAX_RANGE_PVP_SEARCH) then break;
		
		if not (IsTarget_Valid_Char(oTarget))
		or not IsClass_DD(oTarget.ClassId) then continue;
	
		Inc(count);
	end;
	result := count;
end;

function GetPoint_AoePosition_Pvp_ClusteredMages: TPoint;
var
oTarget, oCenterTarget, cchar: Tl2Char;
i, EndX, EndY, nDivider: Integer;
begin
	result := Point(0, 0);
	EndX := 0;
	EndY := 0;
	nDivider := 0;
  
	oCenterTarget := GetTarget_MostClustered_Char_MagesOnly;
	if not IsTarget_ValidAndVisible_Char(oCenterTarget) then begin
		Exit;
	end;
	
	//Investigate all enemies within range of 1k
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) then begin
			WriteError('CalculateBestAoePosition_Pvp: oTarget = nil');
			Continue;
		end;
		if (oCenterTarget.DistTo(oTarget) > (MAX_RANGE_AOE + 100))
		or not (IsTarget_Valid_Char(oTarget))
		or (IsClass_FighterType(oTarget.ClassId)) then Continue;
	
		EndX := EndX + oTarget.X;
		EndY := EndY + oTarget.Y;
		nDivider := nDivider + 1;
	end;

	if (nDivider > 1) then begin
		EndX := EndX div nDivider;
		EndY := EndY div nDivider;
	end;
  
	if (EndX = 0) and (EndY = 0) then begin
		result := Point(0, 0);
	end else begin
		result := Point(EndX, EndY);
	end;
end;

function GetCount_FriendlyBishopsDeadNear_NonParty(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		if (oTarget.IsMember) then continue;
		if (User.DistTo(oTarget) > maxRange) then break;
		if IsClass_Bp(oTarget.ClassId) 
		and (oTarget.Dead)
		and IsTarget_Friendly(oTarget) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function GetCount_PartyBishopsDeadNear(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > maxRange) then continue;
		
		if (IsClass_Bp(oTarget.ClassId) or IsClass_Aeore(oTarget.ClassId))
		and (oTarget.Dead) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function CheckUseRez_Iss: Boolean;
var
oTarget: Tl2Char;
begin
	result := false;
	//11564
	if not HasSkill_Ready(11564) then exit;
	
	if (GetCount_PartyBishopsDeadNear(900) >= 2) then begin
		oTarget := GetTarget_ClosestDeadHealer;
		if (oTarget = User) or (oTarget = nil) or (oTarget.name = '') then exit;
		
		if not (User.Target = oTarget) then begin
			Engine.SetTarget(oTarget);
		end;
		Engine.DUseSkill(11564, true, false);
		result := true;
	end;
end;

function GetTarget_ClosestDeadHealer: Tl2Char;
var
i, lastRange, curRange: Integer;
oCurTarget, oLastTarget : Tl2Char;
begin
	result := user;
	oLastTarget := user;
	lastRange := 10000;
	for i := 0 to Party.Chars.Count - 1 do begin
		oCurTarget := Party.Chars.Items(i);
		if (oCurTarget = nil) or (not oCurTarget.Valid) then continue;
		if not IsClass_Aeore(oCurTarget.ClassId)
		and not IsClass_Bp(oCurTarget.ClassId) then continue;
		
		if (User.DistTo(oCurTarget) > 900) or (not oCurTarget.Dead) then continue;
		
		curRange := User.DistTo(oCurTarget);
		if (curRange < lastRange) then begin
			oLastTarget := oCurTarget;
			lastRange := curRange;
		end;		
	end;
	result := oLastTarget;
end;

function GetCount_BishopsDeadNear(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > maxRange) then continue;
		
		if IsClass_Bp(oTarget.ClassId) 
		and (oTarget.Dead) 
		and IsTarget_Friendly(oTarget) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function GetCount_BishopsAliveInParty_SelfIncluded(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	
	if IsClass_Bp(User.ClassId) and not User.Dead then counter := 1;
	
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > maxRange) then continue;
		
		if IsClass_Bp(oTarget.ClassId) 
		and not (oTarget.Dead) 
		and oTarget.IsMember then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function GetCount_FriendsDeadNear(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	if (User.Dead) then counter := 1;
	
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > maxRange) then break;
		
		if (oTarget.Dead)
		and (oTarget.IsMember or IsTarget_Friendly(oTarget)) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function GetCount_PartyDeadNear(maxRange: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	counter := 0;
	if (User.Dead) then counter := 1;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > maxRange) then continue;
		
		if (oTarget.Dead) then begin
			counter := counter + 1;
		end;
	end;
	
	result := counter;
end;

function IsTime_ToHeal: Boolean;
//checked
var
i: Integer;
oTarget: Tl2Char;
begin
	result := False;
	//Print('Is time to heal started.');
	//if (GetMinPartyHp < 85) then begin
		////Print('Is time to heal? exit lowest is above 85');
		//result := True;
		//Exit;
	//end;
	//Print('Is time to heal 1');
	for i:= 0 to Party.Chars.Count - 1 do begin
		//Print('Is time to heal loop: i = ' + IntToStr(i) + ' of ' + IntToStr(Party.Chars.Count - 1));
		oTarget := Party.Chars.Items(i);
		
		//if not IsTarget_ValidAndVisible_Char(oTarget) then Continue;
		if (oTarget = nil) then continue;
		
		if (oTarget.Hp < 85)
		or (oTarget.Dead) 
		or (IsTarget_Debuffed_GetState(oTarget) > 0) then begin
			result := True;
			//Print('Is time to heal? exit, cuz debuffed');
			Exit;
		end;
	end;
	
	//Print('Is time to heal 2');
	if (DuoPartyMode) then begin
		//Print('Is time to heal duo');
		if (GetCount_FriendlyBishopsDeadNear_NonParty(900) >= 0) then result := true
		else if (GetCount_FriendsDeadNear(900) >= 1) then result := true
		else if (IsTime_ToCleanseFriends) then result := true;
			
	end;
	//Print('Is time to heal ended');
end;

function IsTime_ToHeal_Ee: Boolean;
//checked
var
i: Integer;
oTarget: Tl2Char;
begin
	result := False;
	if (GetMinPartyHp < 85) then begin
		result := True;
		Exit;
	end;
	exit; //Dont look at debuffs atm as elven elder
	for i:= 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then Continue;
		if (IsTarget_Debuffed_GetState(oTarget) > 0) or (oTarget.Dead) then begin
			result := True;
			Exit;
		end;
	end;
	if (DuoPartyMode) then begin
		if (GetCount_FriendlyBishopsDeadNear_NonParty(900) >= 2) then result := true;
		if (GetCount_FriendsDeadNear(900) >= 7) then result := true;
	end;
end;


(*
function CheckUse_ToSublime_ByUser(control: Tl2Control): Boolean;
var
lowMpCount, hpCost, mpCost: Integer;
oHealer: Tl2Char;
otherHealerRez: Tl2Skill;
begin
	result := false;
	hpCost := 8000;
	mpCost := 218;
	if (control.CurHp < hpCost) or (control.CurMp < mpCost) then exit;
	
	//Both bishops should be alive, so ourself and one party bishop
	if (GetCount_BishopsDeadNear(1500) > 0) or control.Dead then exit;
	
	//If any Other Bishop Mana is below 10%
	if IsAnyPartyBishopLowMp_NotMyself(control, 10) then begin
		result := true;
		exit;
	end;
	
	lowMpCount := GetCount_PartyMembers_WithManaLessThan_NonBishops(10); //No need to alter this, as we never need to check ourself
	if ((lowMpCount > 3) and not PvpLoaded) 
	or ((lowMpCount > 1) and PvpLoaded) then begin
		result := true;
		exit;		
	end;
	
end;*)

function CheckUse_Sublime_Healer1Only(): Boolean;
var
i, lowMpCount, hpCost, mpCost: Integer;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	if not HasIntervalPassed_BySkillId(1505, 10000) then exit;
	if not IsUnderAttack then exit;
	
	hpCost := 8000;
	mpCost := 218;
	
	//All bishops should be alive, so ourself and all party bishops
	if (GetCount_PartyBishopsDeadNear(1500) > 0) or User.Dead then exit;
	
	lowMpCount := GetCount_PartyMembers_WithManaLessThan_NonBishops(10);
	if ((lowMpCount > 1) and not PvpLoaded) 
	or ((lowMpCount > 1) and PvpLoaded) then begin
		UseForMembers := true;
	end else 
		UseForMembers := false;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
			if (DuoPartyMode) or (IsTarget_InMyGroup(control)) then begin
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
							
					if IsClass_Bp(controlUser.ClassId) and (HasSkill_Ready(1505, control)) and not IsTarget_Disabled(controlUser) then begin
						if (controlUser.CurHp > hpCost) and (controlUser.CurMp > mpCost) then begin
							
							if (UseForMembers) then begin
								if control.DUseSkill(1505, true, false) then
									SetInterval_OnSkillId(1505, 10000);
								
								result := (control = Engine); //Only return true, if we, ourself, should cast sublime
								exit;
							end;
							
							//If any of the other Bishops Mana is below 10%
							if IsAnyPartyBishopLowMp_NotMyself(control, 10) then begin
								SetInterval_OnSkillId(1505, 10000);
								if control.DUseSkill(1505, false, false) then
									
								//result := (control = Engine); //Only return true, if we, ourself, should cast sublime
								exit;
							end;
							
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;


function CheckUse_Rebirth_Healer1Only(): Boolean;
var
i, lowMpCount, mpCost: Integer;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	if not HasIntervalPassed_BySkillId(11768, 10000) then exit;
	//if not IsUnderAttack then exit;
	
	mpCost := 66;
	
	//All bishops should be alive, so ourself and all party bishops
	if (GetCount_PartyBishopsDeadNear(1500) > 0) or User.Dead then exit;
	
	lowMpCount := GetCount_PartyMembers_WithManaLessThan_NonBishops(10);
	if ((lowMpCount > 1) and not PvpLoaded) 
	or ((lowMpCount >= 1) and PvpLoaded) then begin
		UseForMembers := true;
	end else 
		UseForMembers := false;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
		
			if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
						
				if IsClass_Aeore(controlUser.ClassId) and (HasSkill_Ready(11768, control)) and not IsTarget_Disabled(controlUser) then begin
					if (controlUser.CurMp > mpCost) then begin
						
						if (UseForMembers) then begin
							control.DUseSkill(11768, true, false);
							SetInterval_OnSkillId(11768, 10000);
							Print('Rebirth: Members low on mp = ' + IntToStr(lowMpCount) + '. ' + controlUser.Name + ' use rebirth!');
							result := (control = Engine); //Only return true, if we, ourself, should cast sublime
							exit;
						end;
						
						//If any of the other Bishops Mana is below 5%
						if IsAnyPartyBishopLowMp_NotMyself(control, 5) or (controlUser.mp <= 5) then begin
							control.UseSkill(11768, false, false);
							SetInterval_OnSkillId(11768, 10000);
							Print('Rebirth: Some healer is low mp. ' + controlUser.Name + ' use rebirth!');
							result := (control = Engine); //Only return true, if we, ourself, should cast sublime
							exit;
						end;
						
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;

function CheckUse_Rebirth_Healer1Only_V2(): Boolean;
var
i, lowMpCount: Integer;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
oLowHealer: Tl2Char;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	if not HasIntervalPassed_BySkillId(11768, 5000) then exit;
	//if not IsUnderAttack then exit;
	
	
	//All bishops should be alive, so ourself and all party bishops
	if (GetCount_PartyBishopsDeadNear(1500) > 0) or User.Dead then exit;
	
	lowMpCount := GetCount_PartyMembers_WithManaLessThan_NonBishops(10);
	if ((lowMpCount > 2) and not PvpLoaded) 
	or ((lowMpCount >= 1) and PvpLoaded) then begin
		UseForMembers := true;
	end else 
		UseForMembers := false;
	
	
	if (UseForMembers) then begin
		//Get healer for rebirth.
		control := GetFirstAvailable_AeoreControl_ToUse(11768, 66);
		if not Assigned(control) then begin
			Print('No healer available to rebirth members');
			exit;
		end;
		controlUser := control.GetUser;
		if (controlUser = nil)then begin
			Print('No healer/user available to rebirth members');
			exit;
		end;
		
		control.DUseSkill(11768, false, false);
		control.DUseSkill(11768, false, false);
		control.DUseSkill(11768, false, false);
		SetInterval_OnSkillId(11768, 5000);
		Print('Rebirth: Members low on mp = ' + IntToStr(lowMpCount) + '. ' + controlUser.Name + ' use rebirth!');
		result := (control = Engine); //Only return true, if we, ourself, should cast sublime
		exit;
	end;
			
	oLowHealer := GetMember_LowestMp_OnlyAeore;
	if not (oLowHealer = nil)
	and not (oLowHealer.Name = '')
	and (oLowHealer.MP < 6) then begin
	
		//Get healer for rebirth.
		control := GetFirstAvailable_AeoreControl_ToUse(11768, 66);
		if Assigned(control) then begin
			controlUser := control.GetUser;
			if not (controlUser = nil) then begin
				control.UseSkill(11768, false, false);
				control.DUseSkill(11768, false, false);
				control.DUseSkill(11768, false, false);
				SetInterval_OnSkillId(11768, 5000);
				Print('Rebirth: Some healer is low mp. ' + controlUser.Name + ' use rebirth!');
				result := (control = Engine); //Only return true, if we, ourself, should cast sublime
				exit;		
			end;
		end else begin
			//No healer had rebirth.
			control := GetFirstAvailable_AeoreControl_ToUse(11856, 66, oLowHealer.Oid);
			if Assigned(control) then begin
				controlUser := control.GetUser;
				if not (controlUser = nil) then begin
					if (controlUser.Oid = oLowHealer.Oid) then begin
						Print('ERROR! Rebirth: controlUser.Oid = oLowHealer.Oid');
					end;
					if not (controlUser.Target.Oid = oLowHealer.Oid) then begin
						control.SetTarget(oLowHealer);
					end;
					control.UseSkill(11856, false, false);
					Print('Rebirth: Rebirth not ready. ' + oLowHealer.Name + ' has ' + IntToStr(oLowHealer.Mp) + ' mp. ' + controlUser.Name + ' use mental recharge!');
					result := (control = Engine); //Only return true, if we, ourself, should cast sublime
					exit;		
				end;
			end;
		end;	
	end;
end;

function GetFirstAvailable_AeoreControl_ToUse(skillIdToUse, mpCost: Cardinal): Tl2Control; overload;
var
i: Integer;
control: Tl2Control;
controlUser: Tl2User;
begin
	result := GetFirstAvailable_AeoreControl_ToUse(skillIdToUse, mpCost, 0);
end;

function GetFirstAvailable_AeoreControl_ToUse(skillIdToUse, mpCost, exceptionOid: Cardinal): Tl2Control; overload;
var
i: Integer;
control: Tl2Control;
controlUser: Tl2User;
begin
	result := nil;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
			if ((exceptionOid = 0) or not (controlUser.Oid = exceptionOid)) then begin
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
							
					if IsClass_Aeore(controlUser.ClassId) and (HasSkill_Ready(skillIdToUse, control)) and not IsTarget_Disabled(controlUser) then begin
						if (controlUser.CurMp > mpCost) then begin
							result := control;
							exit;						
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;

function GetMember_LowestMp_NonRecharger: Tl2Char;
var
i, lastMp, curMp: Integer;
oCurTarget, oLastTarget: Tl2Char;
control: Tl2Control;
oSkill: Tl2Skill;
begin
	lastMp := 101;
	oLastTarget := nil;
	for i := 0 to Party.Chars.Count do begin
		if (i = Party.Chars.Count) then oCurTarget := user
		else oCurTarget := Party.Chars.Items(i);
		
		if (oCurTarget = nil)
		or (oCurTarget.Dead)
		or (User.DistTo(oCurTarget) > 700) 
		or IsClass_Aeore(oCurTarget.ClassId) then continue;
		
		if not TargetCanBeRecharged(oCurTarget) then continue;
		(*if (GetClassValue_Healer(oCurTarget.ClassId) > 0) then begin
			control := GetControl(oCurTarget.Name);
			if Assigned(control) then begin
				//If we can see the skills of this member:
				if (control.GetSkillList.ById(1013, oSkill)) then continue;
				if (MODE_GOD) and (control.GetSkillList.ById(11760, oSkill)) then continue;
			end else begin
				continue;
			end;
		end;*)
			
		curMp := oCurTarget.Mp;
		
		if (curMp < lastMp) then begin
			oLastTarget := oCurTarget;
			lastMp := curMp;
		end;
	
	end;
	
	result := oLastTarget;
end;

function GetMember_LowestMp_OnlyAeore: Tl2Char;
var
i, lastMp, curMp: Integer;
oCurTarget, oLastTarget: Tl2Char;
begin
	lastMp := 101;
	oLastTarget := nil;
	for i := 0 to Party.Chars.Count do begin
		if (i = Party.Chars.Count) then oCurTarget := user
		else oCurTarget := Party.Chars.Items(i);
		
		if (oCurTarget = nil)
		or (oCurTarget.Dead)
		or (User.DistTo(oCurTarget) > 700) 
		or (not IsClass_Aeore(oCurTarget.ClassId)) then continue;
			
		curMp := oCurTarget.Mp;
		
		if (curMp < lastMp) then begin
			oLastTarget := oCurTarget;
			lastMp := curMp;
		end;
	
	end;
	
	result := oLastTarget;
end;
function GetMember_HighestMp_OnlyHealers: Tl2Char;
var
i, lastMp, curMp: Integer;
oCurTarget, oLastTarget: Tl2Char;
begin
	lastMp := -1;
	oLastTarget := nil;
	for i := 0 to Party.Chars.Count do begin
		if (i = Party.Chars.Count) then oCurTarget := user
		else oCurTarget := Party.Chars.Items(i);
		
		if (oCurTarget = nil)
		or (oCurTarget.Dead)
		or (User.DistTo(oCurTarget) > 700) 
		or (not (GetClassValue_Healer(oCurTarget.ClassId) > 0)) then continue;
			
		curMp := oCurTarget.Mp;
		
		if (curMp > lastMp) then begin
			oLastTarget := oCurTarget;
			lastMp := curMp;
		end;
	
	end;
	
	result := oLastTarget;
end;
function GetMember_ToRecharge(maxMpForRecharge, criticalRechargeMp: Cardinal): Tl2Char;
var
i, lastMp, curMp: Integer;
oCurTarget, oLastTarget: Tl2Char;
oBuff: Tl2Buff;
begin
	lastMp := 101;
	
	//print('1');
	oLastTarget := nil;
	for i := 0 to Party.Chars.Count do begin
		//print('2');
		if (i = Party.Chars.Count) then oCurTarget := user
		else oCurTarget := Party.Chars.Items(i);
		
		if (oCurTarget = nil)
		or (oCurTarget.Dead)
		or (User.DistTo(oCurTarget) > 700) 
		or (oCurTarget.Mp > maxMpForRecharge) then continue;
			
		if (not TargetCanBeRecharged(oCurTarget)) then continue;
		//print('3');
		if (oCurTarget.MP > criticalRechargeMp)
		and (oCurTarget.Buffs.ById(11760, oBuff) or oCurTarget.Buffs.ById(11761, oBuff)) then continue;
			
		//print('4');
		//if not TimerExpired_OnPerson(oCurTarget.Oid, 11760) then begin
			//print('Timer not passed');
			//continue;
		//end;
		//print('5');
		curMp := oCurTarget.Mp;
		
		if (curMp < lastMp) then begin
			oLastTarget := oCurTarget;
			lastMp := curMp;
			//print('6 Inside!!!!!!!!!!!!!');
		end;
	
	end;
	
	result := oLastTarget;
end;

function TargetCanBeRecharged(oTarget: Tl2Char): Boolean;
var
control: Tl2Control;
oSkill: Tl2Skill;
oBuff: Tl2Buff;
begin
	result := true;
	
	if (oTarget = nil) 
	or oTarget.Dead 
	or (IsFriend_Invincible(oTarget)) 
	or (oTarget.Buffs.ById(1422, oBuff)) then begin //cant recharge if target has Day of Doom
		result := false;
		exit;
	end;
	
	//Specific for Goddess of Destruction Updates.
	if (MODE_GOD) then begin
		if IsClass_Aeore(oTarget.ClassId) then result := false
		else result := true;
		exit;
	end;
	
	
	if IsClass_Se(oTarget.ClassId)
	or IsClass_Ee(oTarget.ClassId) then begin
		result := false;
		exit;
	end;
	
	//If it is a bishop, check if it has taken Recharge as transfer skill
	if (IsClass_Bp(oTarget.ClassId)) then begin
		control := GetControl(oTarget.Name);
		if (Assigned(control)) then begin
		
			result := not (control.GetSkillList.ById(1013, oSkill));
			
			
		end else begin
			//If we cannot determine if the target bishop has the recharge skill, return false by default
			result := false;
		end;
	
	end;
end;


function CheckUse_Recharge_Healer1Only_God(maxMpForRecharge: Cardinal): Boolean;
var
i, lowMpCount, mpCost, rechargeId, criticalManaAmount: Integer;
control: Tl2Control;
UseForMembers, debug: Boolean;
controlUser: Tl2User;
oTarget, oHighHealer : Tl2Char;
begin

	criticalManaAmount := 20;
	
	result := false;
	//Print('Check Recharge:');
	if not (User.Name = GetName_Healer1) then exit;
	if MODE_GOD then begin
		rechargeId := 11760;
		mpCost := 66;
	end else begin
		rechargeId := 1013;
		mpCost := 120;
	end;
	
	//Print('Check Recharge: we are healer 1');
	oTarget := GetMember_LowestMp_NonRecharger;
	if (oTarget = nil) then begin
		//Print('Recharge: No one found is low MP');
		exit;
	end;
	
	if (oTarget.Mp > maxMpForRecharge) then begin
		//if debug then ////Print('Recharge: lowest member has too high mana: ' + IntToStr(oTarget.MP));
		exit;
	end;
	oHighHealer := GetMember_HighestMp_OnlyHealers();
	if (oHighHealer = nil) then begin//mana
		//Print('Recharge: No available healer found to recharge!');
		exit;
	end;
	//Dont recharge if: the MP of the highest healer + 10 is less than the mana amount of the lowest DD. 
	if ((oHighHealer.Mp + 10) < oTarget.Mp) then begin
		//Print('Recharge: Party members higher mp than healers');
		exit;
	end;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		
		if not (controlUser = nil) 
		and (control.Status = lsOnline)  then begin
		
			if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
						
				if (GetClassValue_Healer(controlUser.ClassId) > 0) 
				and IsTarget_InMyGroup(control)
				and (HasSkill_Ready(rechargeId, control)) 
				and not IsTarget_Disabled(controlUser) then begin
					
					if not (controlUser.Oid = oHighHealer.Oid)
					and ((controlUser.Mp < criticalManaAmount) and (oHighHealer.Mp > controlUser.Mp + 10)) then begin
						Inc(i);
						control := GetControlByIndex(i);
						continue;
					end;
					
					if (controlUser.CurMp > mpCost) then begin
						
						oTarget := GetMember_ToRecharge(maxMpForRecharge, criticalManaAmount); //Dont care about the after-effect of recharge if target has less than 20% mana left

						if not (oTarget = nil) and (controlUser.Mp + 10 >= oTarget.MP) then begin
							if not (controlUser.Target.Oid = oTarget.Oid) then begin
								control.SetTarget(oTarget);
							end;
							control.DUseSkill(rechargeId, true, false);
							
							if (oTarget.Mp > criticalManaAmount) then SetTimer_OnPerson(oTarget.Oid, rechargeId, 5000);
							
							
							Print('Recharge: ' + oTarget.Name + ' only has ' + IntToStr(oTarget.MP) + ' MP left. ' + controlUser.Name + ' use recharge!');
							result := (controlUser.OID = User.OID);
						//end else if debug then begin
							//if (oTarget = nil) then 
								//Print('Recharge: Target was nil')
							//else if (controlUser.Mp + 10 >= oTarget.MP) then 
								//Print('Recharge: we have too low mp');
						end;
						
					end;
				end;
			//end else if debug then begin
				//Print('Recharge: User is too far away and is not ourself');
			end;
		//end else if debug then begin
			//Print('Recharge: Current User is nil or not online');
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;


function CheckUse_Recharge_Healer1Only(maxMpForRecharge: Cardinal): Boolean;
var
i, lowMpCount, mpCost, rechargeId, criticalManaAmount: Integer;
control: Tl2Control;
UseForMembers, debug: Boolean;
controlUser: Tl2User;
oTarget, oHighHealer : Tl2Char;
begin

	criticalManaAmount := 20;
	
	result := false;
	//Print('Check Recharge:');
	if not (User.Name = GetName_Healer1) then exit;
	if MODE_GOD then begin
		rechargeId := 11760;
		mpCost := 66;
	end else begin
		rechargeId := 1013;
		mpCost := 120;
	end;
	
	//Print('Check Recharge: we are healer 1');
	oTarget := GetMember_LowestMp_NonRecharger;
	if (oTarget = nil) then begin
		//Print('Recharge: No one found is low MP');
		exit;
	end;
	
	if (oTarget.Mp > maxMpForRecharge) then begin
		//if debug then ////Print('Recharge: lowest member has too high mana: ' + IntToStr(oTarget.MP));
		exit;
	end;
	(*
	oHighHealer := GetMember_HighestMp_OnlyHealers();
	if (oHighHealer = nil) then begin//mana
		//Print('Recharge: No available healer found to recharge!');
		exit;
	end;
	//Dont recharge if: the highest healer has less mana than the lowest DD. 
	if (oHighHealer.Mp < oTarget.Mp) then begin
		//Print('Recharge: Party members higher mp than healers');
		exit;
	end;*)
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		
		if not (controlUser = nil) 
		and (control.Status = lsOnline)  then begin
		
			if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
				
				if (GetClassValue_Healer(controlUser.ClassId) > 0) 
				and IsTarget_InMyGroup(control)
				and (HasSkill_Ready(rechargeId, control)) 
				and not IsTarget_Disabled(controlUser) then begin	
				(*
					//if any healer with not-highest-mp and the healer has less than 20% mana, and the highest healer has more mana than me
					if not (controlUser.Oid = oHighHealer.Oid)
					and ((controlUser.Mp < criticalManaAmount) and (oHighHealer.Mp > controlUser.Mp + 10)) then begin
						Inc(i);
						control := GetControlByIndex(i);
						continue;
					end; *)
					
					if (controlUser.Mp > 35) then begin
						
						oTarget := GetMember_ToRecharge(maxMpForRecharge, criticalManaAmount); //Dont care about the after-effect of recharge if target has less than 20% mana left

						if not (oTarget = nil) and (controlUser.Mp >= oTarget.MP) then begin
							if not (controlUser.Target.Oid = oTarget.Oid) then begin
								control.SetTarget(oTarget);
							end;
							control.DUseSkill(rechargeId, true, false);
							
							//if (oTarget.Mp > criticalManaAmount) then SetTimer_OnPerson(oTarget.Oid, rechargeId, 5000);
							
							
							//Print('Recharge: ' + oTarget.Name + ' only has ' + IntToStr(oTarget.MP) + ' MP left. ' + controlUser.Name + ' use recharge!');
							result := (controlUser.OID = User.OID);
						//end else if debug then begin
							//if (oTarget = nil) then 
								//Print('Recharge: Target was nil')
							//else if (controlUser.Mp + 10 >= oTarget.MP) then 
								//Print('Recharge: we have too low mp');
						end;
						
					end;
				end;
			//end else if debug then begin
				//Print('Recharge: User is too far away and is not ourself');
			end;
		//end else if debug then begin
			//Print('Recharge: Current User is nil or not online');
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;


function CheckUse_PainOfShilen_LeaderTypeOnly(): Boolean;
var
i: Integer;
control: Tl2Control;
controlUser: Tl2User;
oTarget : Tl2Char;
oBuff: Tl2Buff;
begin
	result := false;
	if not (SEED_POP_MODE) then exit;
	//print('pain 1'); Delay(1000);
	if not (IsTarget_Leader(User.Name)) then exit;
	
	//print('pain 2'); Delay(1000);
	if (DoesAnyoneHaveBuffInParty(789, -1, 10000)) then exit; //Spirit of shilen already on.
	
	//print('pain 3'); Delay(1000);
	if DoesAnyoneHaveBuffInParty(5564, 3) (* and (GetCount_PartyMembersHasBuff(789) < 2) *) then begin
		//print('pain 3.1'); Delay(1000);
		result := Use_SpiritOfShilen_LeaderTypeOnly;
		exit;
	end;
	
	//print('pain 4'); Delay(1000);
	
	if not DoesAnyoneHaveBuffInParty(788)
	and not DoesAnyoneHaveBuffInParty(5564) then begin
		
		if not HasIntervalPassed_BySkillId(788, 3000) then exit;
		i := 0;
		control := GetControlByIndex(i);
		while Assigned(control) do begin
			controlUser := control.GetUser;
			
			if not (controlUser = nil) 
			and (control.Status = lsOnline)  then begin
			
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
					
					if (IsClass_Sk(controlUser.ClassId)) 
					and (Party.Chars.ByName(controlUser.Name, oTarget) or (controlUser.Oid = User.Oid))
					and (HasSkill_Ready(789, control)) 
					and (HasSkill_Ready(788, control)) 
					and not (controlUser.Buffs.ById(788, oBuff))
					and not (controlUser.Buffs.ById(5564, oBuff))
					//and not (controlUser.Buffs.ById(789, oBuff))
					and not IsTarget_Disabled(controlUser) then begin	
						
						control.DUseSkill(788, false, false);
						SetInterval_OnSkillId(788, 3000);
						result := true;
						exit;
						
					end;
				end;
			end;
			Inc(i);
			control := GetControlByIndex(i);
		end;
		
	end;
end;
	
function Use_SpiritOfShilen_LeaderTypeOnly(): Boolean;
var
i: Integer;
control: Tl2Control;
controlUser: Tl2User;
oTarget : Tl2Char;
oBuff: Tl2Buff;
begin
	result := false;
	
	if not (IsTarget_Leader(User.Name)) then exit;
	
	if not HasIntervalPassed_BySkillId(789, 5000) then exit;
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
			
		if not (controlUser = nil) 
		and (control.Status = lsOnline)  then begin
			
			if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
					
				if (IsClass_Sk(controlUser.ClassId)) 
				and (Party.Chars.ByName(controlUser.Name, oTarget) or (controlUser.Oid = User.Oid))
				and (HasSkill_Ready(789, control)) 
				and (controlUser.Buffs.ById(5564, oBuff))
				and (oBuff.Level >= 3)
				and not IsTarget_Disabled(controlUser) then begin	
						
					if control.UseSkill(789) then begin
						SetInterval_OnSkillId(789, 5000);
						result := true;
						exit;	
					end;
						
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
		
end;	

function DoesAnyoneHaveBuffInParty(buffId: Integer; minLevel: Integer = -1; minTime: Integer = -1): Boolean;
var
i: Integer;
oBuff: Tl2Buff;
oTarget: Tl2Char;
begin
	result := false;
	
	if (buffId <= 0) then exit;
	if (User.Buffs.ById(buffId, oBuff)) then begin
		if (minLevel = -1)
		or (oBuff.Level >= minLevel) then begin
			if (minTime = -1)
			or (oBuff.EndTime > minTime) then begin
				result := true;
				exit;
			end;
		end;
	end;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) then continue;
		
		if oTarget.Buffs.ById(buffId, oBuff) then begin
			if (minLevel = -1)
			or (oBuff.Level >= minLevel) then begin
				if (minTime = -1)
				or (oBuff.EndTime > minTime) then begin
					result := true;
					exit;
				end;
			end;
		end;
	end;
	
end; 

			


function CheckUse_MassCleanse_Healer1Only(): Boolean;
var
i, lowMpCount, mpCost: Integer;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
mainHealer: Tl2Char;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	
	if not PvpLoaded then exit;
	
	if (DuoPartyMode) then begin
		if CharList.ByName(GetName_Healer1_ByPartyNum(1), mainHealer) then begin //1 for main party
			if (User.DistTo(mainHealer) < 900) then begin
				//if we are using duoPartyMode, and main healer is close, let him handle ressurection.
				exit;
			end;
		end;
	end;
	
	
	if not HasIntervalPassed_BySkillId(1425, 10000) then exit;
	
	mpCost := 80;
	
	//If less than six members has stage 3 (or higher) debuffs, dont use mass cleanse
	if (GetCount_MembersDebuffed_SelfIncluded_AliveOnly(3) < 6) then exit;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
			
			if DuoPartyMode or IsTarget_InMyGroup(control) then begin
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
						
				
					if IsClass_Bp(controlUser.ClassId) 
					and (HasSkill_Ready(1425, control)) 
					and (HasItem_MinCount(control, 8876, 1)) 
					and not IsTarget_Disabled(controlUser) then begin
					
						if (controlUser.CurMp > mpCost) then begin
							control.DUseSkill(1425, false, false);
							SetInterval_OnSkillId(1425, 10000);
									
							result := (control = Engine); //Only return true, if we, ourself, should cast mass cleanse
							exit;
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;

function CheckUse_BalanceLife_Healer1Only(): Boolean;
var
i, lowMpCount, mpCost, balanceID: Integer;
oTarget, temp: Tl2Char;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	if not (User.Name = GetName_Healer1) and not (User.Name = GetName_SubPartyLeader(GetPartyNum)) then exit;
	if MODE_GOD then balanceID := 11762
	else balanceID := 1335;
	
	if not HasIntervalPassed_BySkillId(balanceID, 2000) then exit;
	
	mpCost := 80;
	
	if (GetParty_AverageHp_AliveOnly < 55) then exit;
	
	oTarget := GetTarget_LowestHpAlive_Party;
  
	if not IsTarget_ValidAndVisible_Char(oTarget) then exit;
	
	if (oTarget.HP > 50)
	or (User.DistTo(oTarget) > 900) then Exit;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
		
			if (Party.Chars.ByName(controlUser.Name, temp)) or (controlUser.Oid = User.Oid) then begin
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
							
				
					if (IsClass_Bp(controlUser.ClassId) or IsClass_Aeore(controlUser.ClassId))
					and (HasSkill_Ready(balanceID, control)) 
					and not IsTarget_Disabled(controlUser) then begin
					
						if (controlUser.CurMp > mpCost) then begin
							control.UseSkill(balanceID, false, false);
							SetInterval_OnSkillId(balanceID, 2000);
									
							result := (control = Engine); //Only return true, if we, ourself, should cast mass cleanse
							exit;
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;


function IsMy_TreeOfLifeUp: Boolean;
var
i: Integer;
oTarget: Tl2Live;
begin
	result := false;
	for i := 0 to NpcList.Count - 1 do begin
		oTarget := NpcList.Items(i);
		if (oTarget = nil) or (not oTarget.Valid) then continue;
		
		if (User.DistTo(oTarget) > 700) then break;
		
		if (oTarget.ID = 14933) 
		and (oTarget.Title = User.Name)
		and not (oTarget.Dead) then begin
			result := true;
			exit;
		end;
	end;
end;

function CheckUse_MassRez_Healer1Only(): Boolean;
var
i, mpCost, bpDeadCount, totalDeadCount: Integer;
oHealer, mainHealer: Tl2Char;
otherHealerRez: Tl2Skill;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
oBuff: Tl2Buff;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	
	if (DuoPartyMode) then begin
		if CharList.ByName(GetName_Healer1_ByPartyNum(1), mainHealer) then begin //1 for main party
			if (User.DistTo(mainHealer) < 900) then begin
				//if we are using duoPartyMode, and main healer is close, let him handle ressurection.
				exit;
			end;
		end;
	end;
	
	if not HasIntervalPassed_BySkillId(1254, 4000) then exit;
	
	mpCost := 450;
	
	//bpDeadCount := GetCount_PartyBishopsDeadNear(900);
	totalDeadCount := GetCount_DeadClanPlayersWithinRange(900); //also skipping dod affected corpses
	if (User.Dead) then begin
		//Inc(bpDeadCount);
		if not (User.Buffs.ById(5145, oBuff)) then
			Inc(totalDeadCount);
	end;
	
	//if (bpDeadCount < 1) then exit; //Only use mass rez if 2 or more Bishops are dead 
	
	if DuoPartyMode and (totalDeadCount < 7) then exit //Only use mass rez if 4 or more members are dead
	else if not DuoPartyMode and (totalDeadCount < 4) then exit;
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
		
			if DuoPartyMode or IsTarget_InMyGroup(control) then begin
				if (User.DistTo(controlUser) < 900) or (controlUser.Oid = User.Oid) then begin
						
				
					if IsClass_Bp(controlUser.ClassId) 
					and (HasSkill_Ready(1254, control)) 
					and not IsTarget_Disabled(controlUser) then begin
					
						if (controlUser.CurMp > mpCost) then begin
							control.DUseSkill(1254, false, false);
							Print(controlUser.Name + ' user mass rez!');
							SetInterval_OnSkillId(1254, 4000);
									
							result := (control = Engine); //Only return true, if we, ourself, should cast mass rez
							exit;
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;

function CheckUse_Miracle_Healer1Only(): Boolean;
var
i, lowMpCount, mpCost: Integer;
oHealer, mainHealer: Tl2Char;
otherHealerRez: Tl2Skill;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	
	
	if (DuoPartyMode) then begin
		if CharList.ByName(GetName_Healer1_ByPartyNum(1), mainHealer) then begin //1 for main party
			if (User.DistTo(mainHealer) < 900) then begin
				//if we are using duoPartyMode, and main healer is close, let him handle ressurection.
				exit;
			end;
		end;
	end;
	
	if not PvpLoaded then exit;
	if not HasIntervalPassed_BySkillId(1426, 10000) then exit;
	
	mpCost := 80;
	
	//If less than 5 members has (less than 30% hp and doesnt have Seal of Limit Buff), dont use Miracle (clan 100% heal skill)
	if (GetCount_PartyMembers_WithHpLessThan_Alive_NoSealLimit(30) < 5) then exit;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
		
			if DuoPartyMode or IsTarget_InMyGroup(control) then begin
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
						
				
					if IsClass_Bp(controlUser.ClassId) 
					and (HasSkill_Ready(1426, control)) 
					and (HasItem_MinCount(control, 8876, 1)) 
					and not IsTarget_Disabled(controlUser) then begin
					
						if (controlUser.CurMp > mpCost) then begin
							control.UseSkill(1426, false, false);
							SetInterval_OnSkillId(1426, 10000);
									
							result := (control = Engine); //Only return true, if we, ourself, should cast Miracle
							exit;
						end;
						
					end;
				
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;
(*
function CheckUse_Rez_Healer1Only(): Boolean;
var
i, lowMpCount, mpCost, rezId: Integer;
oTarget, mainHealer: Tl2Char;
otherHealerRez: Tl2Skill;
control: Tl2Control;
healerFound: Boolean;
controlUser: Tl2User;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	
	if (DuoPartyMode) then begin
		if CharList.ByName(GetName_Healer1_ByPartyNum(1), mainHealer) then begin //1 for main party
			if (User.DistTo(mainHealer) < 900) then begin
				//if we are using duoPartyMode, and main healer is close, let him handle ressurection.
				exit;
			end;
		end;
	end;
	
	CleanUp_RezExceptionList();
	mpCost := 100;
	healerFound := false;
	
	
	oTarget := GetTarget_ToRez_FromControl_ByExceptions(Engine);
	if not User.Dead and (oTarget = nil) then exit;
	
	if MODE_GOD then rezId := 11784
	else rezId := 1016;
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
			if DuoPartyMode or IsTarget_InMyGroup(control) then begin
				if (User.DistTo(controlUser) < 900) or (controlUser.Oid = User.Oid) then begin
					
					if (GetClassValue_Healer(controlUser.ClassId) > 0) and (HasSkill_Ready(rezId, control)) and not IsTarget_Disabled(controlUser) then begin
						if TimerExpired_OnPerson(controlUser.Oid, 1016) and (controlUser.CurMp > mpCost) then begin
							healerFound := true;
							
							//someone to rez?
							oTarget := GetTarget_ToRez_FromControl_ByExceptions(control);
							if not (oTarget = nil) then begin
								Print(oTarget.Name + ' is dead!   ' + controlUser.Name + ' rez him!');
								CheckCancel_LessImportantSkillCasting(control);
								control.SetTarget(oTarget);
								RezExceptionList.Add(oTarget);
								SetTimer_OnPerson(oTarget.Oid, 1016, 2000); //1016 rez id
								SetTimer_OnPerson(controlUser.Oid, 1016, 2500); //1016 rez id
								//Print(oTarget.name + ' was added to rez exception list!');
								if control.DUseSkill(rezId, false, false) then begin
									//oTarget.SetVar(GetTickCount + 3000);
									if (User.Oid = controlUser.Oid) then result := true;
								end;
							end;
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
	
	//If no free healers were found, check if someone needs to use Blessed Scroll of ressurection.
	if not healerFound then begin
		i := 0;
		control := GetControlByIndex(i);
		while Assigned(control) do begin
			controlUser := control.GetUser;
			if not (controlUser = nil) and (control.Status = lsOnline)  then begin
		
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
					
					if (HasItem_MinCount(control, 3936, 1)) and not IsTarget_Disabled(controlUser) then begin
							
						//someone to brez?
						oTarget := GetTarget_ToRez_FromControl_ByExceptions(control);
						if not (oTarget = nil) then begin
							Print(oTarget.Name + ' is dead!   ' + controlUser.Name + ' rez him, by using Blessed Scroll of Ressurection!');
							CheckCancel_LessImportantSkillCasting(control);
							control.SetTarget(oTarget);
							RezExceptionList.Add(oTarget);
							SetTimer_OnPerson(oTarget.Oid, 1016, 3000); //1016 rez id
							if control.UseItem(3936) then begin
								//oTarget.SetVar(GetTickCount + 4000);
								if (User = controlUser) then result := true;
							end;
						end;
						
					end;
				end;
			end;
			Inc(i);
			control := GetControlByIndex(i);
		end;		
	end;
	
end;
*)


(*
function CheckUse_Cleanse_Healer1Only(): Boolean;
var
i, lowMpCount, mpCost, cleanseID: Integer;
oTarget, temp: Tl2Char;
otherHealerRez: Tl2Skill;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	CleanUp_CleanseExceptionList();
	mpCost := 100;
	if MODE_GOD then cleanseID := 11763
	else cleanseID := 1409;
	
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
		
			//if (Party.Chars.ByName(controlUser.Name, temp)) or (controlUser.Oid = User.Oid) then begin
			//will now use sub party bishops aswell.
			if IsTarget_InMyGroup(control) then begin
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
					
					if (IsClass_Bp(controlUser.ClassId) or IsClass_Aeore(controlUser.ClassId)) 
					and (HasSkill_Ready(cleanseID, control)) 
					and not IsTarget_Disabled(controlUser)
					and (MODE_GOD or HasItem_MinCount(control, 8874, 1)) then begin
						if (controlUser.CurMp > mpCost) then begin
							
							//someone to cleanse?
							oTarget := GetTarget_ToCleanse_FromControl_ByExceptions(control);
							if not (oTarget = nil) then begin
								CheckCancel_LessImportantSkillCasting(control);
								control.SetTarget(oTarget);
								CleanseExceptionList.Add(oTarget);
								SetTimer_OnPerson(oTarget.Oid, 1409, 3000); //1409 cleanse id
									Print(oTarget.Name + ' is debuffed!   ' + controlUser.Name + ' cleanse him!');
								if control.DUseSkill(cleanseID, false, false) then begin
									//oTarget.SetVar(GetTickCount + 2000);
									//if (User = controlUser) then result := true;
								end;
							end;
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;
*)

function CheckUse_DayOfDoom_FirstAvailableControl(): Boolean;
var
i, lowMpCount, mpCost, dayOfDoomId: Integer;
oTarget, temp: Tl2Char;
otherHealerRez: Tl2Skill;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	
	mpCost := 100;
	dayOfDoomId := 1422;
	
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
		
			if (Party.Chars.ByName(controlUser.Name, temp)) or (controlUser.Oid = User.Oid) then begin
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
					
					if IsClass_Necro(controlUser.ClassId) 
					and HasSkill_Ready(dayOfDoomId, control)
					and not IsTarget_Disabled(controlUser)
					and HasItem_MinCount(control, 8876, 1) then begin
						if (controlUser.CurMp > mpCost) then begin
							
							if Checkuse_DayOfDoom_FromControl(control) then begin
								result := true;
								exit;
							end;
							
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;
function CheckUse_NukeGroundSkill_FirstAvailableControl(): Boolean;
var
i, lowMpCount, mpCost, dayOfDoomId: Integer;
oTarget, temp: Tl2Char;
otherHealerRez: Tl2Skill;
control: Tl2Control;
UseForMembers: Boolean;
controlUser: Tl2User;
begin
	result := false;
	
	mpCost := 100;
	dayOfDoomId := 1422;
	
	
	i := 0;
	control := GetControlByIndex(i);
	while Assigned(control) do begin
		controlUser := control.GetUser;
		if not (controlUser = nil) and (control.Status = lsOnline) then begin
		
			if (Party.Chars.ByName(controlUser.Name, temp)) or (controlUser.Oid = User.Oid) then begin
				if (User.DistTo(controlUser) < MAX_RANGE_FRIEND) or (controlUser.Oid = User.Oid) then begin
					
					if IsClass_Nuker(controlUser.ClassId) 
					and HasSkill_Ready(dayOfDoomId, control) 
					and not IsTarget_Disabled(controlUser)
					and HasItem_MinCount(control, 8876, 1) then begin
						if (controlUser.CurMp > mpCost) then begin
							
							if Checkuse_DayOfDoom_FromControl(control) then begin
								result := true;
								exit;
							end;
							
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		control := GetControlByIndex(i);
	end;
end;


procedure CleanUp_RezExceptionList(startIndex: Integer = 0);
var
len, i: Integer;
oTarget: Tl2Char;
begin
	len := RezExceptionList.Count;
	if (len < 1) then exit;
	
	for i := startIndex to len - 1 do begin
		oTarget := Tl2Char(RezExceptionList.Items(i));
		if (oTarget = nil)
		or (oTarget.Name = '')
		or (oTarget.Oid = 0)
		or (User.DistTo(oTarget) > 900)
		or (not oTarget.Dead)
		or (TimerExpired_OnPerson(oTarget.Oid, 1016)) then begin
			RezExceptionList.Delete(i);
			print(oTarget.Name + ' is removed from rez exception list!');
			CleanUp_RezExceptionList(i); //Solve the rest recursively
			exit;
		end;
	end;
end;
procedure CleanUp_CleanseExceptionList(startIndex: Integer = 0);
var
len, i: Integer;
oTarget: Tl2Char;
begin
	len := CleanseExceptionList.Count;
	if (len < 1) then exit;
	
	for i := startIndex to len - 1 do begin
		oTarget := Tl2Char(CleanseExceptionList.Items(i));
		if (oTarget = nil)
		or (oTarget.Name = '')
		or (User.DistTo(oTarget) > 1250)
		or (oTarget.Dead) 
		or (IsTarget_Debuffed_GetState(oTarget) <= 0)
		or (TimerExpired_OnPerson(oTarget.Oid, 1409)) then begin //Dont keep anyone on list for more than maxTime milliseconds
			CleanseExceptionList.Delete(i);
			CleanUp_CleanseExceptionList(i); //Solve the rest recursively
			exit;
		end;
	end;
end;

function TimerEx_OnChar(oTarget: Tl2Char; nTime: Cardinal): Boolean; overload;
var
val, tick: Cardinal;
begin
	result := TimerEx_OnChar((oTarget as Tl2Live), nTime);
end;

function TimerEx_OnChar(oTarget: Tl2Live; nTime: Cardinal): Boolean; overload;
var
val, tick: Cardinal;
begin
	result := false;
	if (oTarget = nil) then exit;
	val := oTarget.GetVar;
	tick := GetTickCount;
	
	//We have not measured time on this target before,
	//so return true, and set a timer for next check
	if (val = 0) then begin
		result := true;
		oTarget.SetVar(tick + nTime); //Set time for next check
		
	//Time has passed
	end else if (val <= tick) then begin 
		result := true;
		oTarget.SetVar(tick + nTime);//Set time for next check
		
	//Time has not yet passed	
	end else if (val > tick) then begin
		//remain false
		//do nothing
	
	end;
end;

function TimerExpired_OnPerson(oID, InstanceId: Cardinal): Boolean;
var
len, i: Integer;
val, tick: Cardinal;
personTimer : TPersonTimer;
begin
	result := false;
	len := PersonTimers.Count;
	if (len <= 0) then begin
		result := true;
		exit;
	end;
	for i := 0 to len - 1 do begin
		personTimer := TPersonTimer(PersonTimers.Items(i));
		if (personTimer = nil) then continue;
		if (personTimer.Id = oID)
		and (personTimer.Instance = InstanceId) then begin
			val := personTimer.Timer;
			tick := GetTickCount;
			
			//Time has passed
			if (val <= tick) then begin 
				result := true;
				
			//Time has not yet passed	
			end else if (val > tick) then begin
				//remain false
				//do nothing
			
			end;
			exit;
			
		end;
	end;

	//If we made it the whole way through the loop, the timer is non-existent 
	result := true; //So we assume that it has passed.
end;

function SetTimer_OnPerson(oID, InstanceId, nTime: Cardinal): Boolean;
var
len, i: Integer;
val, tick: Cardinal;
personTimer, newPersonTimer : TPersonTimer;
begin
	result := false;
	len := PersonTimers.Count;
	if (len > 0) then begin
		for i := 0 to len - 1 do begin
			personTimer := TPersonTimer(PersonTimers.Items(i));
			if (personTimer = nil) then continue;
			if (personTimer.Id = oID)
			and (personTimer.Instance = InstanceId) then begin
				//Existing timer found, update the time
				tick := GetTickCount;
				personTimer.Timer := tick + nTime;
				result := true;
				exit;		
			end;
		end;
		
	end;
			
	//No existing timer was found, so make a new one.
	Print('PersonalTimer: Creating new timer for char with oID = ' + IntToStr(oID) + ' and instance id = ' + IntToStr(InstanceId));
	newPersonTimer := TPersonTimer.Create();
	tick := GetTickCount;
	newPersonTimer.Timer := tick + nTime;
	newPersonTimer.Id := oID;
	newPersonTimer.Instance := InstanceId;
	PersonTimers.Add(newPersonTimer);
	result := true;
		
end;

function GetCount_MembersDebuffed_SelfIncluded_AliveOnly(minDebuffState: Integer): Integer;
var
count, i: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	count := 0;
	if (IsTarget_Debuffed_GetState(User) >= minDebuffState) then count := 1;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.name = '') or (oTarget.Dead) or (User.DistTo(oTarget) > MAX_RANGE_FRIEND) then continue;
		if (IsTarget_Debuffed_GetState(oTarget) >= minDebuffState) then Inc(count);
 	end;
	result := count;
end;

function IsAnyPartyBishopLowMp_NotMyself(maxMp : Integer): Boolean; overload;
var
i : Integer;
oTarget: Tl2Char;
begin
	result := false;
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		if (not IsClass_Bp(oTarget.ClassId) and not IsClass_Aeore(oTarget.ClassId))  
		or (oTarget.Mp > maxMp) 
		or (oTarget.Dead) then continue;
		
		if (User.DistTo(oTarget) < 1000) then begin
			result := true;
			exit;
		end;
	end;
end;

function IsAnyPartyBishopLowMp_NotMyself(myControl: Tl2Control; maxMp : Integer): Boolean; overload;
var
i : Integer;
oTarget: Tl2Char;
myParty: TParty;
begin
	result := false;
	if not Assigned(myControl) then exit;
	myParty := myControl.GetParty();
	for i := 0 to myParty.Chars.Count - 1 do begin
		oTarget := myParty.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		if (not IsClass_Bp(oTarget.ClassId) and not IsClass_Aeore(oTarget.ClassId)) 
		or (oTarget.Mp > maxMp) 
		or (oTarget.Dead) then continue;
		
		if (User.DistTo(oTarget) < 1000) then begin
			//Print('Low mp healer found: ' + oTarget.Name + ' with mp = ' + IntToStr(oTarget.Mp));
			result := true;
			exit;
		end;
	end;
end;

function GetCount_PartyMembers_WithManaLessThan_NonBishops(maxMp: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
begin
	result := 0;
	
	if (User.Mp < maxMp) then counter := 1
	else counter := 0;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (User.DistTo(oTarget) > MAX_RANGE_FRIEND) or (oTarget.Dead) then continue;
		if (IsClass_Bp(oTarget.ClassId)) or IsClass_Aeore(oTarget.ClassId) then continue;
		
		if (oTarget.MP < maxMp) then Inc(counter);
	end;
	
	result := counter;
end;

function GetCount_PartyMembers_WithHpLessThan_Alive_NoSealLimit(maxHp: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
oBuff: Tl2Buff;
begin
	result := 0;
	
	if (User.Hp < maxHp) and not (User.Dead) then counter := 1
	else counter := 0;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (User.DistTo(oTarget) > MAX_RANGE_FRIEND) or (oTarget.Dead) then continue;
		
		if (oTarget.HP < maxHp) then begin
			if not oTarget.Buffs.ById(1509, oBuff) then //Only targets without Seal of Limit, so we can actually heal them
				Inc(counter);
		end;
	end;
	
	result := counter;
end;

function GetOtherPartyHealer_DuoBishOnly: Tl2Char;
var
oHealer: Tl2Char;
begin
	result := User;
	
	if (User.Name = GetName_Healer1) then begin
		if (Party.Chars.ByName(GetName_Healer2, oHealer)) then begin
			if not (oHealer = nil) and oHealer.Valid then begin
				result := oHealer;
			end;
		end;
	
	end else if (User.Name = GetName_Healer2) then begin
		if (Party.Chars.ByName(GetName_Healer1, oHealer)) then begin
			if not (oHealer = nil) and oHealer.Valid then begin
				result := oHealer;
			end;
		end;
	end;
end;

function GetParty_AverageHp_AliveOnly: Integer;
var
i, counter, CurHp, TotalHp: Integer;
oTarget: Tl2Char;
begin
	result := 100;
	TotalHp := 0;
	counter := 0;
	for i := 0 to Party.Chars.Count - 1 do begin
	
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then Continue;
		if (oTarget = nil) then Continue;   
		if (oTarget.Dead) or (User.DistTo(oTarget) > MAX_RANGE) then continue;  
		
		TotalHp := TotalHp + oTarget.Hp;
		Inc(counter);
	end;
	
	if (counter < 1) then exit;
	result := Round(TotalHp / counter);
end;



function GetParty_AverageHp_DeadIncluded: Integer;
var
i, counter, CurHp, TotalHp: Integer;
oTarget: Tl2Char;
begin
	result := 100;
	TotalHp := 0;
	counter := 1;
	for i := 0 to Party.Chars.Count - 1 do begin
	
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then Continue;
		if (oTarget = nil) then Continue;   
		if (User.DistTo(oTarget) > MAX_RANGE) then continue;  
		
		if not (oTarget.Dead) then
			TotalHp := TotalHp + oTarget.Hp;
			
		Inc(counter);
	end;
	
	if (counter < 1) then exit;
	result := Round(TotalHp / counter);
end;

function IsTime_ToPartyUd_Pve: Boolean;
var
i, DeadCount : Integer;
oTarget: Tl2Char;
udBuff: Tl2Buff;
begin
	result := false;
	
	DeadCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		
		//if anyone already has party ud, dont cast it again.
		if (oTarget.Buffs.ById(528, udBuff)) then exit;
		
		if (oTarget.Dead)
		and (User.DistTo(oTarget) <= 900) then Inc(DeadCount);
	end;
	
	if (GetParty_AverageHp_AliveOnly < 55) 
	and (DeadCount < 4)
	and (GetCount_PartyBishopsAlive >= 1) then begin
		result := true;
	end;
end;

function IsTime_ToPartyUd_Pvp: Boolean;
var
i, DeadCount : Integer;
oTarget: Tl2Char;
begin
	result := false;
	
	DeadCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Dead)
		and (User.DistTo(oTarget) <= 900) then Inc(DeadCount);
	end;
	
	if (GetParty_AverageHp_AliveOnly < 70) 
	and (DeadCount < 4)
	and (GetCount_PartyBishopsAlive >= 1) then begin
		result := true;
	end;
end;

function GetCount_PartyBishopsAlive: Integer;
var
i, count: Integer;
oTarget: Tl2Char;
begin
	count := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Dead) or not (IsClass_Bp(oTarget.ClassId))then continue;
		if (User.DistTo(oTarget) > 900) then break;
		Inc(count);
	end;
	result := count;
end;

function IsTime_ToMajorGroupHeal: Boolean;
var
i, MinInjuredPartyCount, InjuredCount : Integer;
oTarget, heal1, heal2, oHealer: Tl2Char;
condition1, condition2: Boolean;
begin
	result := false;
	oHealer := user;
	
	condition1 := false;
	condition2 := false;
	
	MinInjuredPartyCount := 4;
	
	InjuredCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Hp < 87)
		and not (oTarget.Dead)
		and (User.DistTo(oTarget) <= 900) then Inc(InjuredCount);
	end;
	if (InjuredCount > 4) then begin
		condition1 := true;
	end;
	
  
	InjuredCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Hp < 85)
		and not (oTarget.Dead)
		and not (IsFriend_Invincible(oTarget))
		and (User.DistTo(oTarget) <= 900) then Inc(InjuredCount);
	end;
	
	if (InjuredCount >= MinInjuredPartyCount) then condition2 := true;
	
	
	if not ShouldICastSpell_Healers_ByPriority(1402) then Exit;	
		
	if IsAnyHealer_CastingSpellById(1402) then begin
		Exit;
	end;
		
		
	result := condition1 or condition2;
end;



function IsTime_ToBrilliantHeal: Boolean;
var
i, MinInjuredPartyCount, InjuredCount : Integer;
oTarget, heal1, heal2, oHealer: Tl2Char;
condition1, condition2: Boolean;
begin
	result := false;
	oHealer := user;
	
	condition1 := false;
	condition2 := false;
	
	MinInjuredPartyCount := 4;
	
	InjuredCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Hp < 87)
		and not (oTarget.Dead)
		and (User.DistTo(oTarget) <= 900) then Inc(InjuredCount);
	end;
	if (InjuredCount > 4) then begin
		condition1 := true;
	end;
	
  
	InjuredCount := 0;
	for i := 0 to Party.Chars.Count -1 do begin
		oTarget := Party.Chars.Items(i);
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		if (oTarget.Hp < 85)
		and not (oTarget.Dead)
		and not (IsFriend_Invincible(oTarget))
		and (User.DistTo(oTarget) <= 900) then Inc(InjuredCount);
	end;
	
	if (InjuredCount >= MinInjuredPartyCount) then condition2 := true;
	
	
	if not ShouldICastSpell_Healers_ByPriority(11757) then Exit;	
		
	if IsAnyHealer_CastingSpellById(11757) then begin
		Exit;
	end;
		
		
	result := condition1 or condition2;
end;


function ShouldIAgro: Boolean;
var
oTank: Tl2Char;
begin
	result := true;
	if (User.Name = GetName_Sws) 
	and (CharList.ByName(GetName_Bd, oTank))
	and (IsTarget_GoodState_Party(oTank, 600))
	and (IsSkillReady_OtherBotChar(28, oTank.Name)) then result := false; //Aggresion
	
	if not HasSkill_Ready(28) then result := false;
end;

function CheckRemove_OrbisCurse: Boolean;
var
oBuff: Tl2Buff;
botWasOn: Boolean;
oTarget: Tl2Char;
begin
	result := false;
	if User.Buffs.ById(14196, oBuff) then begin
		botWasOn := Engine.GetFaceState(0);
		if (botWasOn) then begin
			Engine.FaceControl(0, false);
			Delay(500);
		end;
		Engine.StopCasting;
		Engine.CancelTarget();
		oTarget := GetNearestDDMember;
		if not (oTarget = nil) then begin
			Engine.SetTarget(oTarget);
			Delay(250);
			result := Engine.UseSkill(14528); //Spread Abnormality
			if botWasOn then begin
				Engine.FaceControl(0, true);
			end;
		end;
	end;
end;

function GetNearestDDMember: Tl2Char;
var
i, curRange, lastRange: Integer;
oCurTarget, oLastTarget: Tl2Char;
begin
	result := nil;
	lastRange := 5000;
	for i := 0 to Party.Chars.Count - 1 do begin
		oCurTarget := Party.Chars.Items(i);
		if (oCurTarget = nil) then continue;
		
		curRange := User.DistTo(oCurTarget);
		
		if (curRange < lastRange) then begin
			lastRange := curRange;
			oLastTarget := oCurTarget;
		end;
	end;
	
	result := oLastTarget;
end;


function GetTarget_MainAssist: Tl2Char;
var
i, partyNum: Integer;
oTarget: Tl2Char;
CharName: string;
MainAssistNameList: array of string;
isSubPartyMember: Boolean;
begin  
	
	if (Mode_AssistLeader) then begin
		CharName := GetName_LocalLeader;
		if (CharList.ByName(CharName, oTarget)) then begin
			result := oTarget;
			exit;
		end;
	end;
	
	result := User;
	partyNum := GetPartyNum;
	if (partyNum = 1) then begin
		//Print('Find MA: 1st party');
		SetLength(MainAssistNameList, 6);
		MainAssistNameList[0] := 'iSky';
		MainAssistNameList[1] := 'Trin1ty';
		MainAssistNameList[2] := 'Chaos';
		MainAssistNameList[3] := 'Kaballius';
		MainAssistNameList[4] := 'Ragnator';
		MainAssistNameList[5] := 'BlackJesus';
	end else if (partyNum = 2) then begin
		//Print('Find MA: 2nd party');
		SetLength(MainAssistNameList, 6);
		MainAssistNameList[0] := 'iReinn';
		MainAssistNameList[1] := 'iStorm';
		MainAssistNameList[2] := 'Igneous';
		MainAssistNameList[3] := 'NewEra';
		MainAssistNameList[4] := 'iSpike';
		MainAssistNameList[5] := 'Achilles';
	end else if (partyNum = 3) then begin
		//Print('Find MA: 3rd party');
		SetLength(MainAssistNameList, 7);
		MainAssistNameList[0] := 'Undisputed';
		MainAssistNameList[1] := 'Insanity';
		MainAssistNameList[2] := 'iFury';
		MainAssistNameList[3] := 'iPain';
		MainAssistNameList[4] := 'Eviscerator';
		MainAssistNameList[5] := 'Devling';
		MainAssistNameList[6] := 'EyeCandy';
	end else begin
		exit;
	end;
	
	isSubPartyMember := (GetSubPartyNum > 0);

	for i := 0 to Length(MainAssistNameList) - 1 do begin
		CharName := MainAssistNameList[i];
		//print('Check main assist by name: ' + CharName);
		if (CharName = User.Name) 
		and not (IsTarget_Disabled(user)) then begin
			result := user;
			Exit;
		end;
		if not (isSubPartyMember) then begin
			//CharList.ByName(CharName, oTarget);
			if (Party.Chars.ByName(CharName, oTarget))
			and not (oTarget = nil)
			and (User.DistTo(oTarget) < MAX_ASSIST_RANGE_PVP) 
			and not (IsMainAssistDisabled(oTarget)) then begin
				result := oTarget;
				Exit;
			end;
		end else begin
			//Sub party members...
			if (CharList.ByName(CharName, oTarget))
			and not (oTarget = nil)
			and (User.DistTo(oTarget) < MAX_ASSIST_RANGE_PVP) 
			and not (IsMainAssistDisabled(oTarget)) then begin
				result := oTarget;
				Exit;
			end;
		end;
	end;
end;

function SetTarget_MainAssist: Boolean;
var
ma: Tl2Char;
oLiveTarget: Tl2Live;
begin
	result := false;
	
	ma := GetTarget_MainAssist;
	if (ma = nil) or (ma.Oid = user.Oid) then begin
		//if (ma.Oid = user.Oid) then print('I am main assist!')
		//else Print('Main assist not found!');
		exit;
	end;// else print('Main assist found: ' + ma.Name);
	
	oLiveTarget := ma.Target;
	if (oLiveTarget = nil) then begin 
		Print('Main assist does NOT have a target!');
		exit;
	end;
	if (PvpLoaded) then begin
		if not IsTarget_Valid_Char(oLiveTarget) then begin
			print('Pvp Assist: Main assist''s target is not valid. target = ' + oLiveTarget.Name);
			exit;
		end;
		if not (User.Target = oLiveTarget) then begin
			Engine.CancelTarget();
			Engine.SetTarget(oLiveTarget);
			//Print('Pvp Assist: Assist ' + ma.Name + ' - target -> ' + oLiveTarget.Name);
		end;
		result := true;
	end else begin
		if not IsTarget_Valid_Live(oLiveTarget) then begin
			print('Main assist''s target is not valid!');
			exit;
		end;
		if not (User.Target = oLiveTarget) then begin
			Engine.CancelTarget();
			Engine.SetTarget(oLiveTarget);
		end;
		//Print('Assist target found: ' + oLiveTarget.Name);
		result := true;
	end;
end;

function IsMainAssistDisabled(oMainAssist: Tl2Char): Boolean;
var
i: Integer;
oTargetsTarget, tempLive: Tl2Live;
oTarget: Tl2Char;
begin
	result := true;
	if not IsTarget_ValidAndVisible_Char(oMainAssist) then exit;
	if (IsTarget_Disabled(oMainAssist)) then exit;
	
	oTargetsTarget := oMainAssist.Target;
	if (oTargetsTarget = nil) then exit;
  
  
	if PvpLoaded and (CharList.ByName(oTargetsTarget.Name, oTarget)) then begin
		if (IsTarget_Friendly(oTarget))
		or (User.DistTo(oMainAssist) > MAX_ASSIST_RANGE_PVP) 
		or (IsClass_Tank(oTarget.ClassId) and not (IsOnlyTanksLeft)) then begin
			result := true;
			exit;
		end;
	end else begin
		if (not allowEmptyStringMobNames) and not (NpcList.ByName(oTargetsTarget.Name, tempLive)) then begin
			result := true;
			exit;
		end;
	end;
	result := false;
end;


function IsOnlyTanksLeft: Boolean;
//checked
var
i: Integer;
oTarget: Tl2Char;
begin
	result := true;
	for i := 0 to CharList.Count -1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) then begin
			WriteError('IsOnlyTanksLeft: oTarget = nil');
			Continue;
		end;
		if (IsTarget_Valid_Char(oTarget)) then begin
			if not (IsClass_Tank(oTarget.ClassID)) then begin
				result := false;
				exit;
			end;
		end;
	end;
end;

function IsOtherPlayersNearby(minRange: Integer): Boolean;
var
i: Integer;
oTarget: Tl2Char;
begin
	result := false;
	if not DiscreteMode then exit; //Disabled
	for i := 0 to CharList.Count - 1 do begin
		oTarget := CharList.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		if not (oTarget.IsMember)
		and (User.DistTo(oTarget) < minRange) then begin
			result := true;
			Exit;
		end;
	end;


end;






function SetPoint_PartyCenter: void;
var
EndX, EndY, i, z, nCounter: Integer;
oTarget, obj, oLeader: Tl2Char;
begin
	//Print('Set Party Center Started');
	PT_PX := User.X;
	PT_PY := User.Y;
	PARTY_PT_DIST := 0;
	
	if Mode_LeaderIsCenter 
	and (CharList.ByName(GetName_LocalLeader, oLeader)) 
	and (User.DistTo(oLeader) < MAX_RANGE_FRIEND) then begin
		if (oLeader = nil) then WriteError('GetPartyCenterPoint: oLeader = nil');
		PT_PX := oLeader.X;
		PT_PY := oLeader.Y;
		z := User.z;
		PARTY_PT_DIST := User.DistTo(PT_PX, PT_PY, z);
		//Print('Set Party Center Ended 1');
		exit;
	end;
	
	nCounter := 1; //(1 because, we add Users location at start)
	EndX := User.X;
	EndY := User.Y;
	if not (DuoPartyMode) then begin
		for i := 0 to Party.Chars.Count - 1 do begin
			oTarget := Party.Chars.Items(i);
			if not IsTarget_ValidAndVisible_Char(oTarget) then begin
				continue;
			end;
			if (User.DistTo(oTarget) > MAX_RANGE_FRIEND) then break;
		
			EndX := EndX + oTarget.X;
			EndY := EndY + oTarget.Y;
			Inc(nCounter);
		end;
	end else begin
		for i := 0 to CharList.Count - 1 do begin
			oTarget := CharList.Items(i);
			if not IsTarget_ValidAndVisible_Char(oTarget) then begin
				continue;
			end;
			if (User.DistTo(oTarget) > MAX_RANGE_FRIEND) then break;
			
			if not (IsTarget_Friendly(oTarget)) then continue;
		
			EndX := EndX + oTarget.X;
			EndY := EndY + oTarget.Y;
			Inc(nCounter);
		end;
	end;
	
	if (nCounter >= 2) then begin
		EndX := EndX div nCounter;
		EndY := EndY div nCounter;
		PT_PX := EndX;
		PT_PY := EndY;
	end else begin
		if (CharList.ByName(GetName_LocalLeader, oLeader)) 
		and (User.DistTo(oLeader) < MAX_RANGE_FRIEND) then begin
			if (oLeader = nil) then WriteError('GetPartyCenterPoint: oLeader = nil');
			PT_PX := oLeader.X;
			PT_PY := oLeader.Y;
		end else begin
			PT_PX := user.X;
			PT_PY := user.y;
		end;
	end;
	z := User.z;
	PARTY_PT_DIST := User.DistTo(PT_PX, PT_PY, z);
	//Print('Set Party Center Ended');
end;

function ObjectDistTo_PartyCenter(obj: Tl2Spawn): Cardinal;
var
x, y: Integer;
begin
	result := 1000000;
	if (obj = nil) or ((obj.x = 0) and (obj.y = 0)) then exit;
	x := obj.x;
	y := obj.y;
	result := GetDistanceBetweenPoints(PT_PX, PT_PY, x, y);
end;

function GetPath_CharSettings: string;
begin
	result := Script.Path + 'Adrenalin Char Settings\\';
end;

function GetPath_FileSettings: string;
begin
	result := Script.Path + 'Adrenalin Folder Files\\';
end;
function GetPath_ZoneFolder: string;
begin
	result := Script.Path + 'Adrenalin Folder Files\\Settings\\';
end;

function cLoadZone(zoneName: string): Boolean;
begin
	result := Engine.LoadZone(GetPath_ZoneFolder + zoneName);
end;
function cLoadConfig(configName: string): Boolean;
begin
	result := Engine.LoadConfig(GetPath_CharSettings + configName);
end;

function GetName_Leader: string;
var
sName: string;
begin
	result := '';
	if (SettingList = nil) then Exit;
	sName := GetRowStrValueBelow('Leader:', SettingList);
	result := sName;
end;

function GetName_CoLeader: string;
var
sName: string;
begin
	result := '';
	if (SettingList = nil) then Exit;
	sName := GetRowStrValueBelow('CoLeader:', SettingList);
	
	result := sName;
end;
function GetName_LocalCoLeader: string;
var
sName: string;
pNum: Integer;
begin
	result := '';
	if (SettingList = nil) then Exit;
	pNum := GetPartyNum;
	if (pNum = 1) then 
		sName := GetRowStrValueBelow('CoLeader:', SettingList)
	else if (pNum = 2) then 
		sName := GetRowStrValueBelow('SecondCoLeader:', SettingList)
	else if (pNum = 3) then 
		sName := GetRowStrValueBelow('ThirdCoLeader:', SettingList)
	else begin
		sName := '';
		Print('WARNING: No local co-leader found!');
	end;
	result := sName;
end;

function GetName_SecondLeader: string;
var
sName: string;
begin
	result := '';
	if (SettingList = nil) then Exit;
	sName := GetRowStrValueBelow('SecondLeader:', SettingList);
	result := sName;
end;
function GetName_ThirdLeader: string;
var
sName: string;
begin
	result := '';
	if (SettingList = nil) then Exit;
	sName := GetRowStrValueBelow('ThirdLeader:', SettingList);
	result := sName;
end;
function GetName_FourthLeader: string;
begin
	result := 'iTyrant1';
end;
function GetName_FifthLeader: string;
begin
	result := 'iTyrant11';
end;

function GetName_LocalLeader: string;
begin
	result := '';
	if (DuoPartyMode) then 
		result := GetName_Leader
	else if (GetPartyNum = 3) then 
		result := GetName_ThirdLeader
	else if (GetPartyNum = 2) then 
		result := GetName_SecondLeader
	else if (GetPartyNum = 4) then 
		result := GetName_FourthLeader
	else if (GetPartyNum = 5) then 
		result := GetName_FifthLeader
	else
		result := GetName_Leader;
end;

function GetName_Server: string;
var
sName: string;
begin
	result := '';
	if (SettingList = nil) then Exit;
	sName := GetRowStrValueBelow('ServerName:', SettingList);
	result := sName;
end;


function GetName_Sws: string;
var
sName: string;
begin
	result := 'Elreolas';
end;
function GetName_Bd: string;
var
sName: string;
begin
	result := 'Unexpected';
end;
function GetName_Ee: string;
var
sName: string;
begin
	result := 'noSheyrena';
end;

function GetPartyNum: Integer;
var
oLeader: Tl2Char;
sLead1, sLead2, sLead3, sLead4, sLead5: string;
begin
	result := 1;
	sLead1 := GetName_Leader;
	sLead2 := GetName_SecondLeader;
	sLead3 := GetName_ThirdLeader;
	sLead4 := GetName_FourthLeader;
	sLead5 := GetName_FifthLeader;
	
	if (User.Name = sLead1) then begin
		result := 1;
		exit;
	end else if (User.Name = sLead2) then begin
		result := 2;
		exit;
	end else if (User.Name = sLead3) then begin
		result := 3;
		exit;
	end else if (User.Name = sLead4) then begin
		result := 4;
		exit;
	end else if (User.Name = sLead5) then begin
		result := 5;
		exit;
	end;
	
	
	if (Party.Chars.Count > 0) then begin
		if Party.Chars.ByName(sLead1, oLeader) then begin
			result := 1;
			exit;
		end else if (Party.Chars.ByName(sLead2, oLeader)) then begin
			result := 2;
			exit;
		end else if (Party.Chars.ByName(sLead3, oLeader)) then begin
			result := 3;
			exit;
		end else if (Party.Chars.ByName(sLead4, oLeader)) then begin
			result := 4;
			exit;
		end else if (Party.Chars.ByName(sLead5, oLeader)) then begin
			result := 5;
			exit;
		end else begin
			result := GetSubPartyNum();
		end;
	end;	
end;

function GetSubPartyNum(control: Tl2Control): Integer; overload;
var
sLead1, sLead2, sLead3: string;
oLeader: Tl2Char;
cUser: Tl2User;
begin
	result := 0;
	if not Assigned(control) then exit;
	
	sLead1 := GetName_FirstSubPartyLeader;
	sLead2 := GetName_SecondSubPartyLeader;
	sLead3 := GetName_ThirdSubPartyLeader;
	
	cUser := control.GetUser();
	if (cUser = nil) or (cUser.Name = '') then exit;
	
	if (cUser.Name = sLead1) then begin
		result := 1;
		exit;
	end else if (cUser.Name = sLead2) then begin
		result := 2;
		exit;
	end else if (cUser.Name = sLead3) then begin
		result := 3;
		exit;
	end;
	
	if (control.GetParty.Chars.ByName(sLead1, oLeader)) then begin
		result := 1;
		exit;
	end else if (control.GetParty.Chars.ByName(sLead2, oLeader)) then begin
		result := 2;
		exit;
	end else if (control.GetParty.Chars.ByName(sLead3, oLeader)) then begin
		result := 3;
		exit;
	end;
end;

function GetSubPartyNum(): Integer; overload;
begin
	result := GetSubPartyNum(Engine);
end;

function GetName_Healer1_ByPartyNum(partyNum: Integer): string;
var
sName: string;
begin
	result := '';
	sName := '';
	if (SettingList = nil) then Exit;
	if (partyNum = 1) then
		sName := GetRowStrValueBelow('Bishop_1:', SettingList)
	else if (partyNum = 2) then
		sName := GetRowStrValueBelow('Bishop_4:', SettingList)
	else if (partyNum = 3) then
		sName := GetRowStrValueBelow('Bishop_7:', SettingList);
		
	result := sName;
end;

function GetName_Healer1: string;
var
sName: string;
partyNum: Integer;
begin
	result := '';
	sName := '';
	if (SettingList = nil) then Exit;
	partyNum := GetPartyNum;
	if (partyNum = 1) then
		sName := GetRowStrValueBelow('Bishop_1:', SettingList)
	else if (partyNum = 2) then
		sName := GetRowStrValueBelow('Bishop_4:', SettingList)
	else if (partyNum = 3) then
		sName := GetRowStrValueBelow('Bishop_7:', SettingList)
	else if (partyNum = 4) then
		sName := 'iBishop1'
	else if (partyNum = 5) then
		sName := 'iBishop11';
		
	result := sName;
end;
function GetName_Healer2: string;
var
sName: string;
partyNum: Integer;
begin
	result := '';
	sName := '';
	if (SettingList = nil) then Exit;
	partyNum := GetPartyNum;
	if (partyNum = 1) then
		sName := GetRowStrValueBelow('Bishop_2:', SettingList)
	else if (partyNum = 2) then
		sName := GetRowStrValueBelow('Bishop_5:', SettingList)
	else if (partyNum = 3) then
		sName := GetRowStrValueBelow('Bishop_8:', SettingList);
		
	result := sName;
end;
function GetName_Healer3: string;
var
sName: string;
partyNum: Integer;
begin
	result := '';
	sName := '';
	if (SettingList = nil) then Exit;
	partyNum := GetPartyNum;
	if (partyNum = 1) then
		sName := GetRowStrValueBelow('Bishop_3:', SettingList)
	else if (partyNum = 2) then
		sName := GetRowStrValueBelow('Bishop_6:', SettingList)
	else if (partyNum = 3) then
		sName := GetRowStrValueBelow('Bishop_9:', SettingList);
		
	result := sName;
end;


function GetTarget_ToFollow(): Tl2Char;
var
oTargetToFollow: Tl2Char;
begin
	result := User;
	if (User.Name = GetName_LocalLeader) then exit;
	if CharList.ByName(GetName_LocalLeader, oTargetToFollow) and (User.DistTo(oTargetToFollow) < 7000) then begin
		result := oTargetToFollow;		
	end else if CharList.ByName(Party.Leader.Name, oTargetToFollow) and (User.DistTo(oTargetToFollow) < 7000) then begin
		result := oTargetToFollow;	
	end;
end;

function GetRowIntValueBelow(SearchString: string; SettingList: TStringList): Integer;
begin
  if (SettingList = nil) then WriteError('GetRowIntValueBelow: SettingList = nil');
  result := StrToInt(SettingList[((SettingList.IndexOf(SearchString)) + 1)]);
end;
function GetRowStrValueBelow(SearchString: string; SettingList: TStringList): string;
begin
  if (SettingList = nil) then WriteError('GetRowStrValueBelow: SettingList = nil');
  result := SettingList[((SettingList.IndexOf(SearchString)) + 1)];
end;
function GetRowBoolValueBelow(SearchString: string; SettingList: TStringList): Boolean;
var
TrueFalse: string;
begin
  if (SearchString = null) then WriteError('GetRowBoolValueBelow: SearchString = nil');
  if (SettingList = nil) then WriteError('GetRowBoolValueBelow: SettingList = nil');
  TrueFalse := SettingList[((SettingList.IndexOf(SearchString)) + 1)];
  if (TrueFalse = 'true') then
    result := true
  else 
    result := false;
end;




function GetCount_DeadPartyWithinRange(nMaxRange: Integer; skipDodTarget: Boolean = true): Integer;
var
i, DeadCount : Integer;
oTarget: Tl2Char;
oBuff: Tl2Buff;
begin
		//print('GetCount_DeadPartyWithinRange: started');
	result := 0;
	DeadCount := 0;
	for i := 0 to Party.Chars.Count - 1 do begin
		//print('GetCount_Dead: loop start');
		oTarget := Party.Chars.Items(i);
		//print('GetCount_Dead: check valid');
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		//print('GetCount_Dead: check dead');
		if not (oTarget.Dead) then continue;
		
		//dod blocks rez
		if skipDodTarget and (oTarget.Buffs.ById(5145, oBuff)) then continue;
		
		//print('GetCount_Dead: check range');
		if (User.DistTo(oTarget) < nMaxRange) then Inc(DeadCount);
		//print('GetCount_Dead: inc dead count');
	end;
	result := DeadCount;
		//print('GetCount_DeadPartyWithinRange: ended');
end;

function GetCount_DeadClanPlayersWithinRange(nMaxRange: Integer; skipDodTarget: Boolean = true): Integer;
var
i, DeadCount : Integer;
oTarget: Tl2Char;
oBuff: Tl2Buff;
begin
		//print('GetCount_DeadPartyWithinRange: started');
	result := 0;
	DeadCount := 0;
	for i := 0 to CharList.Count - 1 do begin
		//print('GetCount_Dead: loop start');
		oTarget := CharList.Items(i);
		//print('GetCount_Dead: check valid');
		if not IsTarget_ValidAndVisible_Char(oTarget) then continue;
		//print('GetCount_Dead: check dead');
		if not (oTarget.Dead) then continue;
		if not (oTarget.Clan = User.Clan) then continue;
		//dod blocks rez
		if skipDodTarget then begin
			if (oTarget.Oid = User.Oid) or (oTarget.IsMember) then begin
				if (oTarget.Buffs.ById(5145, oBuff)) then continue;
				
			end else begin
				if (CheckIfControlHasBuff_ByName(5145, oTarget.Name)) then continue;
			end;
		end;
		//print('GetCount_Dead: check range');
		if (User.DistTo(oTarget) < nMaxRange) then Inc(DeadCount);
		//print('GetCount_Dead: inc dead count');
	end;
	result := DeadCount;
		//print('GetCount_DeadPartyWithinRange: ended');
end;

function CheckMove_DeadParty_LeaderOnly: Boolean;
var
deadMember : Tl2Char;
TempX, TempY, TempZ: Integer;
begin
	result := false;
	//Print('Check move to dead started');
	if not (User.Name = GetName_LocalLeader) then  begin
		//Print('Check move to dead ended, not enabled.');
		exit;
	end;
	
	//If we are not under attack:	
	if (GetCount_DeadPartyWithinRange(7000) > 0) then begin
		deadMember := GetTarget_NearestDead_Party(7000);
		if not IsTarget_ValidAndVisible_Char(deadMember) then begin
			//Print('Check move to dead ended, not enabled. 2');
			exit;
		end;
		if (User.DistTo(deadMember) > 150)
		and not (deadMember.Oid = user.Oid) then begin
			TempX := deadMember.X;
			TempY := deadMember.Y;
			TempZ := deadMember.Z;
			
			MoveTo_Timer(TempX, TempY, TempZ);
			Print('Move to dead member');
			result := true;
			(*
			if (deadMember.InZone) then begin
				if not (User.InZone) then begin
					MoveTo_BackToZone;
				end;
				if (User.InZone) then begin
					result := MapMove(TempX, TempY);
				end else begin
				
					//	if user is not in zone
					MoveTo_Timer(TempX, TempY, TempZ);
					result := true;
				end;
			end else begin
			
				//  if deadMember is not in zone
			end;*)
		end;
	end;
	
	//Print('Check move to dead Ended');
end;



function MapMove(X, Y: Integer): boolean;
var
 i, j, stepX,stepY, nCurrentX, nCurrentY, nCurrentZ, z, TempX, TempY, count: integer;
 oItem : Tl2Item;
 WasBotOn: Boolean;
begin
	result := false; 

	if (User.Dead) then Exit;

	if not (user.inzone) then 
		MoveTo_BackToZone;
		
	
	
	if not (User.InZone) then Begin
		Print('MapMove_: Could not find out way back into farming zone, exit!');
		Exit;
	end;
	
	count := curPath.Count; 
	
	//  If path is not yet created, 
	if (count <= 0) or (curPath = nil) then begin
		curPath := TList.Create;
		TempX := User.x; 
		TempY := User.Y;
		Engine.FindPath(TempX, TempY, X, Y, curPath);
		curPathStep := 0;
	end;
	
	//	Check for old unfinished path.
	//	If last step is not near our destination, create new path
	if (count >= 2) then begin
		stepX := integer(curPath[count - 2]);
		stepY := integer(curPath[count - 1]);
		if (abs(stepX - X) > 75) and (abs(stepY - Y) > 75) then begin
			curPath.Free;
			curPath := TList.Create;
			TempX := User.x; 
			TempY := User.Y;
			Engine.FindPath(TempX, TempY, X, Y, curPath);
			curPathStep := 0;
		end;
	end;
	  
	
	//  At this point, path is created, so move
	
	//  Are we done?
	z := User.Z;
	if (user.InRange(X, Y, z, 100)) or (curPathStep > (count div 2) - 1)   then begin
		result := true;
		curPath.Free;
		curPath := TList.Create;
		curPathStep := 0;
		Exit;
	
	end else begin
		//	If we are not yet done, pick up where we left off
		stepX := integer(curPath[curPathStep*2]);
		stepY := integer(curPath[(curPathStep*2)+1]);
		TempX := User.x; 
		TempY := User.Y;
		
		//	Step Completed?
		if (abs(TempX - stepX) < 40) and (abs(TempY - stepY) < 40) then begin
			Inc(curPathStep);
			Exit;
		
		//	If step is not complete, move to end of step!
		end else begin
			LockCheck_MoveAndBot_Off;
			Engine.CancelTarget;
			MoveTo_Timer(stepX, stepY, 0);
			Delay(1250);
			LockCheck_MoveAndBot_On;		
		end;
		
	end;
end;

function MoveTo_BackToZone: Boolean;
//checked
var
i, j, x, y, z, nRadius, nAngle, TempX, TempY: Integer;
begin
	result := false;
	x := 0;
	y := 0;
	z := User.z;
	if not (user.inzone) then begin
		for i:= 0 to 300 do begin
			for j := 0 to 72 do begin
				//Minimum range = 75
				nRadius := 75 + (5 * i);  //Start looking for a point at range = 75 distance away, and go up
				nAngle := 5*j; //Increase angle by 5 for every iteration
				TempX := User.X;
				TempY := User.Y;
				x := GetX_OnCircle(nRadius, TempX, nAngle);
				y := GetY_OnCircle(nRadius, TempY, nAngle);
				if (Engine.InZone(x, y, z)) then
					break;
			end;
			if (Engine.InZone(x, y, z)) then
				break;
		end;  
		if (Engine.InZone(x, y, z)) then begin
			MoveTo_Timer(x, y, z);
			Delay(600);
			MoveTo_Timer(x, y, z);
			Delay(600);
			result := true;
		end;
	end else begin
		result := true;
	end;
end;


function MoveToTarget_Timeout_Live(oTarget: Tl2Live; rangeToTarget, nTimeOut: Integer): Boolean;
var
movePoint: TPoint;
nTime, x1, x2, y1, y2, z: Integer;
begin
	result := false;
	if (oTarget = nil) or not oTarget.Valid then exit;
	
	nTime := 0;
	x1 := oTarget.X;
	y1 := oTarget.Y;
	x2 := User.X;
	y2 := User.Y;
	// negate rangeToTarget, so we get a point in front of target, instead of behind
	movePoint := GetPointBehindTargetFromTarget(x1, y1, x2, y2, -rangeToTarget);
	while true do begin
	
		if (oTarget = nil) then exit;
		if (User.DistTo(oTarget) <= rangeToTarget) 
		or (oTarget.Dead)
		or (nTime > nTimeOut) then break;
		
		z := oTarget.Z;
		MoveTo_Timer(movePoint.X, movePoint.Y, z);
		
		Delay(300);
		nTime := nTime + 300;
	end;
	result := (not (oTarget = nil)) and (User.DistTo(oTarget) <= rangeToTarget);
end;

function MoveTo_TimeOut(x, y, z, nMaxTime: Integer): Boolean;
var
nIterations, i: Integer;
begin
	result := false;
	if (nMaxTime < 200) then nMaxTime := 200;
	nIterations := Round(nMaxTime / 200);
	
	for i := 1 to nIterations do begin
		MoveTo_Timer(x, y, z);
		if (User.InRange(x, y, z, 25)) then begin
			result := true;
			exit;
		end;
		Delay(200);		
	end;	
end;

function IsUnderAttack: Boolean;
var
i, maxRange: Integer;
oTarget, oTargetsTarget: Tl2Live;
debug: Boolean;
begin
	debug := false;
	//Print('IsUnderAttack Started.');
	result := false;
	if (PvpLoaded = null) then WriteError('IsUnderAttack: PvpLoaded = null');
	if PvpLoaded then begin
		result := true;
		//if debug then Print('UnderAttack: We are in pvp - return true');
		Exit;
	end;
	//if (GetMinPartyHp < 76) and (Party.Chars.Count > 0) and GetIsSomeMemberInCombat then result := true;
	
	
	
	if (isJava) then begin
		if (Party.Chars.Count < 2) then maxRange := 900
		else maxRange := MAX_RANGE_NPC_ATTACKING;
		
		for i := 0 to NpcList.Count -1 do begin
			oTarget := NpcList.Items(i);
			if (oTarget = nil) then begin
				//if debug then Print('IsUnderAttack: oTarget = nil');
				Continue;
			end;
			
			//if debug then begin
				//Print('UnderAttack: ' + oTarget.Name + ' is valid = ' + BoolToStr(IsTarget_Valid_Live(oTarget)));
				//Print('UnderAttack: ' + oTarget.Name + ' is in combat = ' + BoolToStr(oTarget.InCombat));
				//Print('UnderAttack: ' + oTarget.Name + ' is on us = ' + BoolToStr(IsTarget_OnUs_Live(oTarget)));
			//end;
			if (User.DistTo(oTarget) > maxRange) then break;
			if IsTarget_Valid_Live(oTarget)
			//and (oTarget.InCombat)
			and IsTarget_OnUs_Live(oTarget) then begin
				result := true;
				//Print('IsUnderAttack: Ended Succesfully 1');
				Exit;
			end;
		end;
	end else begin
		for i := 0 to NpcList.Count -1 do begin
			oTarget := NpcList.Items(i);
			if (oTarget = nil) then begin
				Continue;
			end;
			oTargetsTarget := oTarget.Target;
			if (User.DistTo(oTarget) > MAX_RANGE_NPC_ATTACKING) then break;
			if ((oTargetsTarget.IsMember or (DuoPartyMode and (IsTarget_Friendly(oTargetsTarget))))
			or (oTargetsTarget.Oid = user.Oid))
			and IsTarget_Valid_Live(oTarget) then begin
				result := true;
				//Print('IsUnderAttack: Ended Succesfully 2');
				Exit;
			end;
		end;		
	end;
	if (result = null) then WriteError('IsUnderAttack: result = nil');
	//Print('IsUnderAttack: Ended Unsuccesfully');
end;

function BoolToStr(statement: Boolean): string;
begin
	if (statement) then result := 'True'
	else result := 'False';
end;

function GetIsSomeMemberInCombat: Boolean;
var
i: Integer;
oTarget: Tl2Char;
begin
	result := false;
	if (User.InCombat) then begin
		result := true;
		exit;	
	end;
	
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (not oTarget.Valid) or (oTarget.Name = '') then continue;
		if (User.DistTo(oTarget) > MAX_RANGE_FRIEND) then continue;
		if (oTarget.InCombat) then begin
			result := true;
			exit;
		end;
	end;
end;


function GetMinPartyHp: Integer;
//checked
var
i, nLastHp, nCurHp: Integer;
oTarget, cchar: Tl2Char;
begin 
  nLastHp := User.hp;
  for i := 0 to Party.Chars.Count -1 do begin
    oTarget := Party.Chars.Items(i);
	if (oTarget = nil) or (not (CharList.ByName(oTarget.Name, cchar))) then Continue;
	if(User.DistTo(oTarget) > 2000) then continue;
    nCurHp := oTarget.Hp;
	if (oTarget.Dead) then nCurHp := 0;
	if (nCurHp < nLastHp) then nLastHp := nCurHp;
  end;
  result := nLastHp;
end;



function GetMinPartyMp: Integer;
//checked
var
i, nLastMp, nCurMp: Integer;
oTarget, cchar: Tl2Char;
begin
  nLastMp := User.Mp;
  for i := 0 to Party.Chars.Count -1 do begin
    oTarget := Party.Chars.Items(i);
	if (oTarget = nil) or (not (CharList.ByName(oTarget.Name, cchar))) then Continue;
	if(User.DistTo(oTarget) > 2000) then continue;
    nCurMp := oTarget.Mp;
	if (nCurMp < nLastMp) then nLastMp := nCurMp;
  end;
  result := nLastMp;
end;

function CheckFindNewMob: Boolean;
var
oTarget: Tl2Live;
x, y, z: Integer;
begin
	result := false;
	if (ManaMattersMode and (GetMinPartyMp < 79)) then exit;
	
	if not (IsUnderAttack)
	and (GetMinPartyHp > 75) 
	and not (IsAnyoneMissingBuffs_Apocalyps) then begin
		oTarget := GetTarget_NearestInZone_Pve(MAX_RANGE_NPC_SEARCH);
		if (oTarget = nil) then exit;
		x := oTarget.X; y := oTarget.Y; z := oTarget.Z;
		if (User.DistTo(oTarget) < 200) and (oTarget.GetVar < 42) then oTarget.SetVar(42);
		result := MoveTo_Timer(x, y, z);
		Delay(500);
	end;
end;

function CheckMode_KillAll: Boolean;
var
x, y, z: Integer;
oLeader: Tl2Char;
leadName: String;
begin
	result := false;
	//Print('Mode Kill all started');
	if not Mode_KillAll then begin
		//Print('Mode Kill all ended, not enabled 1.');
		exit;
	end;
	//Print('Mode Kill all started 1');
	if (GetCount_DeadPartyWithinRange(3000) > 0) then begin
		//Print('Mode Kill all ended, not enabled 2.');
		exit;
	end;
	//Print('Mode Kill all started 2');
	leadName := GetName_LocalLeader;
	if (leadName = '') then begin
		//Print('Mode Kill all ended, not enabled 3.');
		exit;
	end;
	
	//Print('Mode Kill all started 3');
	if Party.Chars.ByName(leadName, oLeader) then begin
		
		if (oLeader = nil) or (oLeader.Name = '') then exit;
	
		if (User.DistTo(oLeader) < 500) then begin
			x := oLeader.X; y := oLeader.Y; z := oLeader.Z;
			if SetTarget_NearestToPoint_DynamicZone_Pve(x, y, z, 900) then begin
				result := true;
				//if (User.DistTo(User.Target) > 400) then
					//Action_UseSingleSkill_Force;
			end;
		end;
	end;
	
	
	//Print('Mode Kill all ended');
end;


function WriteError(ErrorMessage : string): void;
var
ErrorStringList: TStringList;
StandardText, sFileName : string;
begin
	Print('Error: ' + ErrorMessage);
	exit;
	if (ErrorMessage = '') then begin
		ErrorMessage := 'Empty string';
	end;
  sFileName := 'Fp_ErrorLog_' + User.Name + '.txt';
  ErrorStringList := TStringList.Create;
  
  if (fileexists(sFileName)) then
	ErrorStringList.LoadFromFile(sFileName);  
  
  
  
  StandardText := DateTimeToStr(now) + ' - ' + User.Name;
  
  ErrorStringList.Add(StandardText + ' - ' + ErrorMessage);
  Print(StandardText + ' - ' + ErrorMessage);
  ErrorStringList.SaveToFile(sFileName);
  
  ErrorStringList.Free();
end;

function SaveVariable_ToProfile(varName, varValue : string): void;
var
Profile: TStringList;
StandardText, sFileName : string;
index: Integer;
begin
	if (varName = '') then begin
		exit;
	end;
	sFileName := GetPath_FileSettings + 'Profile_' + User.Name + '.txt';
	Profile := TStringList.Create;
  
	if (fileexists(sFileName)) then
		Profile.LoadFromFile(sFileName);  
	
	index := Profile_FindVariableIndex(varName, Profile);
	
	if (index >= 0) then begin
		Profile[index] := varName + ':' + varValue;
	end else begin
		Profile.Add(varName + ':' + varValue);
	end;
	
	Print('Saved variable ' + varName + ' = ' + varValue);
	Profile.SaveToFile(sFileName);
  
	Profile.Free();
end;

function Profile_FindVariableIndex(varName: string; Profile: TStringList): Integer;
var
i: Integer;
val: string;
begin
	result := -1;
	if (Profile.Count <= 0) then exit;
	varName := varName + ':';
	for i := 0 to Profile.Count - 1 do begin
		val := Profile[i];
		if (pos(varName, val) > 0) then begin
			result := i;
			exit;
		end;
	end;
	
end;


function LoadAndFitVariable_FromProfile(varName : string; var returnVal): void;
begin
	print('asd');

end;

function LoadVariableValue_FromProfile(varName : string): string;
var
Profile: TStringList;
StandardText, sFileName, varValue, temp: string;
words: array of string;
index, i: Integer;
begin
	result := '';
	
	if (varName = '') then begin
		Print('Error: LoadVariable failed, varName is empty');
		exit;
	end;
	
	sFileName := GetPath_FileSettings + 'Profile_' + User.Name + '.txt';
	Profile := TStringList.Create;
  
	if not (fileexists(sFileName)) then begin
		Print('Warning: GetVariable_FromProfile failed. Could not find the file "' + sFileName + '"');
		Profile.Free;
		exit;
	end;
	
	Profile.LoadFromFile(sFileName); 
	
	index := Profile_FindVariableIndex(varName, Profile);
	
	if (index >= 0) then begin
		temp := Profile[index];
		if (temp = '') then begin
			Print('Warning: GetVariable_FromProfile failed. Could not find the variable "' + varName + '"');
			Profile.Free;
			exit;
		end;
		words := temp.Split(':');
		
		index := High(words);
		if (index < 0) then begin
			Profile.Free;
			Print('Warning: find variable: Index wrong');
			exit;
		end;
		varValue := words[index];
		result := varValue;
	end else begin
		Print('Error: LoadVariable failed. variable not found');
	end;
  
	Profile.Free();
end;



function GetKeyState(nVirtKey: integer): byte; stdcall;
external 'user32.dll' name 'GetKeyState' ;

function KeyDown(K : byte) : Boolean;
begin
	Result := (K = 128) or (K = 129)
end;

function SHIFT : boolean;
begin
	Result := KeyDown(GetKeyState($10));
end;

function CTRL : boolean;
begin
	Result := KeyDown(GetKeyState($11));
end;

function ALT : boolean;
begin
	Result := KeyDown(GetKeyState($12));
end;

function bHALF : boolean;
begin
	Result := KeyDown(GetKeyState($DC));
end;


function cEnterText(msg: string): Boolean;
begin
	while ALT do delay(150);
	result := Engine.EnterText(msg);
end;

procedure Anti_EventPopup;
var
counter: Integer;
sMessage, lastMessage: string;
player: Tl2Char;
begin
	Print('Anti Event Popup - Started.');
	counter := 0;
	lastMessage := '';
	while true do begin
		sMessage := Engine.ConfirmDlg.Sender;
		if not (CharList.ByName(sMessage, player)) then begin
			if (not (lastMessage = sMessage)) then begin
				lastMessage := sMessage;
				Print('Popup message changed: ' + sMessage);
				Delay(500);
				while (alt) do delay(20);
				Engine.UseKey('Enter');
			end;
		end;
		if ((counter mod 200) = 1) then begin
			while (alt) do delay(20);
			Engine.UseKey('Enter');
			Print('Popup message changed: ' + sMessage);
		end;
		Delay(3000);
		Inc(counter);
	end;
end;

function IsSpoilCorpseNear: Boolean;
var
i: Integer;
begin
  result := false;
  for i := 0 to NpcList.Count - 1 do begin
    if (User.DistTo(NpcList.Items(i)) > 300 ) then break;
    if (NpcList.Items(i).Dead)
    and (NpcList.Items(i).Sweepable) then begin
      result := true;
      Exit;
    end;
  end;

end;


function CheckSweep: boolean;
begin
	result := false;
    if (IsSpoilCorpseNear) then begin
		Engine.UseSkill(444);
		result := true;
    end;
end;



function GetOutOfCombat: void;
var
counter : Integer;
begin
	if not (IsUnderAttack) then begin
		Engine.FaceControl(0, False);
		Exit;
	end;
	counter := 0;
	while (User.InCombat or User.Pvp) and not (User.Dead) do begin
		while (IsUnderAttack) and not (User.Dead) do begin
			if not(Engine.GetFaceState(0)) then
				Engine.FaceControl(0, true);
	
			Delay(500);
			if not (IsUnderAttack) then begin
				Engine.FaceControl(0, false);
				print('Waiting to get out of combat...');
				Delay(2000 + Random(3000));
				if not (User.InCombat) and not (User.Pvp) then break;
			end;
		end;  
		Delay(500);
		Inc(counter);
		if (counter > 140) then break;
	end;
	Engine.FaceControl(0, False);
	Delay(3000);
end;

function Check_ClusterCharge: Boolean;
begin
	result := false;
	if (PvpLoaded) then 
		result := Check_ClusterCharge_Pvp
	else 
		result := Check_ClusterCharge_Pve;

end;

function Check_ClusterCharge_Pvp(): Boolean;
var
dist: Integer;
begin
	result := false;
	
	if (SetTarget_MostClustered_Pvp) then begin
	
		if (User.Target = nil) then Exit;
		
		dist := User.DistTo(user.target);
		if (dist > 350) then begin
			if (HasSkill_Ready(995)) 
			and (dist < 600) then begin
			
				result := Engine.UseSkill(995);
			
			end else if (HasSkill_Ready(994))
			and (dist < 400) then begin
			
				result := Engine.UseSkill(994);
			
			//end else if (HasSkill_Ready(484))
			//and (dist < 400) then begin
			
				//result := Engine.UseSkill(484);
			
			end;
		
		end;	
	end;
end;
function Check_ClusterCharge_Pve(): Boolean;
var
dist: Integer;
begin
	result := false;
	if (SetTarget_MostClustered_Pve) then begin
		
		if (User.Target = nil) then Exit;
	
		dist := User.DistTo(user.target);
		if (dist > 250) then begin
			if (HasSkill_Ready(995)) 
			and (dist < 600) then begin
				
				result := Engine.UseSkill(995);
			
			end else if (HasSkill_Ready(994))
			and (dist < 400) then begin
			
				result := Engine.UseSkill(994);
			
			//end else if (HasSkill_Ready(484))
			//and (dist < 400) then begin
			
				//result := Engine.UseSkill(484);
			
			end;
		
		end;	
	end;
end;

function CheckUse_Charge(oTarget: Tl2Live): Boolean; Overload;
var
dist: Integer;
begin
	result := false;
	if (oTarget = nil) then Exit;
	
	dist := User.DistTo(oTarget);
	if (dist > 350) then begin
		if (HasSkill_Ready(995)) 
		and (dist < 600) then begin
				
			result := Engine.UseSkill(995);
			
		end else if (HasSkill_Ready(994))
		and (dist < 400) then begin
			
			result := Engine.UseSkill(994);
			
		//end else if (HasSkill_Ready(484))
		//and (dist < 400) then begin
			
			//result := Engine.UseSkill(484);
			
		end;
		
	end;
end;
function CheckUse_Charge(oTarget: Tl2Char): Boolean; Overload;
var
dist: Integer;
begin
	result := CheckUse_Charge(oTarget as Tl2Live);
end;

function CheckUse_FinalSecret(): Boolean;
begin
	result := false;
	if not CanTargetReceiveBuffs(User) then exit;
	if HasSkill_Ready(917) and not IHaveBuff(917) then begin
		result := true;
		print('Use final secret!');
		Engine.UseSkill(917);
	end;
end;

function CheckUse_Enlightenment_Healer(maxManaForUse: Integer): Boolean;
begin
	result := false;
	if (User.Mp > maxManaForUse) then exit;
	if not CanTargetReceiveBuffs(User) then exit;
	
	if HasSkill_Ready(1533) and not IHaveBuff(1533) then begin
		result := true;
		print('Use Enlightenment!');
		Engine.DUseSkill(1533, false, false);
	end;
end;

function CanTargetReceiveBuffs(oTarget: Tl2Char): Boolean;
var
oBuff: Tl2Buff;
begin
	result := true;
	if (oTarget.Dead) or (IsFriend_Invincible(oTarget)) then begin
		result := false;
		exit;
	end;
	
	//Check DOD
	if (oTarget.Oid = User.Oid) or (oTarget.IsMember) then begin
		if (oTarget.Buffs.ById(5145, oBuff)) then result := false;
				
	end else begin
		if (CheckIfControlHasBuff_ByName(5145, oTarget.Name)) then result := false;
	end;
	
end;

function IsTime_ToPickup: Boolean;
var
i: Integer;
oDrop: Tl2Drop;
begin
	result := false;
	
	for i := 0 to DropList.Count - 1 do begin
		oDrop := Droplist.Items(i);
		if (oDrop = nil) or (not oDrop.Valid) then continue;
		
		if (User.DistTo(oDrop) > 600) then break;
		
		if not (oDrop.IsMy) then Continue;
	
		result := true;
		exit;	
	end;
end;

function InitializeVariables: void;
var
path: string;
i: Integer;
begin
	Engine.FaceControl(1, true); //Make sure attacks are enabled by default
	
	//Game mode?
	interlude := false;
	canBuffNoblesse := true;
	isJava := true;
	DiscreteMode := false;
	PvpEnabled := true;
	ManaMattersMode := true;
	Mode_Standard_Pickup := true;
	Mode_Pickup := false;
	
	Mode_NpcRebuff := true;
	
	Mode_DetectSystemMessages := false;
	Mode_WaitForCasting := false;
	Mode_LeaderIsCenter := true;
	
	MODE_GOD := false;
	
	DuoPartyMode := false; //Can be changed by command
	Mode_KillAll := false;

	allowEmptyStringMobNames := true;
	
	
	//Skill Cooldowns (milliseconds)
		//Bishop
		SKILL_CD_MASS_BLOCK_WW := 5000;
	
	
	playerDetectDistance := 4500;

	MONSTER_SOCIAL_RANGE 			:= 300;
	MAX_MOB_ON_US_RANGE				:= 900;
	MAX_RANGE 						:= 1000;
	MAX_RANGE_FRIEND				:= 1600;
	MAX_RANGE_AOE 					:= 300;
	MAX_RANGE_NPC_SEARCH 			:= 3000;
	MAX_RANGE_NPC_ATTACKING			:= 1600;
	MAX_DISTANCE_TO_PARTY_FOR_AOE 	:= 900;
	MAX_ASSIST_RANGE_PVP			:= MAX_RANGE;
	MAX_PARTY_PT_DIST				:= 700;
	MAX_RANGE_PVP_SEARCH			:= MAX_RANGE;
	MAX_RANGE_TOAGRO				:= 1000;
	
	Range_StayClose := 0;
	Mode_StayClose := false;
	
	MAX_ATTACKING_MOBS_TO_PULL := 20;
	
	
	SIGEL_AOE_AGRO_RANGE := 450;
	
	FOLLOW_DIST := 133;
	FOLLOW_RANDOM_TIME_CHANGE_MIN := 3000; //Changes to a new random point every 3 seconds.
	FOLLOW_RANDOM_TIME_CHANGE_MAX := 8000; //Changes to a new random point every 3 seconds.
	FOLLOW_RANDOM_TIME_CHANGE := FOLLOW_RANDOM_TIME_CHANGE_MIN;
	FOLLOW_MOVE_TIME_CHANGE_MIN := 300;
	FOLLOW_MOVE_TIME_CHANGE_MAX := 800;
	FOLLOW_MOVE_TIME_CHANGE := FOLLOW_MOVE_TIME_CHANGE_MIN;
	FOLLOW_RANDOM_RANGE := 25;
	FOLLOW_MOVE_X := 0;
	FOLLOW_MOVE_Y := 0;
	FOLLOW_Random_X := 0;
	FOLLOW_Random_Y := 0;
	FOLLOW_DELAY := 0;
	FOLLOW_CURRENT_POSITION := true;
	Movement_Delay := 300;
	
	//Aoe range of level 80 bubble skills (Day of Doom, Volcano etc..)
	BUBBLE_AOE_RANGE := 300;
	
	AOE_PX := 0;
	AOE_PY := 0;
	AOEAGRO_PT_DIST := 0;
	AOEAGRO_PX := 0;
	AOEAGRO_PY := 0;
	AOE_PT_DIST := 0;
	PT_PX := 0;
	PT_PY := 0;
	PARTY_PT_DIST := 0;
	curPathStep := 0;
	curPath := TList.Create;
	pullMobs_Cooldown := 0;
	weaponOid := 0;
	SysMsg_CannotSeeTarget := false;
	FOCUS_MOB_OID := 0;
	LastAttackTime := 0;
	
	AoePoint_ClusterCount := 0;
	(*
	LastAttackTime := User.AtkTime;
	TimeSinceLastAttack := LastAttackTime;
	
	AttackStartTime := MsToTime(LastAttackTime);	
	StartTime := now;
	TotalTimePassed := 0;
	
	print('Total Time passed = ' + IntToStr(GetMillisecondsInBetween(StartTime, now)));
	print('Time Since last Attack = ' + IntToStr(TimeSinceLastAttack));
	*)
	LowHpSettingLoaded := false;
	LowHpMode := false;
	DiscreteLoaded := false;
	PvpLoaded := false;
	PveLoaded := false;
	TempOff := false;
	IsMoving := false;
	MoveLock := false;
	PauseForBuffs := false;
	TotalPause := false;
	CombatEnabled := true;
	FollowEnabled := true;
	CircleAgroMode := false;
	PlayersNearby := false;
	AA_GoClose := false;
	AA_GoVeryClose := false;
	AA_AssistPk := false;
	AA_BringMobsMode := false;
	tempBuffBotPause := false;
	SEED_POP_MODE := false;
	SOS_TargetFound := false;
	LowHp_TargetFound := false;
	TargetSearch_LowestFirst := false;
	TargetSearch_StrongestFirst := false;
	TargetSearch_ClosestFirst := false;
	AOE_ENABLED := true;
	AOE_ENABLED_PVP := true;
	AOE_ENABLED_PVE := true;
	FEAR_ENABLED := true;
	Mode_BashGate := false;
	Mode_AssistLeader := false;
	Mode_Focus := false;
	foundTargetToFollow := false;
	LastFollowX := 0;
	LastFollowY := 0;
	LastFollowZ := 0;
	
	SettingList := TStringList.Create;
	SettingList.LoadFromFile(GetPath_FileSettings + 'Pvp_Settings.txt'); 
	print('Main Leader: ' + GetName_Leader);
	print('Server: ' + GetName_Server);


	ClanList := TStringList.Create;
	ClanList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClanExceptions.txt');
	FriendList := TStringList.Create;
	FriendList.LoadFromFile(GetPath_FileSettings + 'Pvp_PlayerExceptions.txt');
	
	
    UdEffectList := TStringList.Create;
    UdEffectList.LoadFromFile(GetPath_FileSettings + 'Pvp_UD_Skills.txt');
	
	DbfImnEffectList := TStringList.Create;
    DbfImnEffectList.LoadFromFile(GetPath_FileSettings + 'Pvp_DebuffImmune_Skills.txt'); 
	
	UltimateEffectList := TStringList.Create;
    UltimateEffectList.LoadFromFile(GetPath_FileSettings + 'Pvp_Ultimate_Skills.txt'); 
	
    DebuffList_1 := TStringList.Create;
    DebuffList_1.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_DebuffNames_1.txt');
    DebuffList_2 := TStringList.Create;
    DebuffList_2.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_DebuffNames_2.txt');
    DebuffList_3 := TStringList.Create;
    DebuffList_3.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_DebuffNames_3.txt');
	
	
	
	DebuffListFighter_1 := TStringList.Create;
	DebuffListFighter_1.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_FighterDebuffNames_1.txt');
	DebuffListFighter_2 := TStringList.Create;
	DebuffListFighter_2.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_FighterDebuffNames_2.txt');
	DebuffListFighter_3 := TStringList.Create;
	DebuffListFighter_3.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_FighterDebuffNames_3.txt');
	
	
	DebuffListMage_1 := TStringList.Create;
	DebuffListMage_1.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_MageDebuffNames_1.txt');
	DebuffListMage_2 := TStringList.Create;
	DebuffListMage_2.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_MageDebuffNames_2.txt');
	DebuffListMage_3 := TStringList.Create;
	DebuffListMage_3.LoadFromFile(GetPath_FileSettings + 'Pvp_Cleanse_MageDebuffNames_3.txt');
	
	
	//for i := 0 to DebuffListMage_1.count - 1 do begin
		//Print('DebuffList1[' + IntToStr(i) + '] = ' + DebuffListMage_1[i]);
	//end;
	
	DisabledEffectList := TStringList.Create;
	DisabledEffectList.LoadFromFile(GetPath_FileSettings + 'Pvp_DisabledEffects.txt');
	
	BuffList_Mage := TStringList.Create;
	BuffList_Mage.LoadFromFile(GetPath_FileSettings + 'Pvp_BuffList_Mage.txt');
	
	BuffList_Fighter := TStringList.Create;
	BuffList_Fighter.LoadFromFile(GetPath_FileSettings + 'Pvp_BuffList_Fighter.txt');
	
	Mail_List := TStringList.Create;
	Mail_List.LoadFromFile(GetPath_FileSettings + 'Pvp_MailItems_IdList.txt');
	
	
	
	ClassList := TStringList.Create;
	if (User.Level < 86) then
		ClassList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClassPriority.txt')
	else 
		ClassList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClassPriority_Helios_Sigel.txt');
		
    ClassProtectionList := TStringList.Create;
    ClassProtectionList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClassProtectionPriority.txt');
    ClassAgroList:= TStringList.Create;
    ClassAgroList.LoadFromFile(GetPath_FileSettings + 'Pvp_ClassAgroPriority.txt');
	
	CommandSenderList := TStringList.Create;

	fighterBuffExceptionList := TStringList.Create;
	fighterBuffExceptionList.Add('4703'); //Pony reuse buff
	fighterBuffExceptionList.Add('1004');//Paagrio Wisdom (Acumen)
	fighterBuffExceptionList.Add('1303'); //Wild Magic
	fighterBuffExceptionList.Add('830'); //Embroider
	//fighterBuffExceptionList.Add('1397');//Clarity
	
	fighterCasterBuffExList := TStringList.Create;
	fighterCasterBuffExList.Add('4703'); //Pony reuse buff
	fighterCasterBuffExList.Add('1303'); //Wild Magic
	fighterCasterBuffExList.Add('830'); //Embroider
	//fighterCasterBuffExList.Add('1397');//Clarity
	
	mageBuffExceptionList := TStringList.Create;
	mageBuffExceptionList.Add('1519');//Chant of blood awakening
	mageBuffExceptionList.Add('4699');//Blessing of Queen
	mageBuffExceptionList.Add('982');//Combat Aura
	mageBuffExceptionList.Add('1537');//Paagrio Crit Combi
	
	
	defensiveBuffExceptionList := TStringList.Create;
	defensiveBuffExceptionList.Add('915');//Dance of Berserker
	defensiveBuffExceptionList.Add('1261');//Paagrios Rage
	
	DropPriorityList := TStringList.Create;
	DropPriorityList.LoadFromFile(GetPath_FileSettings + 'Pvp_DropPriorityList.txt');
	
	skillRecordList := TList.Create;
	RezExceptionList := TList.Create;
	CleanseExceptionList := TList.Create;
	PersonTimers := TList.Create;
	
	WasInParty := (Party.Chars.Count > 0);
	
end;

function GetTimeSinceLastAttack(attackTime: Cardinal): Cardinal;
var
tickCount: Cardinal;
begin
	result := 1000000;
	
	tickCount := GetTickCount;
	if (tickCount >= attackTime) then begin
		result := tickCount - attackTime;
	end;
end;

function ResetVariables: void;
begin
	
	//Game mode?
	

	Mode_KillAll := false;
	
	allowEmptyStringMobNames := true;
	
	playerDetectDistance := 4500;

	MONSTER_SOCIAL_RANGE 			:= 0;
	MAX_MOB_ON_US_RANGE				:= 900;
	MAX_RANGE 						:= 1000;
	MAX_RANGE_FRIEND				:= 1600;
	MAX_RANGE_AOE 					:= 300;
	MAX_RANGE_NPC_SEARCH 			:= 3000;
	MAX_RANGE_NPC_ATTACKING			:= 1600;
	MAX_DISTANCE_TO_PARTY_FOR_AOE 	:= 900;
	MAX_ASSIST_RANGE_PVP			:= MAX_RANGE;
	MAX_PARTY_PT_DIST				:= 700;
	MAX_RANGE_PVP_SEARCH			:= MAX_RANGE;

	FOLLOW_DIST := 50;
	FOLLOW_RANDOM_TIME_CHANGE_MIN := 3000; //Changes to a new random point every 3 seconds.
	FOLLOW_RANDOM_TIME_CHANGE_MAX := 8000; //Changes to a new random point every 3 seconds.
	FOLLOW_RANDOM_TIME_CHANGE := FOLLOW_RANDOM_TIME_CHANGE_MIN;
	FOLLOW_MOVE_TIME_CHANGE_MIN := 300;
	FOLLOW_MOVE_TIME_CHANGE_MAX := 1400;
	FOLLOW_MOVE_TIME_CHANGE := FOLLOW_MOVE_TIME_CHANGE_MIN;
	FOLLOW_RANDOM_RANGE := 200;
	FOLLOW_Random_X := 0;
	FOLLOW_Random_Y := 0;
	FOLLOW_CURRENT_POSITION := false;
	
	
	LowHpMode := false;
	TempOff := false;
	IsMoving := false;
	MoveLock := false;
	TotalPause := false;
	CombatEnabled := true;
	FollowEnabled := true;
	CircleAgroMode := false;
	PlayersNearby := false;
	AA_GoClose := false;
	AA_GoVeryClose := false;
	AA_AssistPk := false;
	AA_BringMobsMode := false;
	tempBuffBotPause := false;
	SEED_POP_MODE := false;
	SOS_TargetFound := false;
	LowHp_TargetFound := false;

end;






function GetClosestNpcOfId(NpcId: Integer): Tl2Live;
var
i: Integer;
oTarget: Tl2Live;
begin
	result := User as Tl2Live;
	for i := 0 to NpcList.Count - 1 do begin
		oTarget := NpcList.Items(i);
		if (oTarget = nil) then Continue;
		if (User.DistTo(oTarget) > MAX_RANGE_NPC_SEARCH) then break;
		if (oTarget.Id = NpcId) then begin
			result := oTarget;
			Exit;
		end;	
	end;
end;

function HasSkill_Ready_Interval(nSkillId, interval_ms: Integer): Boolean;
var
skillRecord_Index, tempMilli: Integer;
skillRecord: TSkillRecord;
begin
	result := false;
	if HasSkill_Ready(nSkillId) then begin
		skillRecord_Index := IndexOf_SkillRecord_BySkillId(nSkillId);
		if (skillRecord_Index >= 0) then begin
			skillRecord := TSkillRecord(skillRecordList[skillRecord_Index]);
			if (skillRecord.skillId = nSkillId) then begin
				tempMilli := GetMillisecondsInBetween(skillRecord.lastUse, now);
				if (tempMilli >= interval_ms) then begin
					//At this point, the interval since last use has passed, and skill can now be used again.
					result := true;
					exit;
				end else begin
					//print('Skill Interval:  Skill with ID = ' + IntToStr(nSkillId) + '  was not ready...    ' + IntToStr(interval_ms - tempMilli) + ' ms remains...');
				end;
			end else
				result := true;
		end else 
			result := true;
	end;
end;

function IndexOf_SkillRecord_BySkillId(nSkillId: Integer): Integer;
var
i: Integer;
skillRecord: TSkillRecord;
begin
	//print('IndexOf_SkillRecord_BySkillId: Started');
	try
		result := -1;
		
		if (skillRecordList = nil) or (skillRecordList.Count <= 0) then exit;
		for i := 0 to skillRecordList.Count - 1 do begin
			skillRecord := TSkillRecord(skillRecordList[i]);
			if (skillRecord = nil) or (skillRecord.skillId = 0) then continue;
			if (skillRecord.skillId = nSkillId) then begin
				result := i;
				//print('IndexOf_SkillRecord_BySkillId: found ended');
				exit;
			end;
		end;
	except
		on E : EInvalidPointer do begin
			Print('Pointer Exception Caught;');
			Print('Message: ' + E.Message);
			Print('StackTrace: ' + E.StackTrace);
		end;
		
		on E : Exception do begin
			Print('Exception Caught;');
			Print('Message: ' + E.Message);
			Print('StackTrace: ' + E.StackTrace);
		end;
	end;
	//print('IndexOf_SkillRecord_BySkillId: Ended');
end; 

function UseSkill_SetInterval(nSkillId, intervalToSet: Integer; force: Boolean = false): Boolean;
var
newRecord, skillRecord: TSkillRecord;
skillRecord_Index: Integer;
begin
	//Set cd per SKILL ID
	//Set a time 	DATE Time
	result := false;
	if HasSkill_Ready(nSkillId) then begin
		skillRecord_Index := IndexOf_SkillRecord_BySkillId(nSkillId);
		if (skillRecord_Index >= 0) then begin
			//Skill exists in list, use it, and update lastUse
			skillRecord := TSkillRecord(skillRecordList[skillRecord_Index]);
			if not (skillRecord.skillId = nSkillId) or (skillRecord = nil) then begin
				WriteError('something is very wrong, skillRecord recognized but then not');
				exit;
			end;
			if CUseSkill(nSkillId, force, false, Engine.GetFaceState(0)) then begin
				TSkillRecord(skillRecordList[skillRecord_Index]).lastUse := now;
				result := true;
			end;
		end else begin
			// Skill doesnt exist in list, use it, and add it to list
			if CUseSkill(nSkillId, force, false, Engine.GetFaceState(0)) then begin
				newRecord := TSkillRecord.Create();
				newRecord.lastUse := now;
				newRecord.skillId := nSkillId;
				skillRecordList.Add(newRecord);
				print('Added a new skill record to list.  Added skill with ID = ' + IntToStr(nSkillId));
				result := true;
			end;
		end;
	end;
end;


function SetInterval_OnSkillId(nSkillId, intervalToSet: Integer; force: Boolean = false): Boolean;
var
newRecord, skillRecord: TSkillRecord;
skillRecord_Index: Integer;
begin
	//Set cd per SKILL ID
	//Set a time 	DATE Time
	//print('SetInterval_OnSkillId: Started');
	try
		result := false;
		skillRecord_Index := IndexOf_SkillRecord_BySkillId(nSkillId);
		if (skillRecord_Index >= 0) then begin
			//Skill exists in list, use it, and update lastUse
			skillRecord := TSkillRecord(skillRecordList[skillRecord_Index]);
			if not (skillRecord.skillId = nSkillId) or (skillRecord = nil) then begin
				WriteError('something is very wrong, skillRecord recognized but then not');
				exit;
			end;
			TSkillRecord(skillRecordList[skillRecord_Index]).lastUse := now;
			result := true;
		end else begin
			// Skill doesnt exist in list, use it, and add it to list
			newRecord := TSkillRecord.Create();
			newRecord.lastUse := now;
			newRecord.skillId := nSkillId;
			skillRecordList.Add(newRecord);
			print('Added a new skill record to list.  Added skill with ID = ' + IntToStr(nSkillId));
			result := true;
		end;
	except
		on E : EInvalidPointer do begin
			Print('Pointer Exception Caught;');
			Print('Message: ' + E.Message);
			Print('StackTrace: ' + E.StackTrace);
		end;
		
		on E : Exception do begin
			Print('Exception Caught;');
			Print('Message: ' + E.Message);
			Print('StackTrace: ' + E.StackTrace);
		end;
	end;
	//print('SetInterval_OnSkillId: Ended');
end;

function HasIntervalPassed_BySkillId(nSkillId, interval_ms: Integer): Boolean;
var
skillRecord_Index, tempMilli: Integer;
skillRecord: TSkillRecord;
begin
	try
		result := false;
		skillRecord_Index := IndexOf_SkillRecord_BySkillId(nSkillId);
		if (skillRecord_Index >= 0) then begin
			skillRecord := TSkillRecord(skillRecordList[skillRecord_Index]);
			if (skillRecord.skillId = nSkillId) then begin
				tempMilli := GetMillisecondsInBetween(skillRecord.lastUse, now);
				if (tempMilli >= interval_ms) then begin
					//At this point, the interval since last use has passed, and skill can now be used again.
					result := true;
					exit;
				end else begin
					//print('Skill Interval:  Skill with ID = ' + IntToStr(nSkillId) + '  was not ready...    ' + IntToStr(interval_ms - tempMilli) + ' ms remains...');
				end;
			end else
				result := true;
		end else 
			result := true;
	except
		on E : EInvalidPointer do begin
			Print('Pointer Exception Caught;');
			Print('Message: ' + E.Message);
			Print('StackTrace: ' + E.StackTrace);
		end;
		
		on E : Exception do begin
			Print('Exception Caught;');
			Print('Message: ' + E.Message);
			Print('StackTrace: ' + E.StackTrace);
		end;
	end;
end;

function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean): Boolean; Overload;
var
count, x, y, z : Integer;
begin
	result := false;
	count := 0;
	if not HasSkill_Ready(nSkillID) then exit;
	
	if botWasOn then Engine.FaceControl(0, false);
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 2000) do Delay(40);
	//while (User.Cast.EndTime <= 0) and (HasSkill_Ready(nSkillId)) do begin
	while (count < 8) and (HasSkill_Ready(nSkillId)) do begin
		Engine.DUseSkill(nSkillId, force, shift);
		Delay(40);
		count := count + 1 ;
		//if (count > 15) then break;
	end;
	
	if (count < 8) then begin
		result := true;
	end;
	
	if botWasOn then Engine.FaceControl(0, true);
end;

function SpamSkill_WhileNotReady(nSkillId: Integer; force: Boolean = false; timeout: Integer = 1000): Boolean;
var
count, nDelay, maxCount: Integer;
begin
	result := false;
	if (nSkillID <= 0) then exit;
	if (timeout <= 0) then begin
		Print('WARNING: "SpamSkill_WhileNotReady" - Invalid timeout');
		exit;
	end;
	
	nDelay := 50;
	count := 0;
	if (timeout <= nDelay) then maxCount := 0
	else maxCount := (timeout div nDelay);
	
	while HasSkill_Ready(nSkillId) do begin
		Engine.DUseSkill(nSkillID, force, false);
		Inc(count);
		Delay(nDelay);
		if (count > maxCount) then begin
			exit;
		end;
	end;
	
	
	result := true;
end;

function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean; oTarget: Tl2Live; range: Integer = 900): Boolean; Overload;
var
count, moveCount, x, y, z : Integer;
begin
	result := false;
	count := 0;
	if not HasSkill_Ready(nSkillID) then exit;
	
	if (oTarget = nil) or not (oTarget.Valid) then begin
		print('UseSkill: Warning, target passed was nil or not valid');
		exit;
	end;
	
	if botWasOn then Engine.FaceControl(0, false);
	
	moveCount := 0;
	x := oTarget.X; y := oTarget.Y; z := oTarget.Z;
	while (User.DistTo(oTarget) > range) do begin
		MoveTo_Timer(x, y, z);
		Delay(300);
		x := oTarget.X; y := oTarget.Y; z := oTarget.Z;
		moveCount := moveCount + 1;
		if (moveCount > 5) then begin
			result := true;
			if botWasOn then Engine.FaceControl(0, true);
			exit;
		end;
	end;
	
	while (User.Cast.EndTime > 200) and (User.Cast.EndTime < 2000) do Delay(40);
	//while (User.Cast.EndTime <= 0) and (HasSkill_Ready(nSkillId)) do begin
	while (count < 8) and (HasSkill_Ready(nSkillId)) do begin
		Engine.DUseSkill(nSkillId, force, shift);
		Delay(40);
		count := count + 1 ;
		//if (count > 15) then break;
	end;
	
	
	if (count < 8) then begin
		result := true;
	end;
	
	if botWasOn then Engine.FaceControl(0, true);
end;

function CUseSkill(nSkillId : Integer; force, shift, botWasOn: Boolean; oTarget: Tl2Char; range: Integer = 900): Boolean; Overload;
var
count, x, y, z : Integer;
begin
	CUseSkill(nSkillId, force, shift, botWasOn, (oTarget as Tl2Live), range);
end;

function GetMillisecondsInBetween(time1, time2: TDateTime): Cardinal;
var
time_to_ms: Cardinal;
begin
	//				ms	 sec  min  hour
	time_to_ms := 86400000; //; 1000 * 60 * 60 * 24 = 86 400 000
	result := abs ( Round( (time1 - time2) * time_to_ms ) );
end;

function TimeToMs(cTime: TDateTime): Cardinal;
begin
	result := Cardinal(cTime * 86400000);
end;
function MsToTime(ms: Cardinal): TDateTime;
begin
	result := ms / 86400000;
end;

function PrintAbnormalBitString(abnormalId: Cardinal): void;
var
data : int64;
i: Integer;
begin

	if (abnormalId = 0) then exit;
	data := int64(abnormalId);
    for i := 31 downto 0 do begin
        if ((data shr i) and 1) = 1 then print('1  i = ' + IntToStr(i))
        else print('0  i = ' + IntToStr(i));
	end;
end;

function IsAbnormalActive(searchId, abnormalId: Cardinal): Boolean;
var
data : int64;
i, index: Integer;
begin
	result := false;
	if (abnormalId = 0) then exit;
	//print('Start pringint gvalues');
	//PrintAbnormalBitString(abnormalId);
	data := int64(abnormalId);
	index := GetBitIndex_FromAPowerOfTwo(searchId);
	if (index < 0) then exit;
    //for i := 31 downto 0 do begin
	if ((data shr index) and 1) = 1 then begin
		//	if (i = index) then begin
				//print('Active Abnormal! i = index     ' + IntToStr(i) + ' = ' + IntToStr(index));
		result := true;
		exit;
		//	end;
	end;
	//end;
(*//data := $01 + ($00 shl 8 ) + ($00 shl 16 ) + ($FF shl 24);
data := int64(searchId);
    for i := 31 downto 0 do
        begin
          if ((data shr i) and 1) = 1 then print('data bit was one  i = ' + IntToStr(i))
          else print('data Bit was Zero  i = ' + IntToStr(i));
          end;
end;*)
end;

function GetBitIndex_FromAPowerOfTwo(po2: cardinal): Integer;
var
num : int64;
i: Integer;
begin
	num := 1;
	//print('GetBit : Search for num = ' + IntToStr(po2));
	for i := 0 to 31 do begin
		if (po2 = num) then begin
			//print('GetBit : found for i = ' + IntToStr(i));
			result := i;
			exit;
		end;
		num := num * 2;
	end;
	//print('GetBit : Not Recognized!');
	result := -1;
end;

function SetWeaponEquipped: Boolean;
var
i: Integer;
oWep: Tl2Item;
begin
	result := false;
	weaponOid := 0;
	for i := 0 to Inventory.User.Count - 1 do begin
		oWep := Inventory.User.Items(i);
		if (oWep.ItemType = 0) and (oWep.Equipped) then begin
			result := true;
			weaponOid := oWep.Oid;
			print('Recognized Main Weapon: ' + oWep.Name);
			exit;
		end;	
	end;
	print('WARNING: No equipped weapon found!');
end;

function IsWeaponEquipped: Boolean;
var
i: Integer;
oWep: Tl2Item;
begin
	result := false;
	for i := 0 to Inventory.User.Count - 1 do begin
		oWep := Inventory.User.Items(i);
		if (oWep.ItemType = 0) and (oWep.Oid = weaponOid) and (oWep.Equipped) then begin
			result := true;
			exit;
		end;	
	end;
end;

function EquipLowerWeapon: Boolean;
var
i, wepId: Integer;
oWep: Tl2Item;
begin
	result := false;
	
	if IsClass_Tyrant(User.ClassId) then begin
	
	end else if IsClass_Destro(User.ClassId) then begin
	
	end else if IsClass_Destro(User.ClassId) then begin
	
	end;
	
	
	for i := 0 to Inventory.User.Count - 1 do begin
		oWep := Inventory.User.Items(i);
		if (oWep.ItemType = 0) and (oWep.Oid = weaponOid) and (oWep.Equipped) then begin
			result := true;
			exit;
		end;	
	end;
end;


function EquipWeapon: Boolean;
var
i: Integer;
oWep: Tl2Item;
begin
	result := false;
	for i := 0 to Inventory.User.Count - 1 do begin
		oWep := Inventory.User.Items(i);
		if (oWep.ItemType = 0) and (oWep.Oid = weaponOid) and (not oWep.Equipped) then begin
			result := Engine.UseItem(oWep);
			exit;
		end;	
	end;
end;

function CheckDisarm(): Boolean;
var
oBuff: Tl2Buff;
begin
	result := false;
	if (weaponOid = 0) then begin
		//print('WARNING: No Main Weapon!!!');
		SetWeaponEquipped;
		exit;
	end;
	//if (LowHpMode) then begin
		//EquipLowerWeapon;
		//exit;
	//end;
	if not IsWeaponEquipped then begin
		if not User.Buffs.ById(485, oBuff) and not User.Buffs.ById(794, oBuff) then begin	//Check disarm debuffs
			result := EquipWeapon;
			Delay(1500);
		end;
	end;
end;



function wrap_DoRebuff(takeShadow: Boolean = false): Boolean;
begin
	result := DoRebuff(takeShadow);
end;

function GetMaxLevelToStop(oTarget: Tl2Char): Integer;
begin
	result := 86;
	
	if (User.Name = 'iTyrant1')
	or (User.Name = 'iTyrant2')
	or (User.Name = 'iTyrant3')
	or (User.Name = 'iTyrant4')
	or (User.Name = 'iTyrant5')
	or (User.Name = 'iTyrant6')
	or (User.Name = 'iBishop1')
	or (User.Name = 'iBishop2')
	or (User.Name = 'iElder1')
	or (User.Name = 'iTyrant11') 
	or (User.Name = 'iTyrant12') 
	or (User.Name = 'iTyrant13') 
	or (User.Name = 'iTyrant14') 
	or (User.Name = 'iTyrant15') 
	or (User.Name = 'iTyrant16') 
	or (User.Name = 'iBishop11') 
	or (User.Name = 'iBishop12') 
	or (User.Name = 'iElder11') then begin
		result := 63;
	end;
	
end;

function CompleteAutoFarm: void;
var
lastLoadedZone, nZone, x, y, z, lastX, lastY, lastZ, posCount, counter, pvpCount: Integer;
clanRep: Boolean;
begin
	Engine.AutoAcceptClan('Synergy');
	clanRep := IsClass_Sps(User.ClassId) and (User.level <= 40);
	if (clanRep) then begin
		print('Class Spellsinger detected, enable clan rep mode. Auto open packages/equip start gear');
		delay(1000);
	end;
	if IsClass_Sph(User.ClassId) then begin
		if (User.Name = 'iWind') then begin
			cLoadConfig('auto_sph_high.xml');
		end else begin
			cLoadConfig('auto_sph.xml');
		end;
	end else if (IsClass_Spoiler(User.ClassId)) then
		cLoadConfig('auto_spoil.xml')
	else
		cLoadConfig('auto_farm.xml');
	lastLoadedZone := 0;
	lastX := User.X; lastY := User.Y; lastZ := User.Z;
	posCount := 0;
	
	while true do begin
		Delay(2000);
		if (Check_AutoRelog) then begin
			Delay(5000);
			continue;
		end;
		CheckUseNewbieItems(clanRep);
		
		x := User.X; y := User.Y; z := User.Z;
		if (x = lastX) and (y = lastY) and (z = lastZ) then begin
			posCount := posCount + 1;
			//Print('Position same as last, posCount = ' + IntToStr(posCount));
			if (posCount > 40) and DetectStuck then begin
				Print('We have been standing the same place for too long, minimize/maximize to un-stuck.');
				Unstuck;
				posCount := 0;
			end;
		end else begin
			lastX := x;
			lastY := y;
			lastZ := z;
			posCount := 0;
			
			//Print('Position changed. posCount = ' + IntToStr(posCount));
		end;
		
		
		if (User.Dead) then begin
			while (User.Pvp) do begin
				pvpCount := pvpCount + 1;
				if (pvpCount > 300) then break;
				Delay(1000);
			end;
			Engine.GoHome();
			Delay(15000);
			Continue;
		end else if (GetMaxLevelToStop(User) <= User.level) then begin
		
			
			if (User.DistTo(147715, -56486, -2776) > 500) then begin
				GetOutOfCombat;
				PortRandomTown();
			end;
		
		end else if (User.Buffs.Count < 15) then begin //Missing Buffs
			Print('Buffs missing, go rebuff');
			GetOutOfCombat;
			DoRebuff;
			if DetectStuck then begin
				print('We cannot move!');
				continue;
			end;
			if (User.Level >= 20) and (User.DistTo(147719, -56471, -2776) < 500) then begin
				if (GetName_Server = 'World') then begin
					GetOutOfCombat;
					PortRandomTown();
				end;
				if Restock then begin
					Print('Restart game in order to leave Multisell chat field.');
					Engine.Restart();
					Delay(1000);
					Engine.GameStart();
					Delay(18000);
					counter := 0;
					x := User.X; y := User.Y; z := User.Z;
					Print('Initiate Minimize/Maximize procedure');
					Engine.SetGameWindow(true);
					Delay(3000);
					Engine.SetGameWindow(false);
					Delay(2000);
					Unstuck; //Anti relog movement bug.
					
				end;
			end;
			Continue;
		end else begin
			GoTo_Spot;
		end;
		
		nZone := GetZone;
		if (lastLoadedZone = 0) or not(lastLoadedZone = nZone) then begin
			Print('Load combat zone: ' + IntToStr(nZone));
			lastLoadedZone := SetZone;
		end;
		
		
	end;

end;

function CheckUseNewbieItems(clanRep: Boolean): Boolean;
var
oItem: Tl2Item;
begin
		if (Inventory.User.ById(21606, oItem)) then begin
			Engine.UseItem(21606);
			Delay(2000);
		end;
		if (Inventory.User.ById(20635, oItem)) then begin
			Engine.UseItem(20635);
			Delay(2000);
		end;
		if (Inventory.User.ById(20637, oItem)) then begin
			Engine.UseItem(20637);
			Delay(2000);
		end;
		if (Inventory.User.ById(20549, oItem)) then begin
			Engine.UseItem(20549);
			Delay(2000);
		end;
	if (clanRep) then begin
			
		if (User.level <= 19) then begin
			CheckHaveEquipItem(8977);
			CheckHaveEquipItem(9034);
			CheckHaveEquipItem(9035);
		end else if (User.Level >= 20) and (User.Level < 40) then begin
			CheckHaveEquipItem(20649);
			CheckHaveEquipItem(20650);
			CheckHaveEquipItem(20651);
			CheckHaveEquipItem(20652);
			CheckHaveEquipItem(20653);
			CheckHaveEquipItem(20645);
		end;
		
		if (User.Level >= 40) then begin
			print('We are level 40! Collect clan rep!');
			Engine.BlinkWindow();
		end else if (User.Level > 19) and (User.ClassId = 25) then begin
			print('We are level 20! Change class!');
			Engine.BlinkWindow();
		end;
		
	end;
end;

function CheckHaveEquipItem(itemId: Integer): Boolean;
var
oItem: Tl2Item;
begin
	if (Inventory.User.ById(itemId, oItem)) then begin
		if not (oItem.Equipped) then begin
			Engine.UseItem(oItem);
			Delay(1500);
		end;
	end;
end;

function DetectStuck: Boolean;
var
x, y, z, randX, randY: Integer;
begin
	result := false;
	if (User.Dead) then exit;
	x := User.X; y := User.Y; z := User.Z;
	while (User.Cast.EndTime > 0) do delay(250);
	
	if (Random(2) = 1) then 
		randX := 40
	else  
		randX := -40;
		
	if (Random(2) = 1) then 
		randY := 40
	else  
		randY := -40;
	
	if not Engine.MoveTo(x + randX, y + randY, z) then begin
		Print('Warning we are stuck!');
		result := true;
	end;
end;

function Unstuck: Boolean;
var
counter: Integer;
begin
	result := false;
	Print('Unstuck: Maximize/Minimize!');
	counter := 0;
	while (DetectStuck) do begin
		Engine.SetGameWindow(true);
		Print('Delaying for ' + IntToStr(2400 + (counter * 2300)) + ' milliseconds...');
		Delay(2400 + (counter * 2300));
		Engine.SetGameWindow(false);
		Delay(2000);
		Inc(counter);
		if (counter > 10) then exit;
	end;
	result := true;
end;

function KillAttackers: void;
var
counter : Integer;
begin
	if not (IsUnderAttack) then begin
		Engine.FaceControl(0, False);
		Exit;
	end;
	counter := 0;
	while (IsUnderAttack) and not (User.Dead) do begin
		if not(Engine.GetFaceState(0)) then
			Engine.FaceControl(0, true);
	
		Delay(500);
	end;  
	Engine.FaceControl(0, False);
	Delay(3000);
end;
function CMoveTo(x, y, z: Integer): boolean;
var
count, myZ: Integer;

begin
	count := 0;
	result := false;
	
	if (User.Dead) then exit;
	
	myZ := User.Z;
	if (User.DistTo(x, y, myZ) > 20000) then begin
		print('Distance is greater than 20.000, exit this move.  Distance to point = ' + IntToStr(User.DistTo(x, y, myZ)));
		exit;
	end;
	
	//result := Engine.MoveTo(x, y, z);
	//exit;
	myZ := User.Z;
	while (User.DistTo(x, y, myZ) > 100) do begin
		if (User.Dead) or (count > 70) then begin //counter = 20, is 25 sec?
			//Print('To long passed.. distance to point = ' + IntToStr(User.DistTo(x, y, myZ)));
			break;
		end;
		if (IsUnderAttack) then begin
			//print('We are under attack, kill attackers!');
			KillAttackers;
		end else begin
			//Print('We are not under attack, proceed');
		end;
		MoveTo_Timer(x, y, z);
		count := count + 1;
		Delay(700);
		myZ := User.Z;
	end;
	result := User.InRange(x, y, z, 100);
end;

function GoTo_Spot_GemDragon1: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 15) and not (nZone = 14) then begin
		Print('Go to level 84 spot, Dragon Valley - Gemdragons 1');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToDragonValleyMid;
		CMoveTo(100469, 111383, -3680);
		CMoveTo(99621, 110560, -3704);
		CMoveTo(98448, 109746, -3705);
		CMoveTo(97536, 109443, -3704);
		CMoveTo(97061, 109186, -3584);
		CMoveTo(96528, 108547, -3336);
		CMoveTo(96121, 108086, -3184);
		CMoveTo(95557, 107774, -3112);
		CMoveTo(94653, 107708, -3040);
		CMoveTo(93754, 107635, -3024);
		CMoveTo(92694, 107629, -3032);
		CMoveTo(91989, 107642, -3043);
		CMoveTo(90732, 107529, -3092);
		CMoveTo(89694, 107522, -3072);
		CMoveTo(88855, 107627, -3072);
		CMoveTo(88092, 107819, -3064);
		CMoveTo(87072, 108083, -3117);
		CMoveTo(85983, 108320, -3200);  
	end;
	result := true;
end;
function GoTo_Spot_GemDragon2: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 16) and not (nZone = 15) and not (nZone = 14) then begin
		Print('Go to level 84 spot, Dragon Valley - Gemdragons 2');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToDragonValleyMid;
		CMoveTo(100624, 111558, -3680);
		CMoveTo(100259, 111147, -3672);
		CMoveTo(99626, 110537, -3695);
		CMoveTo(99026, 110059, -3704);
		CMoveTo(98412, 109704, -3717);
		CMoveTo(97822, 109505, -3704);
		CMoveTo(97313, 109321, -3650);
		CMoveTo(96932, 109136, -3568);
		CMoveTo(96783, 108842, -3440);
		CMoveTo(96293, 108253, -3240);
		CMoveTo(95856, 107855, -3136);
		CMoveTo(95224, 107731, -3072);
		CMoveTo(94722, 107695, -3048);
		CMoveTo(94048, 107641, -3024);
		CMoveTo(93291, 107615, -3026);
		CMoveTo(92559, 107623, -3034);
		CMoveTo(92125, 107612, -3038);
		CMoveTo(90848, 107549, -3083);
		CMoveTo(89377, 107452, -3083);
		CMoveTo(88619, 107065, -3160); 
		CMoveTo(88641, 106492, -3192);  
	end;
	result := true;
end;
function GoTo_Spot_GemDragon3: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 16) and not (nZone = 15) then begin
		Print('Go to level 84 spot, Dragon Valley - Gemdragons 3');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToDragonValleyMid;
		CMoveTo(100624, 111558, -3680);
		CMoveTo(100259, 111147, -3672);
		CMoveTo(99626, 110537, -3695);
		CMoveTo(99026, 110059, -3704);
		CMoveTo(98412, 109704, -3717);
		CMoveTo(97822, 109505, -3704);
		CMoveTo(97313, 109321, -3650);
		CMoveTo(96932, 109136, -3568);
		CMoveTo(96783, 108842, -3440);
		CMoveTo(96293, 108253, -3240);
		CMoveTo(95856, 107855, -3136);
		CMoveTo(95224, 107731, -3072);
		CMoveTo(94722, 107695, -3048);
		CMoveTo(94048, 107641, -3024);
		CMoveTo(93291, 107615, -3026);
		CMoveTo(92559, 107623, -3034);
		CMoveTo(92125, 107612, -3038);
		CMoveTo(90848, 107549, -3083);
	end;
	result := true;
end;

function GoTo_Spot_GemDragon4: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 22) then begin
		Print('Go to level 84 spot, Dragon Valley - Gemdragons 4');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToDragonValleyMid;
		CMoveTo(100447, 111442, -3680);
		CMoveTo(99808, 110671, -3704);
		CMoveTo(99199, 110140, -3696);
		CMoveTo(98202, 109740, -3710);
		CMoveTo(97469, 109659, -3698);
		CMoveTo(96336, 110144, -3696);
		CMoveTo(95571, 110010, -3690);
		CMoveTo(94795, 109810, -3704);
	end;
	result := true;
end;

function GoTo_Spot_Cata_ForbiddenPath: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 21) then begin
		Print('Go to level 72-82 spot, Catacomp - Forbidden Path');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortCataForbiddenPath;		
		CMoveTo(12741, -248452, -9576);
		CMoveTo(12982, -248415, -9576);
		CMoveTo(13324, -248476, -9576);
		CMoveTo(13829, -248477, -9576);
		CMoveTo(13802, -247418, -9576);
		CMoveTo(14563, -247034, -9576);
		CMoveTo(14756, -247038, -9576);
		CMoveTo(15206, -247047, -9576);
		CMoveTo(15192, -247699, -9576);
		CMoveTo(15162, -248081, -9576);
		CMoveTo(15671, -248067, -9576);
		CMoveTo(16035, -248068, -9576);
		CMoveTo(16319, -247704, -9576);
		CMoveTo(16293, -247229, -9576);
		CMoveTo(16273, -246929, -9576);
		CMoveTo(17584, -246921, -9576);
		CMoveTo(17549, -247360, -9576);
		CMoveTo(17553, -248183, -9576);
		CMoveTo(17686, -248458, -9576);
		CMoveTo(17800, -248487, -9576);
		CMoveTo(18421, -248482, -9576);
		CMoveTo(18643, -248383, -9576);
		CMoveTo(18643, -247831, -9576);
		CMoveTo(18604, -247642, -9576);
		CMoveTo(19014, -247675, -9576);
		CMoveTo(19746, -247677, -9576);
		CMoveTo(19718, -246606, -9576);
		CMoveTo(19740, -245885, -9576);
	end;
	result := true;
end;

function GoTo_Spot_Sph84: Boolean;
begin
	result := false;
	if (User.name = 'iLeech') then 
		GoTo_Spot_GemDragon1
	else if (User.name = 'iWind') then 
		GoTo_Spot_GemDragon2
	else if (User.Name = 'Devious') then
		GoTo_Spot_GemDragon3
	else if (User.Name = 'Mercedes') then
		GoTo_Spot_GemDragon4
	else if (User.Name = 'Merciless') then
		GoTo_Spot_Cata_ForbiddenPath;
	
	result := true;
end;
function GoTo_Spot_PlainsOfLizardmen: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 23) then begin
		Print('Go to level 82+ spot, Plains of Lizardmen - Moirai Helmet craft');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToPlainsOfLizardmen;
		Engine.MoveTo(87256, 85423, -3080);
		Engine.MoveTo(87319, 85155, -3080);
		Engine.MoveTo(87377, 84723, -3064);
		Engine.MoveTo(87474, 83868, -3056);
		Engine.MoveTo(87592, 83003, -3184);
		Engine.MoveTo(87755, 82294, -3336);
		
	end;
	result := true;
end;
function GoTo_Spot_VanorSilenos: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 17) then begin
		Print('Go to level 48+ spot, Vanor Silenos - Mithril Ore, Mold Glue');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToAden;
		Engine.MoveTo(147288, 27128, -2192);
		Engine.MoveTo(146289, 27590, -2184);
		Engine.MoveTo(145505, 27576, -2256);
		Engine.MoveTo(145064, 27432, -2248);
		Engine.MoveTo(144376, 26472, -2256);
		Engine.MoveTo(142819, 26364, -2371);
		Engine.MoveTo(141608, 26408, -2432);
		Engine.MoveTo(139572, 26324, -2574);
		Engine.MoveTo(138526, 25482, -2670);
		Engine.MoveTo(138418, 23810, -2928);
		Engine.MoveTo(138481, 22194, -3174);
		Engine.MoveTo(138446, 21411, -3301);
		Engine.MoveTo(138442, 20759, -3457);
		Engine.MoveTo(138184, 20600, -3584);
		Engine.MoveTo(137912, 20904, -3584);
	end;
	result := true;
end;
function GoTo_Spot_AboveBlazing: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 19) then begin
		Print('Go to level 70~ spot, Above Blazing Swamp, Asofe, DMP, Oriharukon Ore');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToAden;
		Engine.MoveTo(147448, 26600, -2184);
		Engine.MoveTo(147272, 26088, -2016);
		Engine.MoveTo(147176, 25864, -1992);
		Engine.MoveTo(146760, 25800, -2000);
		Delay(1000);
		Engine.SetTarget(30848);
		Delay(1000);
		Engine.DlgOpen;
		Delay(1500);
		Engine.DlgSel(1);
		Delay(1500);
		Engine.DlgSel(15);
		Delay(8000);
		Engine.MoveTo(155680, -16270, -3232);
		Engine.MoveTo(156269, -16240, -3104);
		Engine.MoveTo(156718, -16175, -3017);
		Engine.MoveTo(157224, -15972, -2934);
		Engine.MoveTo(157980, -15697, -2906);
		Engine.MoveTo(158464, -15539, -2950);
		Engine.MoveTo(158707, -15252, -2946);
		Engine.MoveTo(158870, -14889, -2977);
		Engine.MoveTo(158923, -14394, -3023);
		Engine.MoveTo(158924, -13906, -3023);
		Engine.MoveTo(158957, -13302, -2964);
		Engine.MoveTo(158648, -12888, -2840);
		Engine.MoveTo(157992, -12376, -2784);
	end;
	result := true;
end;
function GoTo_Spot_KetraLeft: Boolean;
var
nZone : Integer;
begin
	result := false;
	nZone := GetZone;
	if not (nZone = 20) then begin
		Print('Go to level 78~ spot, Ketra Left, Adamantite NUgget');
		GetOutOfCombat;
		if DetectStuck then exit;
		PortToKetra;
		
		Engine.MoveTo(146745, -67692, -3672);
		Engine.MoveTo(146078, -68083, -3664);
		Engine.MoveTo(145563, -68507, -3712);
		Engine.MoveTo(144258, -68857, -3760);
		Engine.MoveTo(142761, -69520, -3760);
		Engine.MoveTo(142508, -69602, -3763);
		Engine.MoveTo(141394, -69739, -3761);
		Engine.MoveTo(140437, -69836, -3737);
		Engine.MoveTo(139755, -69906, -3720);
		Engine.MoveTo(138560, -69958, -3617);
		Engine.MoveTo(137382, -70470, -3544);
		Engine.MoveTo(136631, -70204, -3208);

	end;
	result := true;
end;
function GoTo_Spot_Spoiler: Boolean;
begin
	result := false;
	if (User.name = 'Sheiva') then 
		//GoTo_Spot_VanorSilenos
		GoTo_Spot_KetraLeft
	else if (User.name = 'iSpoil') then
		GoTo_Spot_AboveBlazing
	else if (User.name = 'PowerSpoil') then
		GoTo_Spot_PlainsOfLizardmen
	else
		exit;
	
	result := true;
end;

function GoTo_Spot: Boolean;
begin
	result := false;
	if (User.Name = 'Merciless') then begin
		GoTo_Spot_Sph84;
	end else if GoTo_Spot_Spoiler then begin
		//nothing
	
	end else if IsClass_Sph(User.ClassId) and (User.Level >= 84) then begin
		
		GoTo_Spot_Sph84;
	
	end else if ((User.Level >= 76) and IsClass_Sph(User.ClassId))
			 or (User.Level >= 80) then begin
		if not (GetZone = 13) then begin
			Print('Go to level 79 spot, Dragon Valley - Drakos, Necromancers');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToDragonValley;
			CMoveTo(73203, 118076, -3720);
			CMoveTo(73880, 117879, -3736);
			CMoveTo(74410, 117754, -3753);
			CMoveTo(75029, 117625, -3760);
			CMoveTo(75904, 117459, -3750);
			CMoveTo(76628, 117279, -3776);
			CMoveTo(77196, 117143, -3767);
			CMoveTo(77840, 116913, -3778);
			CMoveTo(78466, 116696, -3795);
			CMoveTo(79321, 116434, -3715);
			CMoveTo(80131, 116291, -3608);
			CMoveTo(80640, 116297, -3517);
			CMoveTo(81137, 116518, -3383);
			CMoveTo(81755, 116906, -3225);
			CMoveTo(82293, 117265, -3110);
			CMoveTo(82937, 117683, -3040);
		end;
	end else if (User.Level >= 71) then begin
		if not (GetZone = 10) then begin
			Print('Go to level 70 spot, Varka - Near Spawn');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToVarka;
		end;
	end else if (User.Level >= 67) 
	and (not (IsClass_FighterType(User.ClassId)) or IsClass_Nuker(User.ClassId) or IsClass_Bp(User.ClassId) or IsClass_Archer(User.ClassId) or IsClass_Trick(User.ClassId))
	and not IsClass_Wc(User.ClassId) then begin
		if not (GetZone = 12) then begin
			Print('Go to level 67+ Mage/Archer spot, Pavel Ruins');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortPavel;
			CMoveTo(88937, -125350, -3808);
			CMoveTo(89676, -124451, -3912);
			CMoveTo(90733, -124080, -4059);
			CMoveTo(91861, -123685, -4216);
			CMoveTo(92382, -123327, -4280);
			CMoveTo(93111, -122646, -4544);
		end;
	end else if (User.Level >= 67) or ((User.level >= 65) and IsClass_Tyrant(User.ClassId)) then begin
		if not (GetZone = 2) then begin
			Print('Go to level 67+ Fighter spot, Silent Valley (or lv. 65 for tyrant)');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortSilentValley;
			CMoveTo(171039, 55884, -5344);
			CMoveTo(171461, 56182, -5496);
			CMoveTo(171964, 56514, -5664);
			CMoveTo(172513, 56584, -5792);
			CMoveTo(173479, 56245, -5931);
			CMoveTo(175539, 55138, -6000);
			CMoveTo(175987, 54962, -5992);
		end;
	end else if (User.Level >= 64) then begin
		if not (GetZone = 1) then begin
			Print('Go to level 64+ spot, Garden of beasts');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToGoddard;
			CMoveTo(147458, -56178, -2776);
			CMoveTo(146839, -56125, -2776);
			CMoveTo(146184, -56418, -2776);
			CMoveTo(145461, -56907, -2976);
			CMoveTo(144739, -57550, -2976);
			CMoveTo(144146, -57973, -3022);
			CMoveTo(143065, -58691, -3448);
			CMoveTo(142892, -59198, -3392);
			CMoveTo(142784, -59240, -3360);
			CMoveTo(142592, -59151, -3264);
			CMoveTo(142089, -59515, -3176);
		end;
		
	end else if (User.Level >= 55) then begin
		if not (GetZone = 11) then begin
			Print('Go to level 55+ spot, Fields of Massacre');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToFieldsOfMassacre;
			CMoveTo(183452, -15554, -2736);
			CMoveTo(183411, -15935, -2712);
			CMoveTo(183399, -16400, -2712);
			CMoveTo(183435, -17096, -2800);
			CMoveTo(183431, -17613, -2792);
			CMoveTo(183604, -18351, -2760);
		end;
		
	end else if (User.Level >= 46) then begin
		if not (GetZone = 9) then begin
			Print('Go to level 46 spot, The Cemetary');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToCemetary;
			CMoveTo(172152, 20092, -3328);
			CMoveTo(171811, 19565, -3328);
			CMoveTo(171341, 18941, -3328);
		end;
		
	end else if (User.Level >= 37) then begin
		if not (GetZone = 8) then begin
			Print('Go to level 37 spot, Ivory Tower - Crater');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToIvoryTower;
			CMoveTo(85402, 16352, -3664);
			CMoveTo(85342, 16568, -3608);
			CMoveTo(85336, 17464, -3512);
			CMoveTo(85321, 19827, -3784);
			CMoveTo(85327, 22062, -3512);
			CMoveTo(85328, 23375, -3520);
			CMoveTo(85330, 24104, -3632);
			CMoveTo(85004, 24046, -3616);
			CMoveTo(84878, 23828, -3576);
			CMoveTo(84492, 22773, -4848);
			CMoveTo(84347, 22055, -5288);
			CMoveTo(84274, 21259, -5280);
		end;
		
	end else if (User.Level >= 30) then begin
		if not (GetZone = 7) then begin
			Print('Go to level 30 spot, Cruma Marshlands - upper part');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToCruma;
			CMoveTo(16960, 114171, -3440);
			CMoveTo(16422, 114144, -3512);
			CMoveTo(16031, 114060, -3576);
			CMoveTo(16133, 113938, -3576);
			CMoveTo(16372, 113854, -3576);
			CMoveTo(16574, 113466, -3576);
			CMoveTo(17173, 112864, -3576);
			CMoveTo(17794, 112660, -3576);
			CMoveTo(18604, 112027, -3608);
			CMoveTo(19087, 111680, -3635);
			CMoveTo(19772, 111303, -3640);
			CMoveTo(20662, 110909, -3704);
			CMoveTo(21583, 110057, -3699);
			CMoveTo(21990, 109241, -3672);
			CMoveTo(22333, 108748, -3696);
			CMoveTo(22524, 107946, -3720);
		end;
		
	end else if (User.Level >= 23) then begin
		if not (GetZone = 6) then begin
			Print('Go to level 23 spot, Cruma Marshlands - lower part');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToCrumaMarsh;
			CMoveTo(5564, 126367, -3672);
			CMoveTo(6114, 125379, -3640);
			CMoveTo(6964, 124635, -3664);
			CMoveTo(7473, 124315, -3680);
		end;
		
	end else if (User.Level >= 16) then begin
		if not (GetZone = 5) then begin
			Print('Go to level 16 spot, Neutral Zone');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToNeutralZone;
			CMoveTo(-10680, 76974, -3592);
			CMoveTo(-10591, 77619, -3616);
			CMoveTo(-10302, 78583, -3616);
			CMoveTo(-10050, 79342, -3616);
		end;
		
	end else if (User.Level >= 6) then begin
		if not (GetZone = 4) then begin
			Print('Go to level 6 spot, Talking Island, north - golems');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToTalkingIsland;
			CMoveTo(-84099, 243634, -3728);
			CMoveTo(-84537, 243976, -3728);
			CMoveTo(-84456, 244163, -3728);
			CMoveTo(-84327, 244338, -3728);
			CMoveTo(-84122, 244584, -3728);
			LeadDlg(30006, 3, 9);
			Delay(10000);
			CMoveTo(-106435, 214664, -3424);
			CMoveTo(-105775, 214688, -3408);
			CMoveTo(-104694, 214835, -3424);
			CMoveTo(-103797, 214921, -3424);
			CMoveTo(-103081, 214738, -3288);
		end;
		
	end else if (User.Level >= 1) then begin
		if not (GetZone = 3) then begin
			Print('Go to level 1 spot, Talking Island, outside village');
			GetOutOfCombat;
			if DetectStuck then exit;
			PortToTalkingIsland;
			CMoveTo(-83781, 243601, -3728);
			CMoveTo(-83219, 244099, -3728);
			CMoveTo(-82406, 244921, -3720);
		end;
		
		
	end;
	
	if not (Engine.GetFaceState(0)) then Engine.FaceControl(0, true);
	
	result := true;
end;

function SetZone(): Integer;
var
nZone: IntegeR;
begin
	nZone := GetZone;
	result := nZone;
	
	
	if IsClass_Sph(User.ClassId) and (User.Level >= 84) then begin
		if (User.name = 'iLeech') then begin 
			cLoadZone('auto_gemdragon1.zmap');
			exit;
		end else if (User.name = 'iWind') then begin 
			cLoadZone('auto_gemdragon2.zmap');
			exit;
		end else if (User.Name = 'Devious') then begin
			cLoadZone('auto_gemdragon3.zmap');
			exit;
		end else if (User.Name = 'Mercedes') then begin
			cLoadZone('auto_gemdragon4.zmap');
			exit;
		end;
	
	end;
	
	case nZone of
		1: cLoadZone('auto_gardenOfBeasts1.zmap'); 	//made
		2: cLoadZone('auto_silentValley_Mid.zmap'); 	//made
		3: cLoadZone('auto_talkingIsland_vilout.zmap'); //made
		4: cLoadZone('auto_talkingIsland_north_golems.zmap'); //done
		5: cLoadZone('auto_neutralZone.zmap'); //done
		6: cLoadZone('auto_crumaMarshLow.zmap'); //done
		7: cLoadZone('auto_crumaMarshHigh.zmap'); //done
		8: cLoadZone('auto_ivoryCrater.zmap'); //done
		9: cLoadZone('auto_cemetary.zmap'); 
		10: cLoadZone('auto_varka.zmap'); //done
		11: cLoadZone('auto_fieldsOfMassacre.zmap'); //made
		12: cLoadZone('auto_pavel.zmap');
		13: cLoadZone('auto_dv_dracos.zmap');
		14: cLoadZone('auto_gemdragon1.zmap');
		15: cLoadZone('auto_gemdragon2.zmap');
		16: cLoadZone('auto_gemdragon3.zmap');
		17: cLoadZone('Auto_VanorSilenos.zmap');
		18: cLoadZone('auto_cemetary_taik.zmap');
		19: cLoadZone('auto_above_blazing.zmap');
		20: cLoadZone('auto_ketraLeft.zmap');
		21: cLoadZone('auto_cata_forbidden.zmap');
		22: cLoadZone('auto_gemdragon4.zmap');
		23: cLoadZone('auto_PlainsOfLizardmen.zmap');
		
		
		
		
	end;
	
end;

function GetZone: Integer;
var
z: Integer;
debugP: Boolean;
begin
	result := 0;
	debugP := false;
	z := User.Z;
	//Town of Goddard
	if (User.DistTo(147662, -56254, z) < 4500) then begin
		result := 100;
		if debugP then print('Zone 100 recognized - Town of Goddard');
		exit;
	
	//Garden of Beasts outside goddard
	end else if (User.DistTo(140465, -63188, z) < 7300)
	or (User.DistTo(137146, -52719, z) < 8000) then begin
		result := 1;
		if debugP then print('Zone 1 recognized');
		
	//Silent Valley
	end else if (User.DistTo(177421, 54688, z) < 9000) then begin
		result := 2;
		if debugP then print('Zone 2 recognized');
		
	//Talking Island, outside village
	end else if (User.DistTo(-79657, 246841, z) < 5000) then begin
		result := 3;
		if debugP then print('Zone 3 recognized');
		
	//Talking Island, north - golems
	end else if (User.DistTo(-101861, 216217, z) < 5200) then begin
		result := 4;
		if debugP then print('Zone 4 recognized');
		
	//Neutral Zone
	end else if (User.DistTo(-10050, 79342, z) < 16000) then begin
		result := 5;
		if debugP then print('Zone 5 recognized');
		
	//Cruma Marshlands Lower part
	end else if (User.DistTo(16031, 123728, z) < 10000) then begin
		result := 6;
		if debugP then print('Zone 6 recognized');
		
	//Cruma Marshlands Upper part
	end else if (User.DistTo(22023, 104945, z) < 8200) then begin
		result := 7;
		if debugP then print('Zone 7 recognized');
		
	//Ivory Crater
	end else if (User.DistTo(84093, 19896, z) < 11000)
		and (abs(z - (-5288)) < 300) then begin
		result := 8;
		if debugP then print('Zone 8 recognized');
	//Cemetary - Taiks
	end else if (User.DistTo(181560, 20376, z) < 6000) then begin
		result := 18;
		if debugP then print('Zone 18 recognized');
		
	//Cemetary
	end else if (User.DistTo(172748, 17628, z) < 15000) then begin
		result := 9;
		if debugP then print('Zone 9 recognized');
		
	//Varka Spawn
	end else if (User.DistTo(125744, -40864, z) < 13000) then begin
		result := 10;
		if debugP then print('Zone 10 recognized');
		
	//Fields of Massacre
	end else if (User.DistTo(180852, -21055, z) < 15000) then begin
		result := 11;
		if debugP then print('Zone 11 recognized');
		
	//Pavel Ruins
	end else if (User.DistTo(94220, -121241, z) < 3500) then begin
		result := 12;
		if debugP then print('Zone 12 recognized');
		
	//Dragon Valley - Drakos, Necromancers
	end else if (User.DistTo(84366, 119274, z) < 4200) then begin
		result := 13;
		if debugP then print('Zone 13 recognized');
	
	//Dragon Valley - Gemdragons 1
	end else if (User.DistTo(85453, 108039, z) < 3700) and (z > -3350) then begin
		result := 14;
		if debugP then print('Zone 14 recognized');
	
	//Dragon Valley - Gemdragons 2
	end else if (User.DistTo(88619, 107065, z) < 3000) and (z > -3350) then begin
		result := 15;
		if debugP then print('Zone 15 recognized');
	
	//Dragon Valley - Gemdragons 3
	end else if (User.DistTo(90848, 107549, z) < 3300) and (z > -3350) then begin
		result := 16;
		if debugP then print('Zone 16 recognized');
	
	//Vanor Silenos (48) Mithril Ore
	end else if (User.DistTo(135288, 24088, z) < 7000) then begin
		result := 17;
		if debugP then print('Zone 17 recognized');
	
	//18 is taken, on top
	
	//Above Blazing, Asofe,DMP
	end else if (User.DistTo(157688, -10936, z) < 6000) then begin
		result := 19;
		if debugP then print('Zone 19 recognized');
	
	//Ketra left, Adamantite Nugget Spoil
	end else if (User.DistTo(135257, -71655, z) < 6000) then begin
		result := 20;
		if debugP then print('Zone 20 recognized');
	
	//Catacomp Forbidden Path, Ancient Adena
	end else if (User.DistTo(19786, -245824, z) < 4000) and (z < -5900) then begin
		result := 21;
		if debugP then print('Zone 21 recognized');
	
	//GemDragon 4
	end else if (User.DistTo(94795, 109810, z) < 3000) and (z > -4000) and (z < -3500) then begin
		result := 22;
		if debugP then print('Zone 22 recognized');
	
	//Plains of Lizardmen
	end else if (User.DistTo(87755, 82294, z) < 13000) then begin
		result := 23;
		if debugP then print('Zone 23 recognized');
	
	end;
	
	
end;


function CheckDispellBuffs(idList: array of integer): Boolean;
var
i, len: Integer;
oBuff: Tl2Buff;
begin
	result := false;
	
	len := Length(idList);
	for i := 0 to len - 1 do begin
		if (User.Buffs.ById(idList[i], oBuff)) then begin
			Engine.Dispel(oBuff.Name);
			result := true;
			exit;
		end;
	end;
end;

function CheckUse_HeroSelfBuffs: Boolean;
begin
	result := false;
	if not User.Hero then exit;
	
	if (CheckUse_HeroicUD) then begin
		result := true;
		exit;
	end;
end;

function CheckUse_HeroicUD: Boolean;
begin
	result := false;
	if HasSkill_Ready(395) //395 = Heroic Miracle
	and not GetMemberHasUdBuff(User)
	and HasItem_MinCount(Engine, 1785, 40) then begin	//Have 40+ soul ore?
		if (User.Cp < 50) 
		and (User.Hp < 60) 
		and (GetCount_HasCharAsTarget_PvpOrPve(User) > 2) then begin
			Print('Use Heroic Miracle! [Buff: UD]');
			
			//Dispell Hero Zerk incase
			CheckDispellBuffs([396]);
			result := CUseSkill(395, false, false, Engine.GetFaceState(0));
		end;
	end;
end;

function CheckUse_HeroicValor_LeaderOnly: Boolean;
var
i: Integer;
begin
	result := false;
	
	if not (User.Name = GetName_Leader) then exit;
	
	if PvpLoaded 
	and HasIntervalPassed_BySkillId(1374, 4000)
	and (GetCount_PartyMembersHasBuff(1374) < 3) then begin	//	1374 = Heroic Valor
		//print('Find member to use Heroic Valor');	
		if Use_HeroicValor_OnFirstAvailableHero then begin
			print('Use Heroic Valor');
			SetInterval_OnSkillId(1374, 4000);
			result := true;
		end;
	end;
	
end;

function Use_HeroicValor_OnFirstAvailableHero(): Boolean;
var
i: Integer;
targetControl: Tl2Control;
oSkill : Tl2Skill;
begin
	result := false;
	i := 0;
	targetControl := GetControlByIndex(i);
	while Assigned(targetControl) do begin
		if (targetControl.GetUser.Hero) 
		and (IsTarget_GoodState_Party(targetControl.GetUser, 700))
		and (targetControl.GetSkillList.ById(1374, oSkill))
		and not (oSkill = nil)
		and (oSkill.Valid) 
		and (oSkill.EndTime <= 0) 
		and HasItem_MinCount(targetControl, 3031, 80) then begin  //Has 80 spirit Ore?
			Print('Use Heroic Valor on ' + targetControl.GetUser.Name);
			result := targetControl.DUseSkill(1374, false, false);
			result := targetControl.DUseSkill(1374, false, false);
			result := targetControl.DUseSkill(1374, false, false);
			exit;
		end;	
		i := i + 1;
		targetControl := GetControlByIndex(i);
	end;
end;

function GetCount_PartyMembersHasBuff(nBuffId: Integer): Integer;
var
i, counter: Integer;
oTarget: Tl2Char;
oBuff: Tl2Buff;
begin
	result := -1;
	if (User.Buffs.ById(nBuffId, oBuff)) then
		counter := 1
	else
		counter := 0;
		
	for i := 0 to Party.Chars.Count - 1 do begin
		oTarget := Party.Chars.Items(i);
		if (oTarget = nil) or (oTarget.Name = '') or not (oTarget.Valid) then continue;
		if (oTarget.Buffs.ById(nBuffId, oBuff)) then Inc(counter);
	end;
	result := counter;
end;


function CheckLeaderDistance(maxDist : Integer = -1; FollowFear: Boolean = true): Boolean;
var
z: Integer;
oLeader: Tl2Char;
sLeaderName: string;
begin	
	result := false;
	if (maxDist < 0) then begin
		maxDist := MAX_PARTY_PT_DIST;	
	end;
	sLeaderName := GetName_LocalLeader;
	if Party.Chars.ByName(sLeaderName, oLeader) then begin
		if not FollowFear and IsTarget_Feared_Live(oLeader as Tl2Live) then exit;
		if (User.DistTo(oLeader) > maxDist) then begin
			//print('Distance to leader is too big, auto follow!');
			AutoFollow;
			result := true;
		end;
	end else if (CharList.ByName(sLeaderName, oLeader)) then begin
		if not FollowFear and IsTarget_Feared_Live(oLeader as Tl2Live) then exit;
		if (User.DistTo(oLeader) > maxDist) then begin
			AutoFollow;
			result := true;
		end;
	end;
end;

function GetSettingXmlNamePrefix: string;
begin
	if (IsClass_Bp(User.ClassId)) then begin
		
		if (User.Level < 78) then begin
			result := 'BishopLow';
			exit;
		end;
		
		if (User.Name = GetName_Healer1) then begin
			result := 'Bishop1';
			
		end else if (User.Name = GetName_Healer2) then begin
			result := 'Bishop2';
			
		end else if (User.Name = GetName_Healer3) then begin
			result := 'Bishop3';
			
		end else if (GetSubPartyNum > 0) then begin
			result := 'BishopOff';
		
		end else begin
			Print('Load Settings ERROR: Cannot find a matching bishop name');
			result := 'Bishop3';
		end;
		
	end else if (IsClass_Tank(User.ClassId)) then begin
		result := 'DarkAvenger';
		
	end else if (IsClass_Wl(User.ClassId)) then begin
		result := 'Warlord';
		
	end else if (IsClass_Ee(User.ClassId)) then begin
		if (User.Name = GetName_Ee) then begin
			result := 'ElvenElder1';
		end else begin
			Print('Load Settings WARNING: Cannot find a matching elven elder name (doesnt matter)');
			result := 'ElvenElder1';
		end;
		
	end else if (IsClass_Sorc(User.ClassId)) then begin
		result := 'Sorcerer';
		
	end else if (IsClass_Sps(User.ClassId)) then begin
		result := 'Spellsinger';
		
	end else if (IsClass_Ol(User.ClassId)) then begin
		result := 'Overlord';
		
	end else if (IsClass_Slh(User.ClassId)) then begin
		result := 'SoulHound';
		
	end else if (IsClass_Spoiler(User.ClassId)) then begin
		result := 'Spoiler';
		
	end else if (IsClass_Tyrant(User.ClassId)) then begin
		result := 'Tyrant';
		
	end else if (IsClass_Db(User.ClassId)) then begin
		result := 'Doombringer';
		
	end else if (IsClass_Gh(User.ClassId)) then begin
		result := 'GhostHunter';
		
	end else if (IsClass_Necro(User.ClassId)) then begin
		result := 'Necro';
		
	end else if (IsClass_Se(User.ClassId)) then begin
		result := 'SELow';
				
	end else begin
		Print('Load Settings ERROR: Cannot find a matching class!');
		result := '';
	end;
end;


function SetupTankSkills(	out AuraHate: TSkill): Boolean;
var
	AuraHatePve: TSkill;
	tempValidateFunc: TValidateTargetFunction;						
	
begin
	result := false;
	
	//Aura Hate - Id = 18
	AuraHatePve := TSkill.Create(18, 400, false, false);
	tempValidateFunc := ValidateTarget_HasMemberTarget;
	AuraHatePve.Target.ValidationFunction := tempValidateFunc;
	tempValidateFunc := nil;
	AuraHatePve.RequiresTarget := false;
	AuraHatePve.IsAoeSkill := true;
	AuraHatePve.Target.SkillRadius := 200;
	
	AuraHate := AuraHatePve;
	result := true;
end;

function Simple_PassCommandToSubParty(sCommand: string): Boolean;
var
subLeaderName: String;
begin
	result := false;
	subLeaderName := GetName_SubPartyLeader(GetPartyNum);
	if (subLeaderName = '') then begin
		Print('Sub leader not recognized.');
		exit;
	end;
	//Send commands two times, incase of miss-read
	result := Engine.Say(sCommand, 2, subLeaderName);
	result := Engine.Say(sCommand, 2, subLeaderName);
end;

function GetName_SubPartyLeader(PartyNum: Integer): string;
begin
	result := '';
	if (PartyNum = 1) then result := GetName_FirstSubPartyLeader;
	if (PartyNum = 2) then result := GetName_SecondSubPartyLeader;
	if (PartyNum = 3) then result := GetName_ThirdSubPartyLeader;
	
end;

function GetName_FirstSubPartyLeader: string;
begin
	result := 'Astraeus';
	//result := 'Sheyrena';
end;
function GetName_SecondSubPartyLeader: string;
begin
	result := 'Aldric';
	//result := 'iRecovery';
end;
function GetName_ThirdSubPartyLeader: string;
begin
	result := 'Hermes';
end;
procedure Detect_CannotSeeTarget;
var
id, p: cardinal;
begin
	Print('Detect_CannotSeeTarget: Started procedure.');
	while true do begin
		Engine.WaitAction([laSysMsg], id, p);
		if (id = 181) then begin
			try
				SysMsg_CannotSeeTarget := true;
				Delay(500);
			finally
				SysMsg_CannotSeeTarget := false;
			end;
		end;
	end;
end;

function CheckPrevent_CannotSeeTarget: Boolean;
var
oTarget: Tl2Live;
skillMaxRange, x, y, z: Integer;
begin
	result := false;
	if not (Mode_DetectSystemMessages) then exit;
	if not (SysMsg_CannotSeeTarget) then exit;
	if (User.Target = nil) then exit;
	
	oTarget := User.Target;
	if MODE_GOD then skillMaxRange := 1100
	else skillMaxRange := 900;
	
	if (oTarget = nil)
	or (User.DistTo(oTarget) > skillMaxRange) then exit;
	
	x := oTarget.X;
	y := oTarget.Y;
	z := oTarget.Z;
	if not (User.Target = User) then
		Engine.SetTarget(User);
	result := Engine.DMoveTo(x, y, z);	
end;
(*
procedure AntiStuck_MoveToTarget;
var
count, x, y, z, lastX, lastY, lastZ: Integer;
id, p: cardinal;
oTarget, lastTarget: Tl2Live;
begin
	print('AntiStuck_MoveToTarget: Started Procedure.');
	Delay(1000);
	count := 0;
	lastTarget := nil;
	while true do begin
		Engine.WaitAction([laSysMsg], id, p);
		if (id = 181) then begin
			delay(150);
			
			if (Engine.GetFaceState(0))then begin
				Engine.FaceControl(0, false);
				oTarget := User.Target;
				
				if not (oTarget = nil) and oTarget.Valid then begin

					if not (lastTarget = oTarget) then begin
						lastTarget := oTarget;
						count := 1;
					end else begin // if lastTarget = oTarget --> same target as last time.
						count := count + 1;
					end;
					lastX := User.X; 	lastY := User.Y; 	lastZ := User.Z;
					MoveToTarget_Timeout(oTarget, 10, 1000); 
					
					//If we are within 15 range after moving, increase count to anti stuck
					if (User.DistTo(lastX, lastY, lastZ) < 15) then begin
						Print('AntiStuck_MoveToTarget: Stuck Detected! We didnt move at all, possible stuck detected!');
						count := count + 5;
					end;
				end;
				engine.FaceControl(0, true);
				
				if (count >= 10) then begin
					print('AntiStuck_MoveToTarget: Stuck Detected! (nCount >= 10) procedure has stalled. Disable for 20 seconds.');
					count := 0;
					Delay(20000);
				end;
			end;
			
		end;
	end;
end; *)

function IsTarget_Leader(sName: string): Boolean;
begin
	result := false;
	if (sName = GetName_Leader)
	or (sName = GetName_SecondLeader)
	or (sName = GetName_ThirdLeader) then begin
	//or (sName = GetName_SubPartyLeader(GetPartyNum)) then begin
		result := true;
	end;
end;

function IsTarget_InMyGroup(control: Tl2Control): Boolean;
var
cUser: Tl2User;
oMember: Tl2Char;
begin
	result := false;
	if not Assigned(control) then exit;
	cUser := control.GetUser;
	if (cUser = nil) or (cUser.Name = '') then exit;
	if (cUser.Oid = User.Oid) then begin
		result := true;
		exit;
	end else if (Party.Chars.ByName(cUser.name, oMember)) then begin
		result := true;
		exit;
	end;
	
	result := (GetPartyNum = GetSubPartyNum(control));
end;

function CheckBashGate(callerName: string): Boolean;
var
oCaller: Tl2Char;
begin
	result := false;
	//Print('Bash gate started');
	if not Mode_BashGate then exit;
	
	//Print('Bash gate 1');
	if (GetClassValue_Healer(User.ClassId) > 0) or (IsClass_Ol(User.ClassId)) then exit;
	//Print('Bash gate 2');
	if not (CharList.ByName(callerName, oCaller)) then exit;
	//Print('Bash gate 3');
	///Engine.SetTarget(oCaller);
	//Delay(300);
	//Engine.UseAction(6);
	//Delay(300);
	Engine.Assist(callerName);
	result := Action_UseNukeSkill;
	
	//Print('Bash gate ended');
end;

function CheckUse_Stigma: Boolean;
var
oMa: Tl2Char;
oTarget: Tl2Live;
begin
	result := false;
	if not HasSkill_Ready(1539) 
	or (User.CurMp < 30) then exit;
	oMa := GetTarget_MainAssist;
	if (oMa = User) or (oMa = nil) then exit;
	oTarget := oMa.Target;
	
	if (oTarget = nil) then exit;
	if (TimerEx_OnChar(oTarget, 25000)) then begin
		Engine.SetTarget(oTarget);
		result := Engine.UseSkill(1539);
	end;
	
end;


function GetTarget_ToRez_ByExceptions(): Tl2Char;
var 
i, nCurRange, nCurClassImportance, nLastClassImportance, classID : Integer;
oCurTarget, oLastTarget: Tl2Char;
myParty: TParty;
foundDeadMember: Boolean;
oBuff: Tl2BUff;
begin
	result := nil;
	
	foundDeadMember := false;
	nLastClassImportance := -1;
	oLastTarget := nil;
	//myParty := control.GetParty;
	
	if (User.Dead) and not IHaveBuff(5145) then begin //dont consider ourself if we have dod.
		foundDeadMember := true;
		nLastClassImportance := GetClassValue_PartyImportance(User.ClassId);
		oLastTarget := User;
	end;
	
	for i := 0 to CharList.Count - 1 do begin 

		oCurTarget := CharList.Items(i);
		//if not IsTarget_ValidAndVisible_Char(oCurTarget) then Continue;
		if (oCurTarget = nil) or (oCurTarget.Name = '') then continue;
		nCurRange := User.DistTo(oCurTarget);
		if (nCurRange > 900) then break;
		if not (oCurTarget.Dead) then continue;
		
		//if (foundDeadMember) then begin
			//if not (oCurTarget.Oid = User.Oid) and not (oCurTarget.IsMember) then continue;
		//end;
		
		if not (IsTarget_Friendly(oCurTarget)) then continue;
		
		//Check members for dod
		if (oCurTarget.Oid = User.Oid) or (oCurTarget.IsMember) then begin
			if (oCurTarget.Buffs.ById(5145, oBuff)) then continue;
		end else if CheckIfControlHasBuff_ByName(5145, oCurTarget.Name) then continue;
		
		//Check exceptions
		if (fp_target_inc.CharExceptionListContains(RezExceptionList, oCurTarget)) then continue;
		
		classID := oCurTarget.ClassID;
		nCurClassImportance := GetClassValue_PartyImportance(classID);
		
		(*if not foundDeadMember then begin
			if (oCurTarget.Oid = User.Oid) or (oCurTarget.IsMember) then begin
				foundDeadMember := true;
				//Overide previous target, since it was not a member.
				oLastTarget := oCurTarget;
				nLastClassImportance := nCurClassImportance;
				continue;
			end;
		end;*)
		
		
		//More Important Class?	
		if (nCurClassImportance > nLastClassImportance) then begin
			oLastTarget := oCurTarget;
			nLastClassImportance := nCurClassImportance;
		end;
	end;
	
	result := oLastTarget;
end;



function HandleResurrection_Healer1Only: Boolean;
var
rezId: Integer;
oTarget, mainHealer: Tl2Char;
controlUser: Tl2User;
oHealer: Tl2Control;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	
	if (DuoPartyMode) then begin
		if CharList.ByName(GetName_Healer1_ByPartyNum(1), mainHealer) then begin //1 for main party
			if (User.DistTo(mainHealer) < 900) then begin
				//if we are using duoPartyMode, and main healer is close, let him handle ressurection.
				exit;
			end;
		end;
	end;
	
	
	if MODE_GOD then rezId := 11784
	else rezId := 1016;
	
	CleanUp_RezExceptionList();
	while true do begin
		oTarget := GetTarget_ToRez_ByExceptions;
		if (oTarget = nil) or (oTarget.Name = '') then break;
		oHealer := FindClosest_AbleRezzer(oTarget);
		if not Assigned(oHealer) then break;
		controlUser := oHealer.GetUser;
		if (controlUser = nil) then break;

		Print(oTarget.Name + ' is dead!   ' + controlUser.Name + ' rez him!');
		
		CheckCancel_LessImportantSkillCasting(oHealer);
		oHealer.SetTarget(oTarget);
		Print('add ' + oTarget.Name + ' to rez exception list!');
		RezExceptionList.Add(oTarget);
		SetTimer_OnPerson(oTarget.Oid, 1016, 2000); //1016 rez id
		SetTimer_OnPerson(controlUser.Oid, 1016, 3000); //1016 rez id
		if (HasSkill_Ready(1016, oHealer)) then oHealer.DUseSkill(rezId, false, false)
		else if (HasItem_MinCount(oHealer, 3936, 1)) then oHealer.UseItem(3936);
	end;

end;

function FindClosest_AbleRezzer(oDeadFriend: Tl2Char): Tl2Control;
var
i, mpCost, rezId, lastRange, curRange: Integer;
curControl, lastControl: Tl2Control;
healerFound: Boolean;
curControlUser, lastControlUser: Tl2User;
begin
	result := nil;

	if (oDeadFriend = nil) or (oDeadFriend.Name = '') then exit;	
	
	mpCost := 100;
	healerFound := false;
	lastRange := 1000000;
	lastControl := nil;
	lastControlUser := nil;
	
	if MODE_GOD then rezId := 11784
	else rezId := 1016;
	
	i := 0;
	curControl := GetControlByIndex(i);
	while Assigned(curControl) do begin
		curControlUser := curControl.GetUser;
		
		if not (curControlUser = nil) and (curControl.Status = lsOnline) 
		and not (curControlUser.Oid = oDeadFriend.Oid) then begin
			if (GetClassValue_Healer(curControlUser.ClassId) > 0) then begin
				if DuoPartyMode or IsTarget_InMyGroup(curControl) then begin
					curRange := oDeadFriend.DistTo(curControlUser);
					if (curRange < 900) then begin
						
						if (HasSkill_Ready(rezId, curControl)) and not IsTarget_Disabled(curControlUser) then begin
						
							//Either the healer should not be casting at all, or it should be casting smth like major heal or recharge, and then we cancel it
							if (curControlUser.Cast.EndTime <= 0) or (curControlUser.Cast.EndTime > 1000000) or (IsTarget_CastingLessImportantSkill(curControlUser)) then begin
								if TimerExpired_OnPerson(curControlUser.Oid, 1016) and (curControlUser.CurMp > mpCost) then begin
									if (curRange < lastRange) then begin
										healerFound := true;
										lastControlUser := curControlUser;
										lastControl := curControl;
										lastRange := curRange;
									end;
								end;
							end;
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		curControl := GetControlByIndex(i);
	end;
	
	//If no free healers were found, check if someone needs to use Blessed Scroll of resurrection.
	if not healerFound then begin
		i := 0;
		curControl := GetControlByIndex(i);
		while Assigned(curControl) do begin
			curControlUser := curControl.GetUser;
			if not (curControlUser = nil) and (curControl.Status = lsOnline)  then begin
		
				curRange := oDeadFriend.DistTo(curControlUser);
				if (curRange < 900) then begin
					
					if (HasItem_MinCount(curControl, 3936, 1)) and not IsTarget_Disabled(curControlUser) then begin

						if (curRange < lastRange) then begin
							healerFound := true;
							lastControlUser := curControlUser;
							lastControl := curControl;
							lastRange := curRange;
						end;
						
					end;
				end;
			end;
			Inc(i);
			curControl := GetControlByIndex(i);
		end;		
	end;
	result := lastControl;
end;

function IsTarget_CastingLessImportantSkill(oTarget: Tl2Char): Boolean;
var
castId: Integer;
begin
	result := false;
	if (oTarget = nil) or (oTarget.name = '') then exit;
	
	if (oTarget.Cast.EndTime <= 0) or (oTarget.cast.EndTime > 60000) then exit;
	
	castId := oTarget.Cast.Id;
	if (castId = 0) then exit;
	
	if (GetClassValue_Healer(oTarget.ClassId) > 0) then begin
		if (castId = 1217) //GH
		or (castId = 1218) //GBH
		or (castId = 1219) //GGH
		or (castId = 1401) //MH
		or (castId = 1402) //MGH
		or (castId = 1307) //Prayer
		or (castId = 1394) //trance
		or (castId = 1398) //mana burn
		or (castId = 1013) then begin//recharge
			result := true;
		end;
	end;
end;
function CheckCancel_LessImportantSkillCasting(control: Tl2Control): Boolean;
var
controlUser: Tl2User;
castId: Integer;
begin
	result := false;
	if not Assigned(control) then exit;
	controlUser := control.GetUser;
	if (controlUser = nil) or not (control.Status = lsOnline) then exit;
	
	if IsTarget_CastingLessImportantSkill(controlUser) then begin
		control.StopCasting();
		result := true;
	end;
end;


function HandleCleanse_Healer1Only: Boolean;
var
cleanseID: Integer;
oTarget, mainHealer: Tl2Char;
controlUser: Tl2User;
oHealer: Tl2Control;
mainHealerName: string;
begin
	result := false;
	if not (User.Name = GetName_Healer1) then exit;
	
	if DuoPartyMode then begin
		mainHealerName := GetName_Healer1_ByPartyNum(1);
		if not (User.Name = mainHealerName) then begin
			oHealer := GetControl(mainHealerName);
			if Assigned(oHealer) then begin
				//Main healer is at this pc, let him handle cleanse
				exit;
			end else oHealer := nil;
		end;
	end;
	
	if MODE_GOD then cleanseID := 11763
	else cleanseID := 1409;
	
	CleanUp_CleanseExceptionList();
	while true do begin
	
		oTarget := GetTarget_ToCleanse_ByExceptions;
		
		if (oTarget = nil) or (oTarget.Name = '') then break;
		oHealer := FindClosest_AbleCleanser(oTarget);
		
		if not Assigned(oHealer) then break;
		
		controlUser := oHealer.GetUser;
		if (controlUser = nil) then break;

		Print(oTarget.Name + ' is debuffed!   ' + controlUser.Name + ' cleanse him!');
		
		CheckCancel_LessImportantSkillCasting(oHealer);
		oHealer.SetTarget(oTarget);
		CleanseExceptionList.Add(oTarget);
		SetTimer_OnPerson(oTarget.Oid, 1409, 2000); //1409 cleanse id
		SetTimer_OnPerson(controlUser.Oid, 1409, 2500); //1409 cleanse id
		oHealer.DUseSkill(cleanseID, false, false);
	end;

end;



//Get a target that is either Ourself, InOurParty, or InOurSubParty.
//Skip dead or invincible targets.
function GetTarget_ToCleanse_ByExceptions(): Tl2Char;
var 
i, nCurRange, nCurClassImportance, nLastClassImportance, nCurDebuffState, nLastDebuffState : Integer;
oCurTarget, oLastTarget: Tl2Char;
begin
	result := nil;
	
	nLastClassImportance := -1;
	oLastTarget := nil;
	nLastDebuffState := 0;
	
	//Check ourself
	nCurDebuffState := IsTarget_Debuffed_GetState(User);
	if (nCurDebuffState > nLastDebuffState) 
	and not (User.Dead) 
	and not (IsFriend_Invincible(User)) then begin
		nLastClassImportance := GetClassValue_PartyImportance(User.ClassId);
		nLastDebuffState := nCurDebuffState;
		oLastTarget := User;
	end;
	
	
	for i := 0 to CharList.Count - 1 do begin 
		oCurTarget := CharList.Items(i);
		if (oCurTarget = nil) or (oCurTarget.Name = '') or not (oCurTarget.Valid) then continue;
		nCurRange := User.DistTo(oCurTarget);
		if (nCurRange > 900) then break;
		
		if DuoPartyMode then begin
			if not IsTarget_Friendly(oCurTarget) then continue;
		end else begin
			if not (IsTarget_InMyGroup(GetControl(oCurTarget.Name))) then continue;
		end;
		//Check exceptions
		if (fp_target_inc.CharExceptionListContains(CleanseExceptionList, oCurTarget)) then continue;
		
		nCurDebuffState := IsTarget_Debuffed_GetState(oCurTarget);

		if (nCurDebuffState <= 0) 
		or IsFriend_Invincible(oCurTarget)
		or (oCurTarget.Dead) then Continue;
		
		nCurClassImportance := GetClassValue_PartyImportance(oCurTarget.ClassID);
    
		//Worse Debuff?
		if (nCurDebuffState > nLastDebuffState) then begin
			oLastTarget := oCurTarget;
			nLastClassImportance := nCurClassImportance;
			nLastDebuffState := nCurDebuffState;
		end else if (nCurDebuffState = nLastDebuffState) then begin
	
			//More Important Class?	
			if (nCurClassImportance > nLastClassImportance) then begin
				oLastTarget := oCurTarget;
				nLastClassImportance := nCurClassImportance;
				nLastDebuffState := nCurDebuffState;
			end;
			
		end;
	end;
	
	result := oLastTarget;
end;


function FindClosest_AbleCleanser(oFriendToCleanse: Tl2Char): Tl2Control;
var
i, mpCost, cleanseID, lastRange, curRange: Integer;
curControl, lastControl: Tl2Control;
curControlUser, lastControlUser: Tl2User;
begin
	result := nil;

	if (oFriendToCleanse = nil) or (oFriendToCleanse.Name = '') then exit;	
	
	mpCost := 100;
	lastRange := 1000000;
	lastControl := nil;
	lastControlUser := nil;
	
	if MODE_GOD then cleanseID := 11763
	else cleanseID := 1409;
	
	i := 0;
	curControl := GetControlByIndex(i);
	while Assigned(curControl) do begin
		curControlUser := curControl.GetUser;
		
		if not (curControlUser = nil) and (curControl.Status = lsOnline) then begin
			if (IsClass_Bp(curControlUser.ClassId)) then begin
				if DuoPartyMode or IsTarget_InMyGroup(curControl) then begin
					curRange := oFriendToCleanse.DistTo(curControlUser);
					if (curRange < 900) then begin
						
						if (HasSkill_Ready(cleanseID, curControl)) 
						and not IsTarget_Disabled(curControlUser)
						and (MODE_GOD or HasItem_MinCount(curControl, 8874, 1)) then begin
						
							//Either the healer should not be casting at all, or it should be casting smth like major heal or recharge, and then we cancel it
							if (curControlUser.Cast.EndTime <= 0) or (curControlUser.Cast.EndTime > 1000000) or (IsTarget_CastingLessImportantSkill(curControlUser)) then begin
								if TimerExpired_OnPerson(curControlUser.Oid, 1409) and (curControlUser.CurMp > mpCost) then begin
									if (curRange < lastRange) then begin
										lastControlUser := curControlUser;
										lastControl := curControl;
										lastRange := curRange;
									end;
								end;
							end;
						end;
					end;
				end;
			end;
		end;
		Inc(i);
		curControl := GetControlByIndex(i);
	end;
	
	result := lastControl;
end;


function IsTime_ToCleanseFriends(): Boolean;
var 
i, nCurDebuffState : Integer;
oCurTarget: Tl2Char;
begin
	result := false;
	
	//Check ourself
	nCurDebuffState := IsTarget_Debuffed_GetState(User);
	if (nCurDebuffState > 0) 
	and not (User.Dead) 
	and not (IsFriend_Invincible(User)) then begin
		result := true;
		exit;
	end;
	
	
	for i := 0 to CharList.Count - 1 do begin 
		oCurTarget := CharList.Items(i);
		if (oCurTarget = nil) or (oCurTarget.Name = '') or not (oCurTarget.Valid) then continue;

		if (User.DistTo(oCurTarget) > 900) then break;
		
		if DuoPartyMode then begin
			if not IsTarget_Friendly(oCurTarget) then continue;
		end else begin
			if not (IsTarget_InMyGroup(GetControl(oCurTarget.Name))) then continue;
		end;
		
		nCurDebuffState := IsTarget_Debuffed_GetState(oCurTarget);

		if (nCurDebuffState <= 0) 
		or IsFriend_Invincible(oCurTarget)
		or (oCurTarget.Dead) then Continue;
		
    
		//Worse Debuff?
		if (nCurDebuffState > 0) then begin
			result := true;
			exit;
		end;
	end;
	
end;

function Handle_Pickup_Healer1Only: Boolean;
var
oTarget: Tl2Char;
targetControl: Tl2Control;
oDrop, oLastDrop: Tl2Drop;
i, j, indexedPriority, lastIndexedPriority, x, y, z, index: Integer;
targetOid, dropOid: Cardinal;

begin
	result := false;
	if not Mode_Pickup then exit;
	
	if not (User.Name = GetName_Healer1) then begin
		result := true;
		exit; //return true and exit, so all other bots doesnt do anything else.
	end;
	
	for i := 0 to Party.Chars.Count do begin
		if (i = Party.Chars.Count) then oTarget := User
		else oTarget := Party.Chars.Items(i);
		
		if (oTarget = nil) or (oTarget.Name = '') then continue;
		
		if (User.DistTo(oTarget) > 1000) then continue;
		
		targetControl := GetControl(oTarget.Name);
		
		if not Assigned(targetControl) then continue;
		
		if IsTarget_Disabled(oTarget)
		or (DropDistributionList.IndexOf(IntToStr(oTarget.Oid)) > -1) then continue; //Dont assign the same character to several drops. Duh.
		
		//At this point, the character is ready to get a drop assigned to pickup.
		oLastDrop := nil;
		lastIndexedPriority := 10000000;
		//find the drop:
		for j := 0 to Droplist.Count - 1 do begin
			oDrop := Droplist.Items(j);
			if (oDrop = nil) or not (oDrop.Valid) then continue;
			if (User.DistTo(oDrop) > 1000) then break;
			if (pos('Herb', oDrop.Name) > 0) then continue; //dont pick fkin herbs.
			
			indexedPriority := DropPriorityList.IndexOf(IntToStr(oDrop.Id));
			if (indexedPriority < 0) then indexedPriority := DropPriorityList.Count + 1; //If item is not present in the list, give lowest priority.
			
			if (DropDistributionList.IndexOf(IntToStr(oDrop.Oid)) > -1) then continue; //Dont add same drop twice.
			
			if (indexedPriority < lastIndexedPriority) then begin
				oLastDrop := oDrop;
				lastIndexedPriority := indexedPriority;
			end;
			
			
		end;
		
		// if a drop was found, assign the drop to the given character.
		if not (oDrop = nil)
		and not (oDrop.Oid = 0)
		and not (oTarget.Oid = 0) then begin
			DropDistributionList.Add(IntToStr(oTarget.Oid));
			DropDistributionList.Add(IntToStr(oLastDrop.Oid));
		end;
	end;
	
	//Command everyone to pick their drops.
	if not (DropDistributionList = nil)
	and (DropDistributionList.Count > 0) then begin
		for i := 0 to ((DropDistributionList.Count div 2) - 1) do begin
			if ((i*2) + 1 > DropDistributionList.Count - 1) then exit;
			targetOid := StrToIntDef(DropDistributionList[i*2], 0);
			dropOid := StrToIntDef(DropDistributionList[(i*2) + 1], 0);
			//if (targetOid = 0) or (dropOid = 0) then begin
			
			oTarget := GetMember_ByOid(targetOid);
			oDrop := GetDrop_ByOid(dropOid);
			
			//If Drop has been picked, or the Target has disappeared, remove them from list and continue;
			if (oTarget = nil) or (oDrop = nil) then begin
			
				//Remove the target
				//index := DropDistributionList.IndexOf(IntToStr(oTarget.Oid));
				//if (index >= 0) then begin
					DropDistributionList.Delete(i*2);
					DropDistributionList.Delete(i*2); //same position, because it gets moved to index - 1 because we use .Delete in previous line
					i := i - 1;
				//end;
				
				//Remove the drop
				//index := DropDistributionList.IndexOf(IntToStr(oDrop.Oid));
				//if (index >= 0) then begin
				//end;
				
				
				continue;
			end;
			targetControl := GetControl(oTarget.Name);
			if not Assigned(targetControl) then continue;
			
			if (oTarget.DistTo(oDrop) > 50) then begin
				x := oDrop.X; y := oDrop.Y; z := oDrop.Z;
				targetControl.DMoveTo(x, y ,z);
			end else begin
				targetControl.PickUp(oDrop);
			end;
			
		end;
	end;
	
	result := true;
end;

function GetDrop_ByOid(nOid: Cardinal): Tl2Drop;
var
i : Integer;
oDrop : Tl2Drop;
begin
	result := nil;
	for i := 0 to DropList.Count - 1 do begin
		oDrop := DropList.Items(i);
		if (oDrop = nil) or not (oDrop.Valid) then continue;
		if (User.DistTo(oDrop) > 2000) then break;
		if (oDrop.Oid = nOid) then begin
			//drop found
			result := oDrop;
			exit;
		end;
	end;
end;

function ControlHasParty(control: Tl2Control): Boolean;
begin
	result := false;
	if not Assigned(control) then exit;
	
	if (control.GetParty.Chars.Count > 0) then result := true;
end;

function ControlLeaveParty(control: Tl2Control): Boolean;
begin
	result := false;
	if not Assigned(control) then exit;
	
	control.LeaveParty;
end;

function HandleOopBuffing_LeaderTypeOnly: Boolean;
var
partyNum: Integer;
isMageParty: Boolean;
utilityChar, oopBuffer: Tl2Char;
utilityName, oopBufferName: string;
control: Tl2Control;
begin
	result := false;
	
	
	if not IsTarget_Leader(User.Name) or not (Party.Leader.Oid = User.Oid) then exit;
	
	partyNum := GetPartyNum;
	isMageParty := (partyNum = 1) or (partyNum = 2) or (GetSubPartyNum = 3);

	utilityName := GetName_UtilityChar_ByPartyNum(partyNum);
	oopBufferName := GetName_OopBufferChar_ByPartyNum(partyNum);
	
	if (utilityName = '') then exit;
	
	if (oopBufferName = '') then begin
		Check_InviteMember(utilityName);
	end;
	
	//If we can see both chars needed for this to work
	if CharList.ByName(utilityName, utilityChar) and CharList.ByName(oopBufferName, oopBuffer) then begin 
		
		//If we are missing buffs, and our own buffer is flagged, and the out-of-party buffer is not flagged.
		if (GetCount_MaxBuffsMissingFromAMember(60000, isMageParty) > 4) and (utilityChar.Pvp or utilityChar.Pk or utilityChar.InCombat) and not (oopBuffer.Pvp or oopBuffer.Pk or oopBuffer.InCombat) then begin
			
			//If our own buffer is in party, kick him.
			if (utilityChar.IsMember) then begin
				Engine.DismissParty(utilityChar.Name);
				result := true;
				exit;
			end;
			
			//if the out-of-party buffer is not in our party, invite him.
			if not (oopBuffer.IsMember) then begin
			
				//Make the oop buffer leave the sub party
				control := GetControl(oopBuffer.Name);
				if (ControlHasParty(control)) then begin
					ControlLeaveParty(control);
					result := true;
					exit;
				end;
					
				Engine.InviteParty(oopBuffer.Name);
				result := true;
				exit;
			end;
			
			exit;
			
		end else begin
		
			//If our own buffer is not in our party.
			if not (utilityChar.IsMember) then begin
				if (oopBuffer.IsMember) then begin
					Engine.DismissParty(oopBuffer.Name);
					result := true;
					exit;
				end;
				Engine.InviteParty(utilityChar.Name);
				result := true;
				exit;
			end;
			
			if (Party.Chars.ByName(oopBufferName, oopBuffer)) then begin
				Engine.DismissParty(oopBufferName);
				result := true;
				exit;
			end;
			//restore the party for the OOP buffer. -> get him back in sub party
			control := GetControl(oopBufferName);
			if not ControlHasParty(control) then begin
				InviteTargetToSubParty(oopBufferName);
			end;
			
			exit;
			
		end;
		
	end else begin
	
		if not Party.Chars.ByName(utilityName, utilityChar) and (Charlist.ByName(utilityName, utilityChar)) then begin
			if (Party.Chars.ByName(oopBufferName, oopBuffer)) then begin
				Engine.DismissParty(oopBufferName);
				result := true;
				exit;
			end;
			Engine.InviteParty(utilityName);
			result := true;
			exit;
		end;
	
	end;
	
	
	if (Party.Chars.ByName(oopBufferName, oopBuffer)) then Engine.DismissParty(oopBufferName);
end;

function InviteTargetToSubParty(sName : string): Boolean;
var
sSubLeaderName: string;
control: Tl2Control;
begin
	result := false;
	if (sName = '') then exit;
	
	sSubLeaderName := GetName_SubPartyLeader(GetPartyNum);
	if (sSubLeaderName = '') then exit;
	
	control := GetControl(sSubLeaderName);
	if not Assigned(control) then exit;
	
	if (control.GetParty.Chars.Count < 8) then begin
		control.InviteParty(sName);
	end else begin
		Print('WARNING: Sub Party is FULL!');
	end;
	

end;

function GetName_UtilityChar_ByPartyNum(partyNum: Integer): string;
begin
	result := '';
	if (partyNum = 1) then result := 'Ezekiel'
	else if (partyNum = 2) then result := 'Igneous'
	else if (partyNum = 3) then result := 'Eviscerator';
end;

function GetName_OopBufferChar_ByPartyNum(partyNum: Integer): string;
begin
	result := '';
	//REMEMBER TO REMOVE utility chars from normal party invitations.
	if (partyNum = 1) then result := ''
	else if (partyNum = 2) then result := ''
	else if (partyNum = 3) then result := '';
end;



end.